<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml">

<head>
	<meta charset="UTF-8" />
	<meta name="author" content="Garret Wilson" />
	<title>Simple URF (SURF) Specification</title>
	<link type="text/css" rel="stylesheet" href="../../pub/css/globalmentor-doc.css" />
</head>

<body>
	<h1>Simple URF (SURF) Specification</h1>
	<h2>Introduction</h2>
	<p><dfn>Simple URF</dfn> (<abbr>SURF</abbr>) is a compact, text-based, human-readable persistence format for a directed graph of data values. It is similar in purpose to JSON yet less verbose and more expressive, supporting for example a greater number of types. Moreover as one of the primary serializations (along with <abbr title="Text URF">TURF</abbr>) of the <dfn>Uniform Resource Format</dfn> (<abbr>URF</abbr>), it is compatible with rigorous semantic frameworks such as the <dfn>Resource Description Framework</dfn> (<abbr>RDF</abbr>).</p>
	<h3>Definitions</h3>
	<dl>
		<dt>SURF Parser</dt>
		<dd>Any software component that interprets SURF syntax and produces an appropriate data model according to this specification.</dd>
		<dt>SURF Generator</dt>
		<dd>An software that produces SURF syntax complying with this specification to reflect some data model.</dd>
	</dl>
	<h3>Design Constraints</h3>
	<p><em>This section is non-normative.</em></p>
	<p>The following considerations were used to guide the creation of this specification:</p>
	<ul>
		<li>SURF <span class="spec-must">must</span> support the Unicode character set for text values.</li>
		<li>SURF <span class="spec-should">should</span> support the Unicode character set for identifiers and comments.</li>
		<li>SURF <span class="spec-must">must</span> use only ASCII characters for delimiters.</li>
		<li>All valid JSON documents <span class="spec-must">must</span> also be valid SURF documents.</li>
		<li>All valid SURF documents <span class="spec-must">must</span> also be valid TURF document body content.</li>
		<li>SURF <span class="spec-must">must</span> allow for distinctions among vocabularies of identifiers.</li>
		<li>SURF <span class="spec-must-not">must not</span> require namespace IRIs to be declared.</li>
	</ul>
	<h3>Conventions Used in this Document</h3>
	<p>The key words <q><span class="spec-must">must</span></q>, <q><span class="spec-must-not">must not</span></q>, <q><span class="spec-must">required</span></q>, <q><span class="spec-must">shall</span></q>, <q><span class="spec-must-not">shall not</span></q>, <q><span class="spec-should">should</span></q>, <q><span class="spec-should-not">should not</span></q>, <q><span class="spec-should">recommended</span></q>, <q><span class="spec-may">may</span></q>, and <q><span class="spec-may">optional</span></q> in this document are to be interpreted as described in <a href="#ref-rfc2119" class="ref">RFC 2119</a>. Prose and asides marked as <span class="note">note</span> are non-normative.</p>
	<h2>Internet Media Type</h2>
	<p>The Internet media type (<a href="#ref-rfc2046" class="ref">RFC 2046</a>, <a href="#ref-rfc6657" class="ref">RFC 6657</a>) of a SURF document <span class="spec-must">shall</span> be <code>text/surf</code> and <span class="spec-must">shall</span> be encoded in UTF-8, UTF-16, or UTF-32. SURF processors <span class="spec-must">must</span> support UTF-8. Implementations <span class="must not">must not</span> add a byte order mark to the beginning of content, but <span class="spec-may">may</span> use any byte order mark to determine the encoding.</p>
	<h2>Structure</h2>
	<p>The content of a SURF document encodes a a graph of <dfn>resources</dfn> defined by the Uniform Resource Framework (TODO reference) with a single resource as the root of the graph. A SURF document <span class="spec-may">may</span> be empty, containing no resources.</p>
	<h3>Whitespace</h3>
	<aside class="note far third">SURF follows the <cite>ECMAScript® 2016</cite> definition of <q>WhiteSpace</q>. <span class="see">See <a href="http://www.ecma-international.org/ecma-262/7.0/#sec-white-space"><cite>ECMA-262 7<sup>th</sup> Edition: 11.2 White Space</cite></a>.</span></aside>
	<p>SURF consider the following characters as <dfn>whitespace</dfn>, including characters in the Unicode <code class="name">Space_Separator</code> (<code>Zs</code>) category.</p>
	<ul>
		<li><code class="name">whitespace</code> ⇒ <code class="name">tab</code> | <code class="name">vtab</code> |  <code class="name">ff</code> | <code class="name">sp</code> | <code class="name">nbsp</code> | <code class="name">zwnbspr</code> | <code class="name">Space_Separator</code></li>
		<li><code class="name">tab</code> ⇒ <code class="unicode">U+0009</code> <code class="name">CHARACTER TABULATION</code></li>
		<li><code class="name">vtab</code> ⇒ <code class="unicode">U+000B</code> <code class="name">LINE TABULATION</code></li>
		<li><code class="name">ff</code> ⇒ <code class="unicode">U+000C</code> <code class="name">FORM FEED (FF)</code></li>
		<li><code class="name">sp</code> ⇒ <code class="unicode">U+0020</code> <code class="name">SPACE</code></li>
		<li><code class="name">nbsp</code> ⇒ <code class="unicode">U+00A0</code> <code class="name">NO-BREAK SPACE</code></li>
		<li><code class="name">zwnbspr</code> ⇒ <code class="unicode">U+FEFF</code> <code class="name">ZERO WIDTH NO-BREAK SPACE</code></li>
	</ul>
	<h3>Lines</h3>
	<h4>Line Endings</h4>
	<p>SURF recognizes both the <code class="name">CARRIAGE RETURN (CR)</code> character <code class="unicode">U+000D</code>, the <code class="name">LINE FEED (LF)</code> character <code>U+000A</code>, and any Unicode <code class="name">Line_Separator</code> (<code>Zl</code>) or <code class="name">Paragraph_Separator</code> (<code>Zp</code>) character as marking the end of a line. A SURF processor <span class="spec-must">must</span> behave as if every <code class="name">CRLF</code> sequence as well as every <code>CR</code> not followed by a <code class="name">LF</code> were normalized to a single <code class="name">LF</code>. A SURF generator [TODO define] <span class="spec-should">should</span> use the conventional line ending sequence supported by the platform on which it is running if that sequence is allowed by this specification.</p>
	<ul>
		<li><code class="name">eol</code> ⇒ <code class="name">cr</code> | <code class="name">lf</code> | <code class="name">Line_Separator</code> | <code class="name">Paragraph_Separator</code></li>
		<li><code class="name">cr</code> ⇒ <code class="unicode">U+000D</code> <code class="name">CARRIAGE RETURN (CR)</code></li>
		<li><code class="name">lf</code> ⇒ <code class="unicode">U+000A</code> <code class="name">LINE FEED (LF)</code></li>
	</ul>
	<h4>Line Breaks</h4>
	<aside class="tip far third">A parser may simply discard line comments and parse the SURF document as if they were not present.</aside>
	<p>A line comment may appear before the end of any line. A line comment begins with the <code class="name">EXCLAMATION MARK</code> character <code>!</code> (<code class="unicode">U+0021</code>) and proceeds to the next line ending character.</p>
	<ul class="spec-rule">
		<li><code class="name">line_break</code> ⇒ <code class="name">line_comment</code>? <code class="name">eol</code></li>
		<li><code class="name">line_comment</code> ⇒ ! [^<code>eol</code>]*</li>
	</ul>
	<h3>Sequences</h3>
	<p>Several SURF types allow components to be presented in a <dfn>sequence</dfn>. A sequence is a syntactical construct indicated by the form <code class="name"><var>item</var>-sequence</code>, where <code><var>item</var></code> is the construct that may appear zero or more times in the sequence.</p>
	<aside class="note far third">The list separator is a SURF innovation that allows sequences to be represented in compact form using commas in the JSON style, or in a more human-readable format separated by newlines in the YAML style.</aside>
	<p>Any two items in a sequence are separated by a <dfn>sequence separator</dfn>, which is either a <code class="name">COMMA</code> character <code>,</code> (<code class="unicode">U+002C</code>) optionally surrounded by line line breaks; or one or more line breaks without a <code class="name">COMMA</code> character. If a <code class="name">COMMA</code> character is present, an item <span class="spec-must">must</span> follow. <span class="note">This means that one or more line breaks <span class="spec-may">may</span> end a sequence or appear in an empty sequence.</span>
	</p>
	<ul class="spec-rule">
		<li><code class="name">item-sequence</code> ⇒ <code class="name">line_break</code>* [ <code class="name">item</code> [ <code class="name">sequence_separator_must</code> <code class="name">item</code> | <code class="name">sequence_separator_may</code> <code class="name">item</code>? ]* ]</li>
		<li><code class="name">sequence_separator_must</code> ⇒ <code class="name">line_break</code>* ',' <code class="name">line_break</code>*</li>
		<li><code class="name">sequence_separator_may</code> ⇒ <code class="name">line_break</code>+</li>
	</ul>
	<h3>Names</h3>
	<figure class="far side">
		<figcaption>Example SURF names.</figcaption>
		<ul>
			<li><code class="language-surf">foo</code></li>
			<li><code class="language-surf">fooBar</code></li>
			<li><code class="language-surf">foo_bar</code></li>
			<li><code class="language-surf">touché</code></li>
			<li><code class="language-surf">काम</code></li>
			<li><code class="language-surf">chem-salt</code></li>
			<li><code class="language-surf">crypto-salt</code></li>
			<li><code class="language-surf">User</code></li>
			<li><code class="language-surf">chem-Molecule</code></li>
		</ul>
	</figure>
	<p>A <dfn>name</dfn> in SURF must begin with a character from the Unicode <code class="name">Letter</code> (<code>L</code>) category; followed by zero or more characters each from the <code class="name">Letter</code> (<code>L</code>) category, from the <code class="name">Mark</code> (<code>M</code>) category, from the <code class="name">Decimal_Number</code> (<code>Nd</code>) category, <code class="name">Connector_Punctuation</code> (<code>Pc</code>) category, or the <code class="name">HYPHEN-MINUS</code> character <code>-</code> (<code class="unicode">U+002D</code>).</p>
	<ul class="spec-rule">
		<li><code class="name">name</code> ⇒ <code class="name">Letter</code> (<code class="name">Letter</code> | <code class="name">Mark</code> | <code class="name">Decimal_Number</code> | <code class="name">Connector_Punctuation</code> | '-')*</li>
	</ul>
	<h2>Resources</h2>
	<p>A SURF document <span class="spec-must">must</span> contain at most a single <dfn>resource</dfn>, which may recursively contain other resources. A resource consists of an optional <dfn>label</dfn> followed by a <dfn>resource representation</dfn>.</p>
	<ul class="spec-rule">
		<li><code class="name">resource</code> ⇒ [<code class="name">label</code>] <code class="name">resource_representation</code> | <code class="name">label</code></li>
		<li><code class="name">resource_representation</code> ⇒ <code class="name">object</code> | <code class="name">binary</code> | <code class="name">boolean</code> | <code class="name">character</code> | <code class="name">decimal</code> | <code class="name">iri</code> | <code class="name">number</code> | <code class="name">regex</code> | <code class="name">string</code> | <code class="name">temporal</code> | <code class="name">uuid</code> | <code class="name">list</code> | <code class="name">map</code> | <code class="name">set</code> | <code class="name">table</code></li>
	</ul>
	<p> A label consists of an identifier surrounded by matching <code class="name">VERTICAL LINE</code> characters <code>|</code> (<code class="unicode">U+007C</code>).</p>
	<ul class="spec-rule">
		<li><code class="name"> label</code> ⇒ '|' <code class="name">name</code> '|'</li>
	</ul>
	<p>The first occurrence of a label with a particular identifier <span class="spec-may">may</span> include a resource representation. Subsequent appearances of a label with the same identifier <span class="spec-must-not">must not</span> include a resource representation. A nested resource representation <span class="spec-may">may</span> refer to the label of an outer resource in the graph.</p>
	<h3>Objects</h3>
	<p>Objects are descriptions of unidentified resources.</p>
	<ul class="spec-rule">
		<li><code class="name">object_begin</code> ⇒ '*'</li>
		<li><code class="name">object</code> ⇒ <code class="name">object_begin</code> [<code class="name">type</code>] [<code class="name">properties</code>]</li>
		<li><code class="name">type</code> ⇒ <code class="name">name</code></li>
		<li><code class="name">properties</code> ⇒ ':' <code class="name">property-sequence</code> ';'</li>
		<li><code class="name">property</code> ⇒ <code class="name">name</code> <code class="name">line_break</code>* = <code class="name">line_break</code>* <code class="name">resource</code></li>
	</ul>
	<p>An <code class="name">eol</code> <span class="spec-must-not">must not</span> appear between an <code class="name">object_begin</code> and a <code class="name">type</code>, or between a <code class="name">type</code> and any following <code class="name">properties</code>. </p>
	<p>TODO recommend not to use "true" or "false" as property names, because the semantics in URF are different than expected</p>
	<p>An object <span class="spec-must-not">must not</span> contain more than one <code class="name">property</code> with the same <code class="name">name</code>, and a SURF processor <span class="spec-must">must</span> consider such a condition as a non-recoverable error.</p>
	<h3>Literals</h3>
	<aside class="note far third">Literals are a way to represent URF <dfn>lexical identity resources</dfn>, those resources that can be identified by a lexical representation. TURF provides other ways of representing these resources in addition to literals.</aside>
	<p>SURF <dfn>literals</dfn> are lexical representations of resources.</p>
	<h4>Binary</h4>
	<p>URF allows the encoding of an arbitrary sequence of octets. Zero or more bytes <span class="spec-must">must</span> be encoded using the <q>Base 64 Encoding</q> defined in <a href="#ref-rfc4648" class="ref">RFC 4648</a>, surrounded on both sides by the <code class="name">PERCENT SIGN</code> character <code>%</code> (<code class="unicode">U+0025</code>). The encoding <span class="spec-should">should</span> include Base 64 padding, although a SURF parser <span class="spec-must">must</span> accept binary data that does not include such padding.</p>
	<ul class="spec-rule">
		<li><code class="name">binary</code> ⇒ '%' rfc_4648_base_64 '%'</li>
	</ul>
	<h4>Boolean</h4>
	<p>A Boolean is a either of the tokens <code>true</code> or <code>false</code>.</p>
	<ul class="spec-rule">
		<li><code class="name">boolean</code> ⇒ "false" | "true"</li>
	</ul>
	<h4>IRI</h4>
	<p>An <dfn>Internationalized Resource Identifiers</dfn> (<abbr>IRI</abbr>) is a sequence of Unicode characters for identifying a resource as defined in <a href="#ref-rfc3987" class="ref">RFC 3987</a>. In SURF an IRI is placed between a <code class="name">LESS-THAN SIGN</code> character <code>&lt;</code> (<code class="unicode">U+003C</code>) and a <code class="name">GREATER-THAN SIGN</code> character <code>&gt;</code> (<code class="unicode">U+003E</code>).</p>
	<ul class="spec-rule">
		<li><code class="name">iri</code> ⇒ '&lt;' rfc_3987_IRI '&gt;'</li>
	</ul>
	<h4>Regular Expression</h4>
	<aside class="note far third">SURF regular expressions are syntactically identical to those defined in <cite>ECMAScript® 2016</cite>, except that SURF allows empty regular expressions. <span class="see">See <a href="http://www.ecma-international.org/ecma-262/7.0/#sec-literals-regular-expression-literals"><cite>ECMA-262 7<sup>th</sup> Edition: 11.8.5 Regular Expression Literals</cite></a>.</span></aside>
	<p>A regular expression is surrounded by slash or <code class="name">SOLIDUS</code> character <code>/</code> (<code class="unicode">U+002F</code>). The backslash or <code class="name">REVERSE SOLIDUS</code> <code>\</code> (<code class="unicode">U+005C</code>) is interpreted as as an escape character only if followed by a slash character <code>/</code>.</p>
	<p>TODO decide on whether and how to allow flags</p>
	<p>TODO production</p>
	<h4>String</h4>
	<aside class="note far third"><span class="see">Compare to <a href="https://tools.ietf.org/html/rfc7159"><cite>RFC 7159: The JavaScript Object Notation (JSON) Data Interchange Format</cite></a>.</span></aside>
	<p>A string represents a sequence of Unicode code points, delimited on both sides by the <code class="name">QUOTATION MARK</code> character <code>"</code> (<code class="unicode">U+0022</code>). The backslash or <code class="name">REVERSE SOLIDUS</code> <code>\</code> (<code class="unicode">U+005C</code>) is used as as an escape character. The <code class="name">QUOTATION MARK</code> , <code class="name">REVERSE SOLIDUS</code>, and control characters <span class="spec-must-not">must not</span> appear in a string unless they are escaped. The following escape sequences are allowed</p>
	<dl>
		<dt><code>\\</code></dt>
		<dd><code class="name">REVERSE SOLIDUS</code> (<code class="unicode">U+005C</code>)</dd>
		<dt><code>\/</code></dt>
		<dd><code class="name">SOLIDUS</code> (<code class="unicode">U+002F</code>)</dd>
		<dt><code>\"</code></dt>
		<dd><code class="name">QUOTATION MARK</code> (<code class="unicode">U+0022</code>)</dd>
		<dt><code>\b</code></dt>
		<dd><code class="name">BACKSPACE</code> (<code class="unicode">U+0008</code>)</dd>
		<dt><code>\f</code></dt>
		<dd><code class="name">FORM FEED (FF)</code> (<code class="unicode">U+000C</code>)</dd>
		<dt><code>\n</code></dt>
		<dd><code class="name">LINE FEED (LF)</code> (<code class="unicode">U+000A</code>)</dd>
		<dt><code>\r</code></dt>
		<dd><code class="name">CARRIAGE RETURN (CR)</code> (<code class="unicode">U+000D</code>)</dd>
		<dt><code>\t</code></dt>
		<dd><code class="name">CHARACTER TABULATION</code> (<code class="unicode">U+0009</code>)</dd>
		<dt><code>\v</code></dt>
		<dd><code class="name">LINE TABULATION</code> (<code class="unicode">U+000B</code>)</dd>
		<dt><code>\u<var>XXXX</var></code></dt>
		<dd>Any 16-bit Unicode code point encoding, where <var><code>XXXX</code></var> is four hexadecimal digits in any case. Escaped Unicode code points outside the Basic Multilingual Plane <span class="spec-must">must</span> be represented as two UTF-16 surrogate characters.</dd>
	</dl>
	<p> TODO production</p>
	<h3>Collections</h3>
	<p>Collection resources represent abstract data types that can hold other resources.</p>
	<h4>List</h4>
	<aside class="note far third">Examples of list types SURF processors may use include:
		<dl>
			<dt>Java</dt>
			<dd><a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html"><code class="see">java.util.List&lt;E&gt;</code></a></dd>
			<dt>JavaScript</dt>
			<dd><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" class="see">Array</a></dd>
			<dt>Python</dt>
			<dd><a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" class="see">list</a></dd>
		</dl>
	</aside>
	<p>A SURF <dfn>list</dfn> is an ordered sequence of zero or more resources, beginning with a <code class="name">LEFT SQUARE BRACKET</code> character <code>[</code> (<code class="unicode">U+005B</code>) and ending with a <code class="name">RIGHT SQUARE BRACKET</code> character <code>]</code> (<code class="unicode">U+005D</code>). A SURF processor should represent a SURF list using an corresponding language construct that represents list semantics.</p>
	<ul class="spec-rule">
		<li><code class="name">list</code> ⇒ '[' <code class="name">resource-sequence</code> ']'</li>
	</ul>
	<h2>References</h2>
	<dl>
		<dt id="ref-rfc2046" class="ref-target">RFC 2046</dt>
		<dd><a href="https://tools.ietf.org/html/rfc2046"><cite>Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</cite></a>, N. Freed, Innosoft, N. Borenstein. IETF.</dd>
		<dt id="ref-rfc2119" class="ref-target">RFC 2119</dt>
		<dd><a href="https://tools.ietf.org/html/rfc2119"><cite>Key words for use in RFCs to Indicate Requirement Levels</cite></a>, S. Bradner, Harvard University. IETF.</dd>
		<dt id="ref-rfc3987" class="ref-target">RFC 3987</dt>
		<dd><a href="https://tools.ietf.org/html/rfc3987"><cite>Internationalized Resource Identifiers (IRIs)</cite></a>, M. Duerst, W3C, M. Suignard, Microsoft Corporation. IETF.</dd>
		<dt id="ref-rfc4648" class="ref-target">RFC 4648</dt>
		<dd><a href="https://tools.ietf.org/html/rfc4648"><cite>The Base16, Base32, and Base64 Data Encodings</cite></a>, S. Josefsson, SJD. IETF.</dd>
		<dt id="ref-rfc6657" class="ref-target">RFC 6657</dt>
		<dd><a href="https://tools.ietf.org/html/rfc6657"><cite>Update to MIME regarding "charset" Parameter Handling in Textual Media Types</cite></a>, A. Melnikov, Isode Limited, J. Reschke, greenbytes. IETF.</dd>
	</dl>
	<footer><small>Copyright © 2016–2017 GlobalMentor, Inc. All Rights Reserved. Content may not be published or reproduced by any means for any purpose without permission. Version 2017-04-08.</small></footer>
	<script src="../../pub/js/prism.js"></script>
</body>

</html>
