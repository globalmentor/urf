<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Uniform Resource Framework (URF)</title>

    <link href="http://www.globalmentor.com/css/specification.css"
          rel="stylesheet" type="text/css" />
  </head>

  <body>
    <h1>Uniform Resource Framework (URF)</h1>

    <p>Copyright © 2007 <a href="http://www.globalmentor.com/">GlobalMentor,
    Inc.</a> This specification may be freely used but only in unmodifed
    form.</p>

    <dl>
      <dt>Author</dt>

      <dd><a href="http://www.garretwilson.com/">Garret Wilson</a></dd>

      <dt>Version</dt>

      <dd>2007-12-13</dd>
    </dl>

    <p>The Uniform Resource Framework (URF) provides a consistent way for
    representing resources and their relationships. URF and its interchange
    formats are useful for data storage, data interchange, data querying, and
    logical inferences. URF together with its interchange formats provides a
    more powerful yet in many ways simpler and more consistent replacement for
    data-oriented XML, RDF, and JSON.</p>

    <p>This document defines the Uniform Resource Framework (URF) as an
    abstract model, and also defines a text-based representation format, Text
    URF (TURF). This document does not yet provide a description of the binary
    representation format Serial URF (SURF), or the XML-based format XML URF
    (XMURF).</p>

    <h2>Conventions</h2>

    <p>When this document refers to "URF", it indicates a model for
    representing a community of knowledge abstract from any representation
    format. When this document refers to "TURF", it indicates the textual
    representation of URF. Because abstract concepts must be textualized to be
    communicated in a text-based specification, at times a description of the
    URF abstract model will use TURF notation for clarification of the
    model.</p>

    <h2>Ontologies</h2>

    <p>The following are official URF ontologies sanctioned by this
    specification, with links to their formal definitions in TURF:</p>

    <dl>
      <dt id="urf"><a href="urf.turf">URF</a></dt>

      <dd>The core URF ontology for defining resources.</dd>

      <dt id="content"><a href="content.turf">Content</a></dt>

      <dd>The URF ontology for describing the content of a resource, such as
      content type, size, and actual content bytes.</dd>

      <dt id="select"><a href="select.turf">Select</a></dt>

      <dd>The URF ontology for selecting resources and other objects.</dd>

      <dt id="vcard"><a href="vcard.turf">VCard</a></dt>

      <dd>The URF ontology for describing person resource or white-pages type
      of directory information as described in [<a href="#rfc2426">RFC
      2426</a>].</dd>
    </dl>

    <h2>URF and TURF Quick Start</h2>

    <p>The following is the URI <code>http://urf.name/urf#janedoe</code>:</p>

    <blockquote>
      <pre><code>&lt;http://example.com/example#janedoe&gt;</code></pre>
    </blockquote>

    <p>The following is the resource identified by the URI
    <code>http://urf.name/urf#janedoe</code>:</p>

    <blockquote>
      <pre><code>«http://example.com/example#resource»</code></pre>
    </blockquote>

    <p>That resource may be stored in a TURF interchange document:</p>

    <blockquote>
      <pre><code>`URF
¤
  «http://example.com/example#janedoe»
.</code></pre>
    </blockquote>

    <p>For namespaced resource URIs, the URI reference can be replaced with a
    name reference. Namespaces are declared in a TURF preamble section
    surrounded by the colon <code>':'</code> and semicolon <code>';'</code>
    characters, separated by commas using the tilde character <code>'~'</code>
    to associate the namespace prefix with the namespace URI. The following
    example identifies the same resource as in the previous example.</p>

    <blockquote>
      <pre><code>`URF:
  "example"~&lt;http://example.com/example&gt;
;
¤
  example.janedoe
.</code></pre>
    </blockquote>

    <p>The following is the same resource with a type of
    <code>foaf.Person</code> and with other properties declared. Strings and
    numbers are resources and can themselves be described. The salary value
    resource is given a scoped property indicating the currency. The currency
    resource is identified using a lexical namespace for the
    <code>example.Currency</code> type. Comments begin with a dagger and end
    with a double dagger.</p>

    <blockquote>
      <pre><code>`URF:

††††††††††††††††††††††††††††††††††††††††††††††††††††††††††††††††
†
† This is an example TURF interchange document.
† Comments can be terse or verbosely readable.
†
††††††††††††††††††††††††††††††††††††††††††††††††††††††††††††††††‡

  †declare the example and foaf namespaces‡
  "example"~&lt;http://example.com/example&gt;,
  "foaf"~&lt;http://xmlns.com/foaf/0.1/&gt;
;
¤
  †describe a FOAF person identified by the URI &lt;http://example.com/example#janedoe&gt;‡
  example.janedoe(foaf.Person):
    example.name="Jane Doe",
    example.birthday=@1980-01-01,
    example.salary=#1000000:
      example.currency`=«"usd"(example.Currency)»
    ;
  ;
.</code></pre>
    </blockquote>

    <p>The following is semantically equivalent to the preceding example but
    uses long URI references and no comments:</p>

    <blockquote>
      <pre><code>`URF
¤
  «http://example.com/example#janedoe»:
    «http://urf.name/urf#type»=«http://xmlns.com/foaf/0.1/Person»,
    «http://example.com/example#name»=«http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23String#Jane%20Doe»,
    «http://example.com/example#birthday»=«http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23Date#1980-01-01»,
    «http://example.com/example#salary»=«http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23Integer#1000000»:
      «http://example.com/example#currency»`=«http://urf.name/lexical/http%3A%2F%2Fexample.com%2Fexample%23Currency#usd»
    ;
  ;
.</code></pre>
    </blockquote>

    <p>This is the proposition, "The moon is made of cheese."</p>

    <blockquote>
      <pre><code>`URF:
  "example"~&lt;http://example.com/example&gt;
;
¤
  “example.moon, example.madeOf, example.cheese”
.</code></pre>
    </blockquote>

    <p>It can be asserted that Little Johnny believes the moon is made of
    cheese:</p>

    <blockquote>
      <pre><code>`URF:
  "example"~&lt;http://example.com/example&gt;
;
¤
  example.littleJohnny:
    example.believes=“example.moon, example.madeOf, example.cheese”
  ;
.</code></pre>
    </blockquote>

    <p>It can also be asserted that the moon is made of cheese and that Little
    Johnny believes this to be true:</p>

    <blockquote>
      <pre><code>`URF:
  "example"~&lt;http://example.com/example&gt;
;
¤
  example.moon:
    example.madeOf|cheeseMoon|=example.cheese
  ;
  example.littleJohnny:
    example.believes=|cheeseMoon|
  ;
.</code></pre>
    </blockquote>

    <p>The following indicates that a knowledge community long ago held the
    moon to be made of cheese:</p>

    <blockquote>
      <pre><code>`URF:
  "urf"~&lt;http://urf.name/urf&gt;,
  "example"~&lt;http://example.com/example&gt;
;
¤
  example.community(urf.Community):
    example.when=example.longAgo
  ;
  {
    “example.moon, example.madeOf, example.cheese”
  }
.</code></pre>
    </blockquote>

    <p>The following example is semantically identical to the previous one but
    uses the community short form:</p>

    <blockquote>
      <pre><code>`URF:
  "urf"~&lt;http://urf.name/urf&gt;,
  "example"~&lt;http://example.com/example&gt;
;
¤
  example.community(urf.Community):
    example.when=example.longAgo
  ;
  ¤
    example.moon:
      madeOf=example.cheese
  .
.</code></pre>
    </blockquote>

    <h2>Primer</h2>

    <h3>Resources</h3>

    <dl>
      <dt>URF</dt>

      <dd><p>Everything that can be described by URF is referred to as a
      <dfn>resource</dfn>. Every resource is an instance of the class
      <code>urf.Resource</code>. A group of described resources is referred to
      as an <dfn>URF instance</dfn>.</p></dd>

      <dt>TURF</dt>

      <dd><p>A resource can be described within a colon-semicolon pair.
      Multiple resources are separated by commas. The following example refers
      to an anonymous resource:</p><blockquote>
          <pre><code>:;</code></pre>
        </blockquote><p>A resource can optionally be given a label which can
      be used as a short representation to refer the resource only within the
      interchange document. A resource label is a <a href="#name">name</a>
      placed in front of a resource description and surrounded by vertical
      bars, as in the following example:</p><blockquote>
          <pre><code>|label|:;</code></pre>
        </blockquote></dd>
    </dl>

    <h3>Resource Identification</h3>

    <dl>
      <dt>URF</dt>

      <dd><p>A resource may be <dfn>anonymous</dfn> or may be identified by a
      URI.</p></dd>

      <dt>TURF</dt>

      <dd><p>A URI is indicated by angle brackets. The following example
      indicates the URI represented by the characters
      <code>http://example.com/example#resource</code>:</p><blockquote>
          <pre><code>&lt;http://example.com/example#resource&gt;</code></pre>
        </blockquote><p>A resource may be identified by placing its URI
      characters within angle quotes; when the resource URI is given, the the
      colon and semicolon are optional if the resource has no properties. All
      URIs may be relative references, which are resolved to the base URI of
      the interchange document. The following example refers to the resource
      identified by the URI
      <code>&lt;http://urf.name/urf#resource&gt;</code>.</p><blockquote>
          <pre><code>«http://example.com/example#resource»</code></pre>
        </blockquote><p>A resource identified by URI may also be given a label
      and/or description:</p><blockquote>
          <pre><code>|label|«http://example.com/example#resource»:;</code></pre>
        </blockquote></dd>
    </dl>

    <h3>Ontologies and Namespaces</h3>

    <dl>
      <dt>URF</dt>

      <dd><p>A set of resources related to the same domain may be grouped
      together into an <dfn>ontology</dfn>. If all resources within an
      ontology to have similar URIs, each constructed by relative to the
      ontology URI, the URI of the ontology is said to be a
      <dfn>namespace</dfn>, and each resource is said to have a <dfn>local
      name</dfn> that is combined with the namespace to create the resource
      URI. Not all resource URIs are part of some namespace. URF allows three
      types of namespaces:</p><ul>
          <li>If the namespace URI does not have a fragment and the path of
          the namespace URI does not end with the slash character
          <code>'/'</code>, the URI is formed by URI-encoding all
          non-<var>pchar</var> characters of the local name according to [<a
          href="#rfc3986">RFC 3986</a>] and adding the result to the namespace
          URI as a fragment. For example, a namespace URI of
          <code>&lt;http://urf.name/name&gt;</code> and a local name of
          <code>"type"</code> yield a namespace URI of
          <code>&lt;http://urf.name/name#type&gt;</code>.</li>

          <li>If the namespace URI does not have a fragment and the path of
          the namespace URI ends with the slash character <code>'/'</code>,
          the URI is formed by URI-encoding all non-<var>pchar</var>
          characters of the local name according to [<a href="#rfc3986">RFC
          3986</a>] and appending the result to the namespace URI. For
          example, a namespace URI of
          <code>&lt;http://purl.org/dc/elements/1.1/&gt;</code> and a local
          name of <code>"title"</code> yield a resource URI of
          <code>&lt;http://purl.org/dc/elements/1.1/title&gt;</code>.</li>

          <li>If the namespace URI has a fragment and the fragment does not
          end with the slash character <code>'/'</code>, the URI is formed by
          URI-encoding all non-<var>pchar</var> characters of the local name
          according to [<a href="#rfc3986">RFC 3986</a>] , prepending a slash
          character, and appending the result to original fragment. For
          example, a namespace URI of
          <code>&lt;http://example.com/base#namespace&gt;</code> and a local
          name of <code>"demo"</code> yield a resource URI of
          <code>&lt;http://example.com/base#namespace/demo&gt;</code>.</li>
        </ul><p>A namespace URI therefore may never have a fragment identifier
      that ends with a slash character <code>'/'</code>. These rules allow the
      namespace and local name to be unambiguously determined given any URI
      within a namespace.</p></dd>

      <dt>TURF</dt>

      <dd><p>A resource within a namespace can be identified by a <dfn>name
      reference</dfn> by listing the unencoded local name of the resource,
      with an optional prefix separated by full stop or period. The prefix, if
      present, is a string that has been associated with some namespace URI
      using a tilde character <code>'~'</code> in the TURF preamble, which is
      surrounded by colon <code>':'</code> and semicolon <code>';'</code>
      characters. If a property name reference has no prefix, the namespace is
      the URI of the type of the subject resource. No other resources may have
      name references without prefixes.</p><p>In the following example, the
      name reference <code>component.Button</code> is equivalent to the URI
      reference <code>«java:/com/guiseframework/component/Button»</code>, and
      the name reference of its sole property, <code>label</code>, is
      equivalent to the URI reference
      <code>«java:/com/guiseframework/component/Button#label»</code>. Another
      resource is also described that uses name references with prefixes for
      its URI, type, and property.</p><blockquote>
          <pre><code>`URF:
  "component"~&lt;java:/com/guiseframework/component/&gt;,
  "example"~&lt;http://example.com/example&gt;,
  "foaf"~&lt;http://xmlns.com/foaf/0.1/&gt;
;
¤
  (component.Button):
    label="Convert"
  ;,
  example.janedoe(foaf.Person):
    example.name="Jane Doe"
  ;
.</code></pre>
        </blockquote>Namespace declarations within a TURF document are purely
      syntactical, and make no separate appearance in the resulting URF
      instance.</dd>
    </dl>

    <p>This specification uses resources in the following namespaces, with
    corresponding prefixes:</p>

    <dl>
      <dt><code>"dc"~&lt;http://purl.org/dc/elements/1.1/&gt;</code></dt>

      <dd>The Dublin Core Metadata Initiative namespace [<a
      href="#dcmiNamespace">DCMI Namespace</a>].</dd>

      <dt><code>"example"~&lt;http://example.com/example&gt;</code></dt>

      <dd>An example namespace; used for hypothetical situations.</dd>

      <dt><code>"urf"~&lt;http://urf.name/urf&gt;</code></dt>

      <dd>The URF namespace for resource and properties related to the
      framework abstract model itself.</dd>
    </dl>

    <h3>Properties</h3>

    <dl>
      <dt>URF</dt>

      <dd><p>A resource may be related to another resource by the use of a
      <dfn>property</dfn>. Every property is itself a resource, although it is
      not implicitly an instance of the class <code>urf.Property</code> unless
      declared to be so. A resource <dfn>subject</dfn>, a property
      <dfn>predicate</dfn>, and the related resource <dfn>object</dfn>
      together make an <dfn>assertion</dfn> about the universe being
      described.</p><p>An infinite number of assertions may be made about a
      single subject resource. Repeated assertions about a subject resource
      with the same same predicate property and the same object resource are
      considered identical.</p></dd>

      <dt>TURF</dt>

      <dd><p>Assertions about a particular subject resource are presented
      within curly brackets and separated by commas. Each predicate property
      and object resource pair of an assertion are separated by an equals
      character. Object resources, like resources in other contexts, can serve
      as the subject of other property assertions. In the following example,
      the resource <code>«http://example.com/example#resource»</code> has a
      single property <code>«http://example.com/example#property»</code>,
      which has as its value another resource,
      <code>«http://example.com/example#value»</code>:</p><blockquote>
          <pre><code>`URF
¤
  «http://example.com/example#resource»:
    «http://example.com/example#property»=«http://example.com/example#value»
  ;
.</code></pre>
        </blockquote><p>By associating the namespace
      <code>&lt;http://example.com/example&gt;</code> with the prefix string
      <code>"example"</code>, the above example could be represented in the
      following representation:</p><blockquote>
          <pre><code>`URF:
  "example"~&lt;http://example.com/example&gt;
;
¤
  example.resource:
    example.property=example.value
  ;
.</code></pre>
        </blockquote></dd>
    </dl>

    <h3>Classes</h3>

    <dl>
      <dt>URF</dt>

      <dd><p>A resource may represent a <dfn>class</dfn> or set of resources
      containing instances of other resources. As stated earlier, for example,
      all resources are implicitly instances of the class
      <code>urf.Resource</code>. Any resource may be explicitly asserted to be
      an instance of some class by identifying the class resource as a value
      of the <code>urf.type</code> property.</p></dd>

      <dt>TURF</dt>

      <dd><p>It can be asserted that a resource is an instance of a class by
      normal representation of the <code>urf.type</code> property. In the
      following example, the resource <code>example.resource</code> is
      asserted to be an instance of the class
      <code>example.Class</code>:</p><blockquote>
          <pre><code>`URF:
  "urf"~&lt;http://urf.name/urf&gt;,
  "example"~&lt;http://example.com/example&gt;
;
¤
  example.resource:
    urf.type=example.Class,
    example.property=example.value
  ;
.</code></pre>
        </blockquote><p>As a shorthand representation, that a resource is an
      instance of one or more classes may be represented by placing the class
      resource after the resource reference surrounded by parentheses.
      Multiple classes may be separated by commas, and are added as <a
      href="#orderedProperties">ordered properties</a>. The following example
      is semantically identical to the preceding example.</p><blockquote>
          <pre><code>`URF:
  "example"~&lt;http://example.com/example&gt;
;
¤
  example.resource(example.Class):
    example.property=example.value
  ;
.</code></pre>
        </blockquote></dd>
    </dl>

    <h3>URF Types</h3>

    <p>URF and its standard ontologies comes with several built-in types,
    including:</p>

    <dl>
      <dt><code>urf.Binary</code></dt>

      <dd>Binary resources represent arbitrarily long sequences of bytes.
      Binary resources use the appropriate lexical namespace for their type,
      with a lexical form of the <dfn>base64url</dfn> encoding of the binary
      data without line breaks according to [<a href="#rfc4648">RFC
      4648</a>].</dd>

      <dt><code>urf.Boolean</code></dt>

      <dd>There are two boolean resources, the values <code>true</code> and
      <code>false</code>. Boolean resources are identified by lexical
      namespace URIs with lexical representations of <code>"true"</code> and
      <code>"false"</code>, respectively.</dd>

      <dt><code>urf.Character</code></dt>

      <dd>Character resources are the Unicode code points, and their lexical
      forms are the Unicode characters represented by those code points.</dd>

      <dt><code>urf.Class</code></dt>

      <dd>Not every resource used as a class is an instance of the class
      <code>urf.Class</code>, but a resource may be declared to be of the
      class type to further specify its semantics. The class
      <code>urf.Class</code> is a subclass of the class
      <code>urf.Resource</code>.</dd>

      <dt><code>urf.Date</code></dt>

      <dd>Date resources represent calendar dates in terms of calendar year,
      calendar month, and calendar day of month. They use a lexical namespace
      with a lexical form consistent with [<a href="#rfc3339">RFC 3339</a>] of
      <code><var>YYYY</var>-<var>MM</var>-<var>DD</var></code> as defined in
      [<a href="#iso8601">ISO 8601</a>].</dd>

      <dt><code>urf.DateTime</code></dt>

      <dd>A date time resource represents a time of day on a particular
      calendar date. They use a lexical namespace with a lexical form
      combining the lexical forms of <code>urf.Date</code> and
      <code>urf.Time</code> separated by <code>T</code>:
      <code><var>YYYY</var>-<var>MM</var>-<var>DD</var>T<var>hh:</var><var>mm</var>:ss<strong>[</strong>.s<strong>+</strong><strong>]</strong><strong>[</strong><strong>(</strong>+<strong>|</strong>-<strong>)</strong><var>hh</var>:<var>mm</var><strong>]</strong></code>
      with optional UTC offset as defined in [<a href="#iso8601">ISO
      8601</a>]. A form without the optional UTC offset is said to be
      <dfn>floating</dfn> as defined in [<a href="#rfc2445">RFC 2445</a>], and
      should not be used unless a time independent of a time zone is to be
      specified. In most cases a <dfn>fixed time</dfn> is appropriate and a
      form with the UTC offset should be used. The hours component represents
      midnight as <code>00</code> and must not have a value larger than
      <code>23</code>. The UTC offset <code>-00:00</code> is not allowed;
      <code>+00:00</code> must be used instead.</dd>

      <dt><code>urf.Duration</code></dt>

      <dd>Duration resources represent lengths of time. They use a lexical
      namespace with a lexical form consistent with [<a href="#rfc2445">RFC
      2445</a>] and [<a href="#iso8601">ISO 8601</a>] of
      <code>P<strong>[</strong><var>n</var>Y<var>n</var>M<var>n</var>D<strong>]</strong><strong>[</strong>T<var>n</var>H<var>n</var>M<var>n</var><strong>[</strong>.<var>n</var><strong>]</strong>S<strong>]</strong></code>,
      where <var>n</var> is some positive number of roman digits and at least
      the date or time section is present.</dd>

      <dt><code>urf.Enum</code></dt>

      <dd>The base class of class resources having lexical URIs the lexical
      forms of which are enumerated as class list elements.</dd>

      <dt><code>urf.Integer</code></dt>

      <dd>Integer resources are the positive whole numbers, the negative whole
      numbers, and zero. They are identified by lexical namespace URIs with a
      lexical representation in the form
      <code><strong>[</strong>-<strong>]</strong><var>romandigit</var><strong>+</strong></code>.
      The integer class is a subclass of the class
      <code>urf.Number</code>.</dd>

      <dt><code>urf.Language</code></dt>

      <dd>Language resources represent human langages and use lexical
      namespace URIs. The lexical form of each is the corresponding
      <dfn>language tag</dfn> described in [<a href="#rfc4646">RFC
      4646</a>].</dd>

      <dt><code>urf.List</code></dt>

      <dd>List resources are resources that contain other <dfn>element</dfn>
      resources at certain <dfn>indexes</dfn> of the list. A list, like normal
      resources, may have any property, but the properties representing the
      elements of the list lie in the ordinal namespace
      <code>&lt;http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23Ordinal&gt;</code>,
      each representing the ordinal index of the element. That is, if a list
      contains an element at index 5, the element resource will appear as a
      value of the property
      <code>«http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23Ordinal#5»</code>
      (that is, the property <code>«"5"(urf.Ordinal)»</code>, or simply
      <code>º5</code>). Although many uses cases will prefer a continuous,
      unduplicated sequence of index properties beginning with
      <code>º5</code>, this is not an URF requirement.</dd>

      <dt><code>urf.Map</code></dt>

      <dd>A resource for which the properties represent key values (and are
      typically instances of <code>urf.String</code>), and for which the first
      value of each property represents the value for that key.</dd>

      <dt><code>urf.Ordinal</code></dt>

      <dd>Ordinal resources are numbers that represent the position of an
      element in a sequence. URF currently only supports finite ordinals,
      which means that there will be a corresponding ordinal for every
      positive whole numbers and zero. Ordinals are identified by lexical
      namespace URIs with a lexical representation in the form
      <code><var>romandigit</var><strong>+</strong></code>. The ordinal class
      is a subclass of the class <code>urf.</code>Number.</dd>

      <dt><code>urf.Property</code></dt>

      <dd>Not every resource used as a predicate is an instance of the class
      <code>urf.Property</code>, but a resource may be declared to be of the
      property type to further specify its semantics and expected domain and
      range. The class <code>urf.Property</code> is a subclass of the class
      <code>urf.Class</code>.</dd>

      <dt><code>urf.Real</code></dt>

      <dd>Real number are all of the measuring numbers and may include decimal
      fractional parts. They are identified by lexical namespace URIs with a
      lexical representation in the form
      <strong>[</strong>-<strong>]</strong><var>romandigit</var><strong>+</strong>.<var>romandigit</var><strong>+[</strong>e<strong>[</strong>+<strong>|</strong>-<strong>]</strong><var>romandigit</var><strong>+]</strong>.
      The integer class is a subclass of the class
      <code>urf.Number</code>.</dd>

      <dt><code>urf.RegularExpression</code></dt>

      <dd>Regular expression resources are text-based patterns that define
      rules for the content of strings. These are lexical namespace
      resources.</dd>

      <dt><code>urf.Resource</code></dt>

      <dd>Every resource is implicitly an instance of the class
      <code>urf.Resource</code>. The resources <code>urf.Property</code> and
      <code>urf.Resource</code> are both instances of the class
      <code>urf.Resource</code>.</dd>

      <dt><code>urf.Set</code></dt>

      <dd>Set resources are resources that contain at most one instance of
      other <dfn>element</dfn> resources. A set, like normal resources, may
      have any property, but the properties representing the elements of the
      set appear as values of the <code>urf.element</code> property.</dd>

      <dt><code>urf.String</code></dt>

      <dd>String resources are sequences of Unicode code points or text and
      lie in the corresponding lexical namespace.</dd>

      <dt><code>urf.Time</code></dt>

      <dd>Time resources represent time of day. They use a lexical namespace
      with a lexical form consistent with [<a href="#rfc3339">RFC 3339</a>] of
      <code><var>hh:</var><var>mm</var>:ss<strong>[</strong>.s<strong>+</strong><strong>]</strong><strong>[</strong><strong>(</strong>+<strong>|</strong>-<strong>)</strong><var>hh</var>:<var>mm</var><strong>]</strong></code>
      with optional UTC offset as defined in [<a href="#iso8601">ISO
      8601</a>]. A form without the optional UTC offset is said to be
      <dfn>floating</dfn> as defined in [<a href="#rfc2445">RFC 2445</a>], and
      should not be used unless a time independent of a time zone is to be
      specified. In most cases a <dfn>fixed time</dfn> is appropriate and a
      form with the UTC offset should be used. The hours component represents
      midnight as <code>00</code> and must not have a value larger than
      <code>23</code>. The UTC offset <code>-00:00</code> is not allowed;
      <code>+00:00</code> must be used instead.</dd>

      <dt><code>urf.URI</code></dt>

      <dd>URI resources are sequences of Unicode code points that function as
      resource identifiers and conform to [<a href="#rfc3986">RFC 3986</a>].
      They lie in the corresponding lexical namespace with a lexical form
      specified by [<a href="#rfc3986">RFC 3986</a>].</dd>

      <dt><code>urf.UTCOffset</code></dt>

      <dd>UTC offset resources represent an offset from UTC to local time.
      They use a lexical namespace with a lexical form of
      <strong>(</strong>+<strong>|</strong>-<strong>)</strong><var>hh</var>:<var>mm</var>
      with semantics corresponding to the UTC offset described in [<a
      href="#rfc2426">RFC 2426</a>] and [<a href="#rfc2445">RFC 2445</a>]. The
      UTC offset <code>-00:00</code> is not allowed; <code>+00:00</code> must
      be used instead.</dd>

      <dt><code>content.MediaType</code></dt>

      <dd>A media type resource is an Internet media types described by [<a
      href="#rfc2046">RFC 2046</a>]. Internet media types are also known as
      <dfn>MIME types</dfn> and <dfn>content types</dfn>. Media type resources
      use lexical namespace URIs, and each has a lexical form corresponding to
      its [<a href="#rfc2046">RFC 2046</a>] representation without any media
      type parameters.</dd>
    </dl>

    <h3 id="lexical">Lexical Namespaces</h3>

    <dl>
      <dt>URF</dt>

      <dd><p>Some resource types contain resource instances that in day-to-day
      life have customarily been identified by character sequences or
      <dfn><dfn>lexical representations</dfn></dfn>. For example, the integer
      <code>123</code> has historically been represented by the character
      sequence <code>"123"</code>, although the number itself is an abstract
      concept, not a series of characters. Similarly, the two boolean values
      are usually represented as the character sequences <code>"true"</code>
      and <code>"false"</code>. URF provides for a series of namespaces to
      identify resources that are typically identified by lexical
      representations. Each lexical namespace URI begins with the general URF
      lexical namespace URI <code>&lt;http://urf.name/lexical/&gt;</code> and
      has the following format,</p><blockquote>
          <pre><code>http://urf.name/lexical/<var>encodedTypeURI</var>#<var>encodedLexicalForm</var></code></pre>
        </blockquote><p>where <var>encodedTypeURI</var> is the URI path
      segment-encoded form of the full type URI of the resource, and
      <var>encodedLexicalForm</var> is the URI path segment-encoded canonical
      lexical form of the resource as defined by the indicated type. For
      example, the integer 123, which is of the type
      <code>«http://urf.name/urf#Integer»</code>, is represented in URF using
      the following URI:</p><blockquote>
          <pre><code>http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23Integer#123</code></pre>
        </blockquote><p>A resource in a lexical namespace is implicitly an
      instance of the type indicated in the <var>encodedTypeURI</var> section
      of the URI. In all other aspects resources in lexical namespaces are no
      different from resources not in a lexical namespace; these resources are
      <em>not</em> instances of a special resource type solely because their
      namespaces are lexical namespaces. Lexical namespaces provide a
      framework for easily and consistently formulating identifying URIs for
      resources that are traditionally identified in lexical form; lexical
      namespaces in themselves imply no additional semantics.</p></dd>

      <dt>TURF</dt>

      <dd><p>Any representation of a resource in a lexical namespace also
      implicitly asserts the type of the resource. A resource in a lexical
      namespace can be identified by its URI as with any other resource. For
      example, the integer 123 can be identified by its URI
      <code>&lt;http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23Integer#123&gt;</code>
      as in the following example:</p><blockquote>
          <pre><code>«http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23Integer#123»</code></pre>
        </blockquote><p>Rather than indicating directly the URI of a resource
      in a lexical namespace, the resource may be identified by indicating the
      canonical lexical form of the resource, followed by the contents of the
      URI of the type of the resource. The integer 123 may therefore be
      represented as either of the following short forms:</p><blockquote>
          <pre><code>«"123"(«http://urf.name/urf#Integer»)»</code></pre>
        </blockquote><blockquote>
          <pre><code>«"123"(urf.Integer)»</code></pre>
        </blockquote><p>The lexical namespaces for several types have
      additional short representations. The examples below assume that the
      label <code>urf</code> has been assigned to the URF namespace.</p><dl>
          <dt><code>urf.Binary</code></dt>

          <dd><p>An binary resource may be identified by its [<a
          href="#rfc4648">RFC 4648</a>] base64url lexical form surrounded by
          percent signs. For example, the series of bytes <code>64</code>,
          <code>63</code>, <code>62</code>, <code>61</code> produce the
          lexical form, <code>"QD8-PQ=="</code>; the corresponding short
          representation,</p><blockquote>
              <pre><code>%QD8-PQ==%</code></pre>
            </blockquote><p>is equivalent to the following long
          representation,</p><blockquote>
              <pre><code>«http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23Binary#QD8-PQ%3D%3D»</code></pre>
            </blockquote><p>which is also equivalent to the following general
          short representation for resources in a lexical
          namespace:</p><blockquote>
              <pre><code>«"QD8-PQ=="(urf.Binary)»</code></pre>
            </blockquote></dd>

          <dt><code>urf.Boolean</code></dt>

          <dd><p>An boolean resource may be identified by its lexical form
          beginning with an asterisk. For example, the following short
          representation,</p><blockquote>
              <pre><code>*true</code></pre>
            </blockquote><p>is equivalent to the following long
          representation,</p><blockquote>
              <pre><code>«http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23Boolean#true»</code></pre>
            </blockquote><p>which is also equivalent to the following general
          short representation for resources in a lexical
          namespace:</p><blockquote>
              <pre><code>«"true"(urf.Boolean)»</code></pre>
            </blockquote></dd>

          <dt><code>urf.Character</code></dt>

          <dd><p>A character resource may be identified by its <a
          href="#charactershort">character-escaped lexical form</a> with
          surrounding single quotes. For example, the following short
          representation,</p><blockquote>
              <pre><code>'x'</code></pre>
            </blockquote><p>is equivalent to the following long
          representation,</p><blockquote>
              <pre><code>«http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23Character#x»</code></pre>
            </blockquote><p>which is also equivalent to the following general
          short representation for resources in a lexical
          namespace:</p><blockquote>
              <pre><code>«"x"(urf.Character)»</code></pre>
            </blockquote></dd>

          <dt><code>urf.Number</code></dt>

          <dd><p>Integer and real number resources may be identified by their
          lexical forms introduced by the number sign. The specific type of
          number resource yielded depends on the lexical form used. For
          example, the following short representations,</p><blockquote>
              <pre><code>#123
#123.45</code></pre>
            </blockquote><p>are equivalent to the following long
          representations, respectively,</p><blockquote>
              <pre><code>«http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23Integer#123»
«http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23Real#123.45»</code></pre>
            </blockquote><p>which are also equivalent to the following general
          short representations for resources in a lexical namespace,
          respectively:</p><blockquote>
              <pre><code>«"123"(urf.Integer)»
«"123.45"(urf.Real)»</code></pre>
            </blockquote></dd>

          <dt><code>urf.Ordinal</code></dt>

          <dd><p>Ordinal number resources may be identified by their lexical
          forms preceded by the ordinal character <code>'º'</code>. For
          example, the following short representation,</p><blockquote>
              <pre><code>º5</code></pre>
            </blockquote><p>is equivalent to the following long
          representation,</p><blockquote>
              <pre><code>«http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23Ordinal#5»</code></pre>
            </blockquote><p>which are also equivalent to the following general
          short representation for resources in a lexical
          namespace:</p><blockquote>
              <pre><code>«"5"(urf.Ordinal)»</code></pre>
            </blockquote></dd>

          <dt><code>urf.RegularExpression</code></dt>

          <dd><p>A regular expression resource may be identified by its <a
          href="#regexshort">regular expression-escaped lexical form</a>
          surrounded by slashes ('/'). For example, the following short
          representation,</p><blockquote>
              <pre><code>/a?b+c*/</code></pre>
            </blockquote><p>is equivalent to the following long
          representation,</p><blockquote>
              <pre><code>«http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23RegularExpression#a%3Fb%2Bc*»</code></pre>
            </blockquote><p>which is also equivalent to the general short
          representation for resources in a lexical namespace:</p><blockquote>
              <pre><code>«"a?b+c*"(urf.RegularExpression)»</code></pre>
            </blockquote></dd>

          <dt><code>urf.String</code></dt>

          <dd><p>A string resource may be identified by its <a
          href="#stringshort">string-escaped lexical form</a> with surrounding
          quotes. For example, the following short
          representation,</p><blockquote>
              <pre><code>"apple"</code></pre>
            </blockquote><p>is equivalent to the following long
          representation,</p><blockquote>
              <pre><code>«http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23String#apple»</code></pre>
            </blockquote><p>which is also equivalent to the general short
          representation for resources in a lexical namespace:</p><blockquote>
              <pre><code>«"apple"(urf.String)»</code></pre>
            </blockquote></dd>

          <dt><code>urf.Temporal</code></dt>

          <dd><p>A temporal resource such as <code>urf.Date</code>,
          <code>urf.DateTime</code>, <code>urf.Duration</code>,
          <code>urf.Time</code>, or <code>urf.UTCOffset</code> may be
          identified by its lexical form with a beginning at sign
          (<code>'@'</code>). The specific temporal type can be determined by
          the specific lexical form used. For example, the following short
          representations for <code>urf.Date</code>, <code>urf.Time</code>,
          <code>urf.DateTime</code>, <code>urf.Duration</code>, and
          <code>urf.UTFOffset</code>,</p><blockquote>
              <pre><code>@1980-05-06
@16:39:57-08:00
@1980-05-06T16:39:57-08:00
@P100Y5M3DT8H2M10.5S
@-08:00</code></pre>
            </blockquote><p>are equivalent to the following long
          representations, respectively,</p><blockquote>
              <pre><code>«http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23Date#1980-05-06»
«http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23Time#16%3A39%3A57-08%3A00»
«http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23DateTime#1980-05-06T16%3A39%3A57-08%3A00»
«http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23Duration#P100Y5M3DT8H2M10.5S»
«http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23UTCOffset#-08:00»</code></pre>
            </blockquote><p>which are also equivalent to the general short
          representations for resources in a lexical namespace:</p><blockquote>
              <pre><code>«"1980-05-06"(urf.Date)»
«"16:39:57-08:00"(urf.Time)»
«"1980-05-06T16:39:57-08:00"(urf.DateTime)»
«"P100Y5M3DT8H2M10.5S"(urf.Duration)»
«"-08:00"(urf.UTCOffset)»</code></pre>
            </blockquote></dd>

          <dt><code>urf.URI</code></dt>

          <dd><p>A URI resource may be identified by its lexical form with
          surrounding angle brackets <code>'&lt;'</code> and
          <code>'&gt;'</code>. For example, the following short
          representation,</p><blockquote>
              <pre><code>&lt;http://urf.name/urf#type&gt;</code></pre>
            </blockquote><p>is equivalent to the following long
          representation,</p><blockquote>
              <pre><code>«http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23URI#http%3A%2F%2Furf.name%2Furf%23type»</code></pre>
            </blockquote><p>which is also equivalent to the general short
          representation for resources in a lexical namespace:</p><blockquote>
              <pre><code>«"http://urf.name/urf#type"(urf.URI)»</code></pre>
            </blockquote></dd>
        </dl></dd>
    </dl>

    <h3 id="enum">Enums</h3>

    <dl>
      <dt>URF</dt>

      <dd><p>URF provides a special class, <code>urf.Enum</code>, for
      declaring subclasses that have values from a finite set of lexical
      forms. The URI of each instance of the enum subclass is a normal lexical
      URI, made up of the enum type (the <code>urf.Enum</code> subclass) and
      the lexical form of the enum value. <code>urf.Enum</code> is in turn a
      subclass of <code>urf.Set</code>, and the lexical form values of the
      enum type are specified as set elements of the <code>urf.Enum</code>
      subclass. For example, the URF class <code>urf.Boolean</code> is a
      subclass of <code>urf.Enum</code>, and its lexical form values are
      <code>"false"</code> and <code>"true"</code>. The URI of each
      <code>urf.Boolean</code> instance is formed following normal URF lexical
      URI rules, resulting in
      <code>«http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23Boolean#false»</code>
      and
      <code>«http://urf.name/lexical/http%3A%2F%2Furf.name%2Furf%23Boolean#true»</code>.</p></dd>

      <dt>TURF</dt>

      <dd><p>The following is the definition of the <code>urf.Boolean</code>
      class, which is a typical enum subclass:</p><blockquote>
          <pre><code>`URF:
  "urf"~&lt;http://urf.name/urf&gt;
;
¤
  urf.Boolean(urf.Class):
    urf.subClassOf=urf.Enum
  ;
  {
    "false",
    "true"
  }
.</code></pre>
        </blockquote></dd>
    </dl>

    <h3>Reification</h3>

    <dl>
      <dt>URF</dt>

      <dd><p>Propositions may be described without actually asserting those
      propositions. The sentence, "John believes that the sky is purple," for
      example, does not assert that the skye is purple, but merely that John
      believes this to be the case. The proposition "the sky is purple" may be
      described like any other resource, using the URF class
      <code>urf.Proposition</code> and the URF properties
      <code>urf.subject</code>, <code>urf.predicate</code>, and
      <code>urf.object</code>.</p></dd>

      <dt>TURF</dt>

      <dd><p>The following example asserts that John believes the sky to have
      the color purple without asserting that the sky actually has that
      color:</p><blockquote>
          <pre><code>`URF:
  "urf"~&lt;http://urf.name/urf&gt;,
  "example"~&lt;http://example.com/example&gt;
;
¤
  example.john:
    example.believes=(urf.Proposition):
      urf.subject=example.sky,
      urf.predicate=example.color,
      urf.object=example.purple
    ;
  ;
.</code></pre>
        </blockquote><p>Propositions may be presented in a short form
      consisting of the subject, predicate, and object enclosed in open double
      quotation mark <code>'“'</code> and closed double quotation mark
      <code>'”'</code> characters. The following example is semantically
      equivalent to the previous one:</p><blockquote>
          <pre><code>`URF:
  "urf"~&lt;http://urf.name/urf&gt;,
  "example"~&lt;http://example.com/example&gt;
;
¤
  example.john:
    example.believes=“example.sky, example.color, example.purple”
  ;
.</code></pre>
        </blockquote><p>Any proposition that is asserted can be reified by
      placing a label before the equals sign in a property definition. The
      label will then identify a proposition that is the reification of the
      property assertion, and that labeled resource can then be used in any
      situation in which a resource is expected. The following example first
      asserts that the sky is purple, using the label
      <code>skyColorPurple</code> to represent the reified proposition,
      <code>“example.sky, example.color, example.purple”</code>. Then it is
      asserted that John believes this proposition; the second assertion is
      therefore semantically identical to the one in the previous
      example.</p><blockquote>
          <pre><code>`URF:
  "example"~&lt;http://example.com/example&gt;
;
¤
  example.sky:
    example:color|skyColorPurple|=example:purple
  ;,
  example.john:
    example.believes=|skyColorPurple|
  ;
.</code></pre>
        </blockquote></dd>
    </dl>

    <h3>Proposition Scope</h3>

    <dl>
      <dt>URF</dt>

      <dd><p>Some assertions are only valid within a certain scope; they are
      asserted in a separate URF instance related to the context of some other
      subject and property. For example, if Juan has an English name of
      <code>"John"</code>, Juan could specify a <code>example.name</code> of
      <code>"John"</code> with an <code>example.lang</code> of
      <code>example.english</code>. Because the string <code>"John"</code> may
      not represent an English string in all contexts, its property
      <code>example.lang</code> should be considered to be in the scope of the
      relationship between Juan and the <code>example.name</code>
      <code>"John"</code>. The assertion, "the string 'John' is in English",
      is contextual to the string "John" being the name of
      Juan.</p><p>Similarly, Juan could specify a <code>example.weight</code>
      of <code>#72</code> with an <code>example.unit</code> of
      <code>example.kilogram</code>. Because the integer <code>#72</code> may
      not represent a unit of kilograms in all contexts, its property
      <code>example.unit</code> should be considered to be in the scope of the
      relationship between Juan and the <code>example.weight</code>
      <code>#72</code>. The assertion, "the integer 72 is in kilograms", is
      contextual to the integer 72 being the weight of Juan.</p><p>Scoped
      propositions are actually propositions asserted in separate <a
      href="#communities">knowledge communities</a> created by their context
      propositions.</p></dd>

      <dt>TURF</dt>

      <dd><p>To restrict a particular property assignment to the scope of the
      subject serving as the value of some other resource's property, the
      grave accent character <code>'`'</code> is used before the equals sign
      <code>'='</code> in the property declaration:</p><blockquote>
          <pre><code>`URF:
  "example"~&lt;http://example.com/example&gt;
;
¤
  example.juan:
    example.name="John":
      example.lang`=example.english
    ;,
    example.weight=#72:
      example.unit`=example.kilogram
    ;
  ;
.</code></pre>
        </blockquote></dd>
    </dl>

    <h3 id="orderedProperties">Ordered Properties</h3>

    <dl>
      <dt>URF</dt>

      <dd><p>Although all resource property assertions of a particular subject
      have no inherent order, URF provides a facility for declaring property
      order using scoped properties. Each property that should be considered
      to have an order relative to other assertions of the same property is
      given a scoped property <code>urf.order</code> with a value of type
      <code>urf.Integer</code>, representing the relative order in which the
      property should be interpreted.</p><p>The interpretation of the
      property's order is specific to the property in question. Although many
      uses cases will prefer a continuous, unduplicated sequence of order
      property values beginning with <code>0</code>, this is not an URF
      requirement. The result of merging ordered properties is undefined,
      except that the properties in each group before the merge must still be
      in the same order relative to each other after the merge.</p></dd>

      <dt>TURF</dt>

      <dd><p>Ordered properties may be indicated using the general
      representation for contextual properties. The following example
      indicates that a resource has two names, <code>"William"</code> and
      <code>"Bill"</code>, and that <code>"Will"</code> comes before
      <code>"Bill"</code>. (What it means that a name "comes before" another
      name depends on the definition of the name property being used. Perhaps
      one name comes before the other if used simultaneously, or perhaps one
      name has a higher priority or is considered the "default" name.)
      </p><blockquote>
          <pre><code>`URF:
  "urf"~&lt;http://urf.name/urf&gt;,
  "example"~&lt;http://example.com/example&gt;
;
¤
  example.billy:
    example.name="William":
      urf.order`=#0
    ;,
    example.name="Bill":
      urf.order`=#1
    ;
  ;
.</code></pre>
        </blockquote>The same information may be presented in short
      representation in the form of a <dfn>sequence</dfn> by placing the
      ordered values within matching backslash characters. A sequence does not
      result in a new type of value, but rather indicates that the given
      predicate should be asserted for each value, each with a scoped property
      of <code>urf.order</code> with values starting at <code>#0</code> and
      continuing sequentially. The following example represents information
      semantically identical to the previous example:<blockquote>
          <pre><code>`URF:
  "urf"~&lt;http://urf.name/urf&gt;,
  "example"~&lt;http://example.com/example&gt;
;
¤
  example.billy:
    example.name=\"William",  "Bill"\
  ;
.</code></pre>
        </blockquote></dd>
    </dl>

    <h3>Programming Languages</h3>

    <dl>
      <dt>URF</dt>

      <dd><p>URF provides inherent support for describing how to instantiate
      objects from programming languages such as Java. When an ontology of a
      semantic framework such as URF is used to represent programming language
      objects, the ontology is referred to as a Programming Language Ontology
      for Objects and Properties, or <a href="#ploop">PLOOP</a>. A class can
      be identified as an object's type using a URI that identifies the type,
      such as <code>«java:/com/example/package/ExampleClass»</code> for the
      Java class <code>com.example.package.ExampleClass</code>. An optional
      <code>urf.inits</code> property specifies an <code>urf.List</code> of
      resources to be used for object initialization using a constructor with
      parameters matching the given values.</p><p>URF properties specify
      programming language properties, which may be virtual properties using
      "getter" and "setter" methods such as with JavaBeans. Programming
      languages usually have properties relative to each class rather than
      absolute for all classes. For example, the Java property represented by
      the JavaBean method
      <code>com.example.package.ExampleClass.setProperty(java.lang.String)</code>
      would be represented by an URF property with the URI
      <code>«java:/com/example/package/ExampleClass#property»</code>. Some
      values may be language-specific; Java, for example, provides a global
      <code>null</code> value represented in URF by
      <code>«java:null»</code>.</p></dd>

      <dt>TURF</dt>

      <dd><p>TURF allows a shorthand notation for the <code>urf.inits</code>
      property <code>urf.List</code> value by surrounding its elements with
      inverted and upright exlamation marks. The class
      <code>com.guiseframework.Category</code> of the Guise Internet
      application framework [<a href="#guise">Guise</a>], for example, does
      not have a default constructor. The following example provides an
      <code>urf.inits</code> <code>urf.List</code> property containing a
      single element of type <code>urf.String</code>, which can be converted
      to a <code>java.lang.String</code> object and used as arguments for the
      <code>com.guiseframework.Category(java.lang.String,
      java.lang.String)</code> constructor. Properties of that class will then
      be set, recursively converting values such as <code>urf.List</code> to
      the equivalent Java object such as
      <code>java.util.List</code>.</p><blockquote>
          <pre><code>`URF:
  "guise"~&lt;java:/com/guiseframework/&gt;
;
¤
  (guise.Category)¡"category1", "First Category"!:
    categories=
    [
      (guise.Category)¡"subcategoryA"!,
      (guise.Category)¡"subcategoryB"!
    ]
  ;
.</code></pre>
        </blockquote><p>This is equivalent to the following TURF long
      form:</p><blockquote>
          <pre><code>`URF:
  "urf"~&lt;http://urf.name/urf&gt;,
  "guise"~&lt;java:/com/guiseframework/&gt;
;
¤
  (guise.Category):
    urf.inits=["category1", "First Category"],
    categories=
    [
      (guise.Category):
        urf.inits=["subcategoryA"]
      ;,
      (guise.Category):
        urf.inits=["subcategoryB"]
      ;
    ]
  ;
.</code></pre>
        </blockquote></dd>
    </dl>

    <h3 id="communities">Knowledge Communities</h3>

    <dl>
      <dt>URF</dt>

      <dd><p>The class <code>urf.Community</code> represents a body of
      knowledge accepted within a certain context. The
      <code>urf.Community</code> class is a subclass of <code>urf.Set</code>;
      its elements are instances of <code>urf.Proposition</code>. The
      propositions an <code>urf.Community</code> contains are considered to be
      asserted within that community.</p><p>The class
      <code>urf.Proposition</code> is a subclass of
      <code>urf.Community</code>, which means that each proposition is itself
      a knowledge community providing a context for asserted propositions.
      Scoped propositions are propositions that are contained within another
      instance of <code>urf.Proposition</code>.</p></dd>

      <dt>TURF</dt>

      <dd><p>In a TURF interchange document, every root resource and its
      recursive properties (excluding those within other
      <code>urf.Community</code> instances), represent propositions asserted
      in a default knowledge community. For example, the following example
      asserts that Punxsutawney Phil predicts the weather. ("Punxsutawney
      Phil" the name given to a marmot in Punxsutawney, Philadelphia, USA. On
      the American holiday Groundhog Day, whether Punxsutawney Phil sees his
      shadow is considered to be a prognostication regarding the onset of
      spring weather.)</p><blockquote>
          <pre><code>`URF:
  "punx"~&lt;http://example.com/punxsutawney&gt;
;
¤
  punx.Phil:
    punx:predicts=punx.weather
  ;
.</code></pre>
        </blockquote><p>It may instead be asserted that some other community,
      possibly identified, asserts a set of propositions. The currency symbol
      <code>'¤'</code> and full stop <code>'.'</code> characters indicate that
      the properties and resources between them are reified as propositions
      and serve as elements of the given <code>urf.Community</code>
      instance—which in turn is taken to mean that the propositions are
      asserted by the given knowledge community. (All TURF exchange documents
      have a common <dfn>instance community</dfn> in which root assertions are
      made.) For example, rather than directly asserting that Punxsutawney
      Phil predicts the weather, the following example asserts that <em>the
      community of Punxsutawney</em> asserts (believes or holds) that
      Punxsutawney Phil predicts the weather:</p><blockquote>
          <pre><code>`URF:
  "urf"~&lt;http://urf.name/urf&gt;,
  "punx"~&lt;http://example.com/punxsutawney&gt;
;
¤
  punx.Punxsutawney(urf.Community)
  ¤
    punx.Phil:
      punx:predicts=punx.weather
  .
.</code></pre>
        </blockquote><p>Semantics identical to those the previous example can
      be represented in the following longer form, with the propositions
      (shown here in short form) that are asserted in the community explicitly
      reified:</p><blockquote>
          <pre><code>`URF:
  "urf"~&lt;http://urf.name/urf&gt;,
  "punx"~&lt;http://example.com/punxsutawney&gt;
;
¤
  punx.Punxsutawney(urf.Community)
  {
    “punx.Phil, punx.predicts, punx.weather”
  }
.</code></pre>
        </blockquote><p>Because scoped properties are really propositions
      asserted in the knowledge community that is some other proposition,
      scoped properties may be represented in the same manner as other
      knowledge community representations. The following is the scoped
      property example given earlier in its short form:</p><blockquote>
          <pre><code>`URF:
  "example"~&lt;http://example.com/example&gt;
;
¤
  example.juan:
    example.name="John":
      example.lang`=example.english
    ;,
    example.weight=#72:
      example.unit`=example.kilogram
    ;
  ;
.</code></pre>
        </blockquote><p>Because each <code>urf.Proposition</code> instance is
      also an instance of <code>urf.Community</code>, reifying the
      propositions <code>example.name="John"</code> and
      <code>example.weight</code> provides two separate knowledge communities,
      in this case asserting the scoped properties. This is illustrated in the
      following example, which uses labels to indicate the reification of the
      asserted propositions relating to
      <code>example.juan</code>:</p><blockquote>
          <pre><code>`URF:
  "example"~&lt;http://example.com/example&gt;
;
¤
  example.juan:
    example.name|juanNameJohn|="John",
    |juanNameJohn|
    ¤
      "John":
        example.lang=example.english
      ;
    .,
    example.weight|juanWeight72|=#72,
    |juanWeight72|
    ¤
      #72:
        example.unit=example.kilogram
      ;
    .
  ;
.</code></pre>
        </blockquote><p>Referring to labeled assertions represent the
      reification of those propositions, and property declarations within a
      community (which itself may be another reified proposition) represent
      reified propositions asserted within that community. Therefore, the
      previous example can be represented in a more fully reified form (using
      proposition short forms):</p><blockquote>
          <pre><code>`URF:
  "urf"~&lt;http://urf.name/urf&gt;,
  "example"~&lt;http://example.com/example&gt;
;
¤
  example.juan:
    example.name="John",
    example.weight=#72,
    “example.juan, example.name, "John"”
    {
      “"John", example.lang, example.english”
    },
    “example.juan, example.weight, #72”
    {
      “#72, example.unit, example.kilogram”
    }
  ;
.</code></pre>
        </blockquote><p>Note that <code>example.name="John"</code> and
      <code>example.weight=#72</code> are listed separately as assertions of
      John's name and weight; those two propositions are later explicitly
      reified as propositions and serve as separate knowledge communities
      containing other assertions about the name <code>"John"</code> and the
      weight <code>#72</code>.</p></dd>
    </dl>

    <h2>URF</h2>

    <p>Everything that is described in URF is referred to as a
    <dfn>resource</dfn>. For purposes of description within URF, each resource
    may be identified using a URI [<a href="#rfc3986">RFC 3986</a>]. Resources
    are described by a set of <dfn>assertions</dfn>, each of which is a
    proposition, an instance of <code>urf.Proposition</code>. Each proposition
    contains a <dfn>subject</dfn>, a <dfn>predicate</dfn>, and an
    <dfn>object</dfn>.</p>

    <p>A particular group of assertions is called an <dfn>URF instance</dfn>.
    Each asserted proposition exists in some URF <dfn>knowledge
    community</dfn> as an element of <code>urf.Community</code>. Each
    <code>urf.Proposition</code> is itself a subclass of
    <code>urf.Community</code>, and may therefore contain other <dfn>scoped
    assertions</dfn> that are contextual to the first proposition. The root
    assertions of an URF instance are part of the <dfn>instance
    community</dfn> and may be considered to be asserted in the same knowledge
    community as the instance community of all other URF instances.</p>

    <h2 id="turf">TURF</h2>

    <p>TURF is the text interchange format for URF. TURF emphasizes terseness
    and consistency while maintaining human readability, with a preference for
    using symbols from existing interchange formats such as JSON and
    programming languages such as Java and C#.</p>

    <h3>Internet Media Type</h3>

    <p>The Internet media type of general URF information encoded as TURF
    is:</p>

    <blockquote>
      <p><code>application/turf</code></p>
    </blockquote>

    <p>For any application-specific URF data encoded as TURF should be
    represented as <code>application/<var>applicationName</var>+turf</code> to
    allow the data to be recognized as such, where <var>applicationName</var>
    is the application-specific identifier for the URF information. <em>Note:
    These Internet media types have yet to be registered with the
    IANA.</em></p>

    <h3>Encoding</h3>

    <p>TURF may use any encoding in a closed environment in which all relevant
    parties are aware of the encoding being used. In situations where the
    encoding may not be readily known to a processor, such as in a general
    file stored in a file system, TURF must use the UTF-8 character encoding.
    TURF interchange document files should use a UTF-8 U+FEFF sequence (the
    so-called UTF-8 Byte Order Mark or BOM) at their beginning to notify
    general text processing agents that may not be aware of TURF that UTF-8
    encoding is being used [<a href="#unicodeBOMFAQ">Unicode BOM FAQ</a>].</p>

    <h3>Signature</h3>

    <p>Every TURF interchange document must begin with the signature character
    sequence, <code>`URF</code>, which must appear as the first characters of
    the document after the Byte Order Mark (BOM), if any [<a
    href="#unicodeBOMFAQ">Unicode BOM FAQ</a>].</p>

    <h3>Grammar</h3>

    <p>The following grammar indicates literals in normal style, variables in
    emphasized text, and grammar symbols in strong text.</p>

    <p>Any two TURF tokens may be separated by separator or whitespace Unicode
    characters, or a TURF comment, which is a string surrounded by the dagger
    <code>'†'</code> and double dagger <code>'‡'</code> characters.</p>

    <blockquote>
      <p><code><var>separator</var> ⇒ Unicode Paragraph Separator
      <strong>|</strong> Unicode Segment Separator <strong>|</strong> Unicode
      Whitespace <strong>|</strong> <var>comment</var></code></p>
    </blockquote>

    <blockquote>
      <p><code><var>comment</var> ⇒ †"<strong>[</strong><var>Unicode character
      except double dagger and backslash</var> <strong>|</strong> \"
      <strong>|</strong> \\ <strong>|</strong> <var>escapedunicode</var>
      <strong>|</strong>
      <var>escapedcontrol</var><strong>]*</strong>‡</code></p>
    </blockquote>

    <p>A TURF interchange document is encoded in UTF-8 and begins with the
    TURF signature <code>`URF</code> followed by the description of the
    instance community, which consists of optional properties and a required
    community short representation.</p>

    <blockquote>
      <p><code><var>TURF</var> ⇒ signature
      <strong>[</strong>:<var>properties</var>;<strong>]</strong>
      <var>communityshort</var></code></p>
    </blockquote>

    <blockquote>
      <p><code><var>signature</var> ⇒ `URF</code></p>
    </blockquote>

    <p>The community short form, the grammar of which is below, is delimited
    by the currency character <code>'¤'</code> and the full stop character
    <code>'.'</code> and contains zero or more resource descriptions,
    separated by commas. Each resource description must have at least one of
    the following optional components, any may have any or all of them: a
    label, a reference, a type declaration, a set of property definitions, a
    community short form, a proposition form, a list short form, and a set
    short form.</p>

    <blockquote>
      <p><code><var>resource</var> ⇒
      <strong>[</strong>|<var>label</var>|<strong>]</strong>
      <strong>[</strong><var>reference</var><strong>]</strong>
      <strong>[</strong>(<var>type</var>s)<strong>]</strong>
      <strong>[</strong>¡<var>inits</var>!<strong>]</strong>
      <strong>[</strong>:<var>properties</var>;<strong>]</strong>
      <strong>[</strong><var>communityshort</var><strong>]</strong>
      <strong>[</strong><var>propositionshort</var><strong>]</strong>
      <strong>[</strong><var>listshort</var><strong>]</strong>
      <strong>[</strong><var>setshort</var><strong>]</strong></code></p>
    </blockquote>

    <p>A label consists of a name.</p>

    <blockquote>
      <p><code><var>label</var> ⇒ <var>name</var></code></p>
    </blockquote>

    <p>A name is any letter followed by any number of letters, digits, or
    connectors such as the underscore character <code>'_'</code>.</p>

    <blockquote id="name">
      <p><code><var>name</var> ⇒
      <var>namebeginchar</var><strong>(</strong><var>namechar</var><strong>)</strong><strong>*</strong></code></p>
    </blockquote>

    <blockquote>
      <p><code><var>namebeginchar</var> ⇒ <var>Unicode Letter</var></code></p>
    </blockquote>

    <blockquote>
      <p><code><var>namechar</var> ⇒ <var>Unicode Letter</var>
      <strong>|</strong> <var>Unicode Decimal Digit Number</var>
      <strong>|</strong> <var>Unicode Connector Punctuation</var></code></p>
    </blockquote>

    <p>A resource reference is a URI reference or one of several short
    representations.</p>

    <blockquote>
      <p><code><var>reference</var> ⇒ <var>urireference</var>
      <strong>|</strong> <var>namereference</var> <strong>|</strong>
      <var>urishort</var> <strong>|</strong> <var>stringshort</var>
      <strong>|</strong> <var>charactershort</var> <strong>|</strong>
      <var>booleanshort</var> <strong>|</strong> <var>numbershort</var>
      <strong>|</strong> <var>ordinalshort</var> <strong>|</strong>
      <var>regexshort</var> <strong>|</strong>
      <var>temporalshort</var></code></p>
    </blockquote>

    <p>A resource URI reference is enclosed in angle quotes. The contents is
    either the text of a URI (or relative reference), or a string containing
    the lexical representation of a resource in a lexical namespace,
    immediately followed by the type of the resource, which must contain a
    resource reference. Any URI reference that includes a lexical
    representation is equivalent to a URI reference in the form
    <code>«http://urf.name/lexical/<var>encodedTypeURI</var>#<var>encodedLexicalForm</var></code>».</p>

    <blockquote>
      <p><code><var>urireference</var> ⇒
      «<strong>(</strong><var>stringshort</var>(<var>type</var>)<strong>)</strong>
      <strong>|</strong>
      <strong>(</strong><var>urichar</var><strong>+</strong><strong>)</strong>»</code></p>
    </blockquote>

    <blockquote>
      <p><code><var>type</var> ⇒ <var>resource</var></code></p>
    </blockquote>

    <p>A name reference is a <var>name</var> representing the local name of a
    resource, optionally preceded by a <var>name</var> ending with the full
    stop or period character <code>'.'</code>, together representing the URI
    of a resource. The prefix, if present, must have been associated with a
    namespace URI in using the tilde character <code>'~'</code> either in the
    properties of the current resource or one of its subject resources. If no
    prefix is present for a property, the namespace is the URI of the first
    type of the subject resource. A prefix must be present in all other name
    references. The local name is the unencoded form of the fragment to be
    appended to the namespace URI.</p>

    <blockquote>
      <p><code><var>namereference</var> ⇒
      <strong>[</strong>prefix.<strong>]</strong>localName</code></p>
    </blockquote>

    <blockquote>
      <p><code><var>prefix</var> ⇒ <var>name</var></code></p>
    </blockquote>

    <blockquote>
      <p><code><var>localName</var> ⇒ <var>name</var></code></p>
    </blockquote>

    <p>A string short form is a sequence of Unicode characters, using the
    backslash as an escape character, enclosed in double quotes. The double
    quotation mark (<code>'"'</code>) and backslash (<code>'\\'</code>)
    characters must be escaped. A string short form is equivalent to a
    resource of type <code>urf.String</code> using the corresponding lexical
    namespace. The string short form <code>"example"</code> is the equivalent
    of the string resource <code>«"example"(urf.String)»</code>.</p>

    <blockquote id="stringshort">
      <p><code><var>stringshort</var> ⇒ "<strong>[</strong><var>Unicode
      character except double quote and backslash</var> <strong>|</strong> \"
      <strong>|</strong> \\ <strong>|</strong> <var>escapedunicode</var>
      <strong>|</strong>
      <var>escapedcontrol</var><strong>]*</strong>"</code></p>
    </blockquote>

    <p>Any Unicode code point may be represented in string and other short
    representations where indicated by the four lowercase hexadecimal
    representation following the character sequence <code>"\u"</code>, or if
    the code point is not in the Basic Multilingual Plane, two such sequences
    representing UTF-16 surrogate pair.</p>

    <blockquote id="escapedunicode">
      <p><code><var>escapedunicode</var> ⇒ \u<var>xxxx</var></code></p>
    </blockquote>

    <p>Several control characters have escaped forms which can be used in
    string and other short representations where indicated.</p>

    <blockquote id="escapedcontrol">
      <p><code><var>escapedcontrol</var> ⇒ \b <strong>|</strong> \t
      <strong>|</strong> \n <strong>|</strong> \f <strong>|</strong> \r
      <strong>|</strong> \“ <strong>|</strong> \”</code></p>
    </blockquote>

    <blockquote>
      <p><code>\b †\\\u0062‡ ⇒ \u0008 †backspace‡</code></p>
    </blockquote>

    <blockquote>
      <p><code>\t †\\\u0074‡ ⇒ \u0009 †character tabulation‡</code></p>
    </blockquote>

    <blockquote>
      <p><code>\n †\\\u006e‡ ⇒ \u000a †line feed (LF)‡</code></p>
    </blockquote>

    <blockquote>
      <p><code>\f †\\\u0066‡ ⇒ \u000c †form feed (FF)‡</code></p>
    </blockquote>

    <blockquote>
      <p><code>\r †\\\u0072‡ ⇒ \u000d †carriage return (CR)‡</code></p>
    </blockquote>

    <blockquote>
      <p><code>\“ †\\\u201c‡ ⇒ \u0098 †start of string (SOS)‡</code></p>
    </blockquote>

    <blockquote>
      <p><code>\” †\\\u201d‡ ⇒ \u009c †string terminator (ST)‡</code></p>
    </blockquote>

    <p>A character short form is a single Unicode characters, using the
    backslash as an escape character, enclosed in a single quote. The single
    quote (<code>'\''</code>) and backslash (<code>'\\'</code>) characters
    must be escaped. A character short form is equivalent to a resource of
    type <code>urf.Character</code> using the corresponding lexical namespace.
    The character short form <code>'x'</code> is the equivalent of the
    character resource <code>«"x"(urf.Character)»</code>.</p>

    <blockquote id="charactershort">
      <p><code><var>charactershort</var> ⇒ '<strong>[</strong><var>Unicode
      character except single quote and backslash</var> <strong>|</strong> \'
      <strong>|</strong> \\ <strong>|</strong> <var>escapedunicode</var>
      <strong>|</strong>
      <var>escapedcontrol</var><strong>]*</strong>'</code></p>
    </blockquote>

    <p>A URI short form is a sequence of character constituting a
    syntactically correct URI or a relative reference, surrounded by the angle
    brackets <code>'&lt;'</code> and <code>'&gt;'</code>. If a relative
    reference is provided, it is resolved against the base URI of the TURF
    document according to the rules specified in [<a
    href="#rdfxml">RDF/XML</a>] <cite>5.3 Resolving URIs</cite>. If a label
    appears at the beginning of the URI characters and that label refers to a
    previously defined URI resource, the remaining characters are interpreted
    as a relative reference and resolved against the URI to which the label
    refers. A single relative reference is resolved to the base URI of the
    interchange document. A URI short form is equivalent to a resource of type
    <code>urf.URI</code> using the corresponding lexical namespace. The URI
    short form <code>&lt;http://example.com&gt;</code> is the equivalent of
    the URI resource <code>«"http://example.com"(urf.URI)»</code>.</p>

    <blockquote>
      <p><code><var>urishort</var> ⇒
      &lt;<strong>[</strong>|<var>label</var>|<strong>]</strong><var>urichar</var><strong>+</strong>&gt;</code></p>
    </blockquote>

    <p>A boolean short form is the character sequence <code>true</code> or
    <code>false</code> preceded by an asterisk <code>'*'</code>. A boolean
    short form is equivalent to a resource of type <code>urf.Boolean</code>
    using the corresponding lexical namespace. The boolean short form
    <code>*true</code> is the equivalent of the boolean resource
    <code>«"true"(urf.Boolean)»</code>.</p>

    <blockquote>
      <p><code><var>booleanshort</var> ⇒
      *true<strong>|</strong>*false</code></p>
    </blockquote>

    <p>A number short form consists of roman digits, optionally preceded by a
    minus sign, with an optional decimal and optional exponent, all preceded
    by the number sign <code>'#'</code>. A number short form is equivalent to
    a resource of type <code>urf.Integer</code> or <code>urf.Real</code>,
    depending on the lexical form used, using the corresponding lexical
    namespace. The number short form <code>#123</code> is the equivalent of
    the number resource <code>«"123"(urf.Integer)»</code>, and the number
    short form <code>#123.45</code> is the equivalent of the number resource
    <code>«"123.45"(urf.Real)»</code>.</p>

    <blockquote>
      <p><code><var>numbershort</var> ⇒
      #<strong>[</strong>-<strong>]</strong><var>n</var><strong>[</strong>.<var>n</var><strong>][</strong>e<strong>(</strong>+<strong>|</strong>-<strong>)</strong><var>n</var><strong>]</strong></code></p>
    </blockquote>

    <blockquote>
      <p><code><var>n</var> ⇒
      <var>romandigit</var><strong>+</strong></code></p>
    </blockquote>

    <p>An ordinal short form consists of roman digits preceded by the ordinal
    sign <code>'º'</code>. An ordinal short form is equivalent to a resource
    of type <code>urf.Ordinal</code> using the corresponding lexical
    namespace. The ordinal short form <code>º27</code> is the equivalent of
    the ordinal resource <code>«"27"(urf.Ordinal)»</code>.</p>

    <blockquote>
      <p><code><var>ordinalshort</var> ⇒ º<var>n</var></code></p>
    </blockquote>

    <p>A regular expression short form is a sequence of Unicode characters,
    using the backslash as an escape character, enclosed in forward slash
    (<code>'/'</code>) characters. The slash (<code>'/'</code>) and backslash
    (<code>'\\'</code>) characters must be escaped. A regular expression short
    form is equivalent to a resource of type
    <code>urf.RegularExpression</code> using the corresponding lexical
    namespace. The regular expression short form <code>/a?b+c*/</code> is the
    equivalent of the string resource
    <code>«"a?b+c*"(urf.RegularExpression)»</code>.</p>

    <blockquote id="regexshort">
      <p><code><var>regexshort</var> ⇒ /<strong>[</strong><var>Unicode
      character except slash and backslash</var> <strong>|</strong> \/
      <strong>|</strong> \\ <strong>|</strong> <var>escapedunicode</var>
      <strong>|</strong>
      <var>escapedcontrol</var><strong>]*</strong>/</code></p>
    </blockquote>

    <p>A temporal short form consists of the lexical form of a temporal
    resource such as <code>urf.Date</code>, <code>urf.DateTime</code>,
    <code>urf.Duration</code>, <code>urf.Time</code>, or
    <code>urf.UTCOffset</code>, beginnint with an at sign (<code>'@'</code>).
    An <code>urf.Duration</code> requires at least the date or the time
    section to be present. The hours component represents midnight as
    <code>00</code> and must not have a value larger than <code>23</code>. The
    UTC offset <code>-00:00</code> is not allowed; <code>+00:00</code> must be
    used instead. A temporal short form is equivalent to a resource of the
    corresponding urf.Temporal type, based upon the specific lexical form
    used. The temporal short form <code>@1999-03-04@</code> is the equivalent
    of the number resource <code>«"1999-03-04"(urf.Date)»</code>, for
    example.</p>

    <blockquote>
      <p><code><var>temporalshort</var> ⇒
      @<strong>(</strong><var>YYYY</var>-<var>MM</var>-<var>DD</var><strong>)</strong>
      <strong>|</strong>
      <strong>(</strong><var>YYYY</var>-<var>MM</var>-<var>DD</var><code>T<var>hh:</var><var>mm</var>:ss<strong>[</strong>.s<strong>+</strong><strong>]</strong><strong>[</strong><strong>(</strong>+<strong>|</strong>-<strong>)</strong><var>hh</var>:<var>mm</var><strong>]</strong></code><strong>)</strong>
      <strong>|</strong>
      <strong>(</strong><var>hh:</var><var>mm</var>:ss<strong>[</strong>.s<strong>+</strong><strong>]</strong><strong>[</strong><strong>(</strong>+<strong>|</strong>-<strong>)</strong><var>hh</var>:<var>mm</var><strong>]</strong><strong>)</strong>
      <strong>|</strong>
      <strong>(</strong>P<strong>[</strong><var>n</var>Y<var>n</var>M<var>n</var>D<strong>]</strong><strong>[</strong>T<var>n</var>H<var>n</var>M<var>n</var><strong>[</strong>.<var>n</var><strong>]</strong>S<strong>]</strong><strong>)</strong>
      <strong>|</strong>
      <strong>(</strong><strong>(</strong>+<strong>|</strong>-<strong>)</strong><var>hh</var>:<var>mm</var><strong>)</strong></code></p>
    </blockquote>

    <p>The types declaration consists of zero or more resource descriptions
    between parenthes characters <code>'('</code> and <code>')'</code>, each
    resource indicating a type of the resource being described. Indicating
    types in this manner is equivalent to indicating the types as a sequence
    of values of the <code>urf.type</code> property.</p>

    <blockquote>
      <p><code><var>types</var> ⇒
      (<strong>[</strong><var>resource</var><strong>[,</strong><var>resource</var><strong><strong>]*</strong>]</strong>)</code></p>
    </blockquote>

    <p>The inits declaration consists of zero or more resource descriptions
    between <code>'¡'</code> and <code>'!'</code>, each resource indicating an
    initialization argument of the resource being described. Indicating inits
    in this manner is equivalent to indicating the inits as elements of an
    <code>urf.List</code> value of the <code>urf.inits</code> property.</p>

    <blockquote>
      <p><code><var>inits</var> ⇒
      (<strong>[</strong><var>resource</var><strong>[,</strong><var>resource</var><strong><strong>]*</strong>]</strong>)</code></p>
    </blockquote>

    <p>Properties consist of a comma-separated list of predicate resource and
    object resource pairs, each separated by the equals sign <code>'='</code>.
    If the grave character <code>'`'</code> is present before the equals sign,
    it indicates that the property is scoped in the context of the property's
    subject resource and its respective predicate resource and subject
    resource. If a label is provided, it identifies the proposition
    represented by the reification of the assertion.</p>

    <blockquote>
      <p><code><var>properties</var> ⇒
      <strong>[</strong><var>property</var><strong>[</strong>,<var>property</var><strong><strong>]*</strong>]</strong></code></p>
    </blockquote>

    <blockquote>
      <p><code><var>property</var> ⇒
      <var>resource</var><strong>[</strong>|<var>label</var>|<strong>]</strong><strong>[</strong>`<strong>]</strong>=<strong>(</strong><var>sequenceshort</var><strong>|</strong><var>resource</var><strong>)</strong></code></p>
    </blockquote>

    <p>A sequence short form consists of a sequence of element resources
    separated by commas and surrounded by the backslash character
    <code>'\\'</code>. Each listed element resource indicates another
    assertion of the given predicate with the given element resource as the
    value, each with a contextual property of <code>urf.order</code> with
    values starting at <code>#0</code> and continuing sequentially.</p>

    <blockquote>
      <p><code><var>sequenceshort</var> ⇒
      \<strong>[</strong><var>resource</var><strong>[</strong>,<var>resource</var><strong>]*]</strong>\</code></p>
    </blockquote>

    <p>A community short form consists of a sequence of resources surrounded
    by the currency symbol <code>'¤'</code> and the full stop character
    <code>'.'</code>, separated by commas. Each listed resource represents an
    unreified proposition that is a value of the <code>urf.element</code>
    property. The presence of a community short form implies a type of
    <code>urf.Community</code> if no other types have yet been specified,
    either implicitly or explicitly.</p>

    <blockquote>
      <p><code><var>communityshort</var> ⇒
      ¤<strong>[</strong><var>resource</var><strong>[</strong>,<var>resource</var><strong>]*].</strong></code></p>
    </blockquote>

    <p>A proposition short form lists the subject, predicate, and object of a
    proposition inside the open double quotation mark <code>'“'</code> and
    closed double quotation mark <code>'”'</code> characters. A proposition
    short form is equivalent to setting the resource <code>urf.Subject</code>,
    <code>urf.Predicate</code>, and <code>urf.Object</code> propoerties to the
    three listed resources within the proposition short form. The presence of
    a proposition short form implies a type of <code>urf.Proposition</code> if
    no other types have yet been specified, either implicitly or
    explicitly.</p>

    <blockquote>
      <p><code><var>propositionshort</var> ⇒ “<var>subject</var>
      <var>separator</var>+ <var>predicate</var>
      <var>separator</var><strong>+</strong> <var>object</var>”</code></p>
    </blockquote>

    <blockquote>
      <p><code><var>subject</var> ⇒ <var>resource</var></code></p>
    </blockquote>

    <blockquote>
      <p><code><var>predicate</var> ⇒ <var>resource</var></code></p>
    </blockquote>

    <blockquote>
      <p><code><var>object</var> ⇒ <var>resource</var></code></p>
    </blockquote>

    <p>A list short form consists of a sequence of element resources
    surrounded by bracket characters <code>'['</code> and <code>']'</code> and
    separated by commas. Each listed element resource represents the value of
    an ordinal index property, in sequence beginning with the ordinal property
    <code><code>º0</code></code>. The presence of a list short form implies a
    type of <code>urf.List</code> if no other types have yet been specified,
    either implicitly or explicitly.</p>

    <blockquote>
      <p><code><var>listshort</var> ⇒
      [<strong>[</strong>resource<strong>[</strong>,resource<strong>]*]</strong>]</code></p>
    </blockquote>

    <p>A set short form consists of a sequence of element resources surrounded
    by curly bracket characters <code>'{'</code> and <code>'}'</code> and
    separated by commas. Each listed element resource represents a value of
    the <code>urf.element</code> property. The presence of a set short form
    implies a type of <code>urf.Set</code> if no other types have yet been
    specified, either implicitly or explicitly.</p>

    <blockquote>
      <p><code><var>setshort</var> ⇒
      {<strong>[</strong>resource<strong>[</strong>,resource<strong>]*]</strong>}</code></p>
    </blockquote>

    <h2 id="ploop">PLOOP</h2>

    <p>It is possible to use URF as a Programming Language Ontology for
    Objects and Properties (PLOOP), allowing long-term storage and/or object
    tree instance descriptions of programming languages using TURF, for
    example. The following specifies a canonical set of rules a processor must
    follow for for constructing a hierarchy of programming language objects
    based upon an URF description. All examples are represented using TURF and
    are given in the Java programming language using the Guise Internet
    application framework [<a href="#guise">Guise</a>]. A complete <a
    href="#ploopExample">PLOOP example</a> is provided at the end of this
    specification.</p>

    <h3>Classes</h3>

    <p>The URI of an URF class must indicate the complete package name and
    class name of a programming language class to instantiate. In the
    following example, the Java class
    <code>com.guiseframework.component.Layoutpanel</code> should be
    instantiated using its default constructor:</p>

    <blockquote>
      <pre><code>`URF
¤
  («java:/com/guiseframework/component/LayoutPanel»)
.</code></pre>
    </blockquote>

    <p>If a resource has an <code>urf.inits</code> property with an
    <code>urf.List</code> value, a PLOOP processor must use all the
    corresponding values to locate a constructor with the correct number of
    parameters for which the URF property values can be converted into
    constructor arguments. A PLOOP instance would use the following example to
    indicate that an instance of the Guise class
    <code>com.guiseframework.Category</code> should be constructed using
    <code>new Category("category1", "First Category")</code>:</p>

    <blockquote>
      <pre><code>`URF
¤
  («java:/com/guiseframework/Category»)¡"category1", "First Category"!
.</code></pre>
    </blockquote>

    <p>If there is no <code>urf.inits</code> property but there is a single
    constructor taking a URI, that constructor must be used to instantiate the
    class, using the resource URI, if any.</p>

    <h3>Properties</h3>

    <p>URF allows identification of programming language properties that are
    relative to the class of the resource being described, and TURF provides a
    shorthand notation for such properties having URIs with the class URI as
    their namespace. A PLOOP processor must use normal get/set conventions for
    the language in question for interpreting the read/write properties
    available for a particular class. For example, because the property
    <code>«java:/com/guiseframework/component/Button#label»</code> has theh
    same namespace as the type
    <code>«java:/com/guiseframework/component/Button»</code>, its local name,
    <code>label</code>, is considered a property name for getting or setting a
    value of an instance of the <code>Button</code> class:</p>

    <blockquote>
      <pre><code>`URF
¤
  («java:/com/guiseframework/component/Button»):
    label="Push Me"
  ;
.</code></pre>
    </blockquote>

    <h3>Values</h3>

    <p>In general, URF resources with URIs that are recognized must be
    converted to the equivalent type in the programming language. For example,
    in Java all resources of type <code>urf.Integer</code> must be converted
    to instances of java.lang.Integer. Likewise in Java urf.List, urf.Set, and
    urf.Map resources must be converted to java.util.List, java.util.Set,
    java.util.Set, and java.util.Map instances, respectively, with each
    element recursively instantiated or converted as needed. A resource with a
    lexical URI must be converted if possible to a programming language type
    functioning as a lexical identifier, if its lexical type indicates such an
    enumerated type. In the following example, the Guise Java class
    <code>com.guiseframework.component.layout.FlowLayout</code> has a
    <code>setFlow(com.guiseframework.component.layout.Flow)</code> method. The
    lexical URI <code>«"LINE"(layout.Flow)»</code> indicates a type of
    <code>com.guiseframework.component.layout.Flow</code>, which is a Java
    enum class. A PLOOP processor must construct a
    <code>com.guiseframework.component.layout.Flow</code> object from the
    string "LINE" and assign it to the instance of
    <code>com.guiseframework.component.layout.FlowLayout</code> using
    <code>com.guiseframework.component.layout.FlowLayout.setFlow(com.guiseframework.component.layout.Flow)</code>.</p>

    <blockquote>
      <pre><code>`URF
¤
  («java:/com/guiseframework/component/layout/FlowLayout»):
    flow=«"LINE"(layout.Flow)»
  ;
.</code></pre>
    </blockquote>

    <h2>Reference Implementation</h2>

    <p>GlobalMentor, Inc. maintains an open-source reference implementation
    for processing URF. The library provides an API and source code for
    parsing URF from TURF, parsing URF from RDF/XML, creating a Java instance
    tree from URF, generating TURF from URF, generating URF from a Java
    instance tree, and manipulating URF in-memory. The reference
    implementation source code may be downloaded from the GlobalMentor
    Subversion repository at &lt;<a
    href="https://svn.globalmentor.com/java/src/com/garretwilson/urf/">https://svn.globalmentor.com/java/src/com/garretwilson/urf/</a>&gt;.
    The API documentation may be found at &lt;<a
    href="http://www.guiseframework.com/doc/api/com/garretwilson/urf/package-summary.html">http://www.guiseframework.com/doc/api/com/garretwilson/urf/package-summary.html</a>&gt;.
    The Guise Internet application framework [<a href="#guise">Guise</a>]
    development library contains the URF reference implementation already
    compiled, and is available at &lt;<a
    href="http://www.guiseframework.com/com.guiseframework-unlicensed.jar">http://www.guiseframework.com/com.guiseframework-unlicensed.jar</a>&gt;.</p>

    <p>GlobalMentor also maintains an online demonstration of live, dynamic
    URF processing and exploration. The demonstration uses the Guise Internet
    application framework [<a href="#guise">Guise</a>] and allows TURF or
    RDF/XML to be processed and displayed as URF assertions, TURF, and a
    dynamic tree or resources and properties. This URF processing
    demonstration is available at &lt;<a
    href="http://www.guiseframework.com/demo/urfprocess">http://www.guiseframework.com/demo/urfprocess</a>&gt;.</p>

    <h2>Examples</h2>

    <h3 id="jsonExample">JSON</h3>

    <p>In the JavaScript Object Notation (JSON) [<a href="#rfc4627">RFC
    4627</a>], every object besides strings, numbers, and booleans are
    associative arrays using string keys. The following is a complex JSON
    object, using every JSON data type available:</p>

    <blockquote>
      <pre><code>{
  "length":1234,
  "valid":true,
  "status":"processing",
  "results":[false, 5, "dog", {"code":9.8}]
}</code></pre>
    </blockquote>

    <p>While this representation has some undesirable traits (e.g. strings are
    not recommended as general property identifiers except in the case of
    resources used as maps), the following TURF representation is semantically
    identical to the JSON example above:</p>

    <blockquote>
      <pre><code>`URF
¤
  :
    "length"=#1234,
    "valid"=*true,
    "status"="processing",
    "results"=[*false, #5, "dog", :"code"=#9.8;]
  ;
.</code></pre>
    </blockquote>

    <p>There is one slight semantic descrepancy between these two examples:
    URF uses a true ordinal property for each list element, while JSON adds
    each array element as the value of a string containing the lexical form of
    an integer.</p>

    <p>Although the above TURF representation replicates the simple semantics
    of the given JSON example, a better formulation that takes advantage of
    URF semantics would most importantly use actual properties rather than
    associative array string key pseudo-properties. An improved formulation
    would also indicate the type of the resources. Such improvements are
    illustrated in the following reformulation:</p>

    <blockquote>
      <pre><code>`URF:
  "urf"~&lt;http://urf.name/urf&gt;,
  "example"~&lt;http://example.com/example&gt;
;
¤
  (example.Class):
    example.length=#1234,
    example.valid=*true,
    example.status="processing",
    example.results=[*false, #5, "dog", (urf.Map):"code"=#9.8;]
  ;
.</code></pre>
    </blockquote>

    <h3 id="ploopExample">PLOOP</h3>

    <p>The following TURF example uses URF as <a href="#ploop">PLOOP</a> for
    the Guise Internet application framework [<a href="#guise">Guise</a>]
    using the Java programming language. It defines a panel of Guise
    components that allow temperature to be converted between Celsius and
    Fahrenheit. (The control listeners and temperature conversion logic would
    be defined elsewhere.)</p>

    <blockquote>
      <pre><code>`URF:
  "component"~&lt;java:/com/guiseframework/component/&gt;,
  "layout"~&lt;java:/com/guiseframework/component/layout/&gt;,
  "validator"~&lt;java:/com/guiseframework/validator/&gt;,
  "demo"~&lt;java:/com/guiseframework/demo/&gt;
;
¤
  (demo.TemperatureConversionPanel2):
    label="Guise™ Demonstration: Temperature Conversion",
    layout=(layout.FlowLayout):
      flow=«"LINE"(layout.Flow)»
    ;,
    name="temperatureConversionPanel",
    children=
    [
      (component.LayoutPanel):
        layout=(layout.FlowLayout):
          flow=«"PAGE"(layout.Flow)»
        ;,
        name="inputPanel",
        children=
        [
          (component.TextControl)¡«java:/java/lang/Double»!:
            label="Input Temperature",
            name="temperatureInput",
            validator=(validator.ValueRequiredValidator)
          ;,
          (component.TextControl)¡«java:/java/lang/Double»!:
            editable=*false,
            label="Output Temperature",
            name="temperatureOutput"
          ;
        ]
      ;,
      (component.LayoutPanel):
        layout=(layout.FlowLayout):
          flow=«"PAGE"(layout.Flow)»
        ;,
        name="conversionPanel",
        children=
        [
          (component.GroupPanel):
            label="Input Scale",
            layout=(layout.FlowLayout):
              flow=«"PAGE"(layout.Flow)»
            ;,
            name="scalePanel",
            children=
            [
              (component.CheckControl):
                checkType="ellipse",
                label="Calsius",
                name="celsiusCheckControl"
              ;,
              (component.CheckControl):
                checkType="ellipse",
                label="Fahrenheit",
                name="fahrenheitCheckControl"
              ;
            ]
          ;,
          (component.Button):
            label="Convert",
            name="conversionButton"
          ;
        ]
      ;
    ]
  ;
.</code></pre>
    </blockquote>

    <p>The preceding example, when processed by an URF PLOOP processor, will
    produce an object instance graph identical to that produced by the
    following Java code:</p>

    <blockquote>
      <pre><code>import com.guiseframework.component.*;
import com.guiseframework.component.layout.*;
import com.guiseframework.validator.*;

DefaultNavigationPanel navigationPanel=new DefaultNavigationPanel();
navigationPanel.setName("temperatureConversionPanel");
navigationPanel.setLayout(new FlowLayout(Flow.LINE));
navigationPanel.setLabel("Guise\u2122 Demonstration: Temperature Conversion");

LayoutPanel inputPanel=new LayoutPanel(new FlowLayout(Flow.PAGE));
TextControl&lt;Double&gt; temperatureInput=new TextControl&lt;Double&gt;(Double.class);
temperatureInput.setName("temperatureInput");
temperatureInput.setLabel("Input Temperature");
temperatureInput.setValidator(new ValueRequiredValidator&lt;Double&gt;());
inputPanel.add(temperatureInput);

TextControl&lt;Double&gt; temperatureOutput=temperatureOutput=new TextControl&lt;Double&gt;(Double.class);
temperatureOutput.setName("temperatureOutput");
temperatureOutput.setLabel("Output Temperature");
temperatureOutput.setEditable(false);
inputPanel.add(temperatureOutput);

navigationPanel.add(inputPanel);

LayoutPanel conversionPanel=new LayoutPanel();
conversionPanel.setLayout(new FlowLayout(Flow.PAGE));

GroupPanel scalePanel=new GroupPanel();
scalePanel.setLayout(new FlowLayout(Flow.PAGE));

scalePanel.setLabel("Input Scale");
CheckControl celsiusCheckControl=celsiusCheckControl=new CheckControl();
celsiusCheckControl.setName("celsiusCheckControl");
celsiusCheckControl.setCheckType(CheckControl.CheckType.ELLIPSE);
celsiusCheckControl.setLabel("Celsius");
scalePanel.add(celsiusCheckControl);
CheckControl fahrenheitCheckControl=fahrenheitCheckControl=new CheckControl();
fahrenheitCheckControl.setName("fahrenheitCheckControl");
fahrenheitCheckControl.setCheckType(CheckControl.CheckType.ELLIPSE);
fahrenheitCheckControl.setLabel("Fahrenheit");
scalePanel.add(fahrenheitCheckControl);

conversionPanel.add(scalePanel);

Button convertButton=new Button();
convertButton.setName("conversionButton");
convertButton.setLabel("Convert");
conversionPanel.add(convertButton);
navigationPanel.add(conversionPanel);
</code></pre>
    </blockquote>

    <h3 id="rdfxmlExample">RDF/XML</h3>

    <p>URF is a semantic superset of RDF, and can represent any construct
    available in RDF. URF presents equivalents of many RDF classes as well. In
    terms of representation formats, TURF can represent any semantic
    information that is available using [<a href="#rdfxml">RDF/XML</a>], yet
    is more flexible and has less restrictions. The following is a sample
    RDF/XML representation of an RDF data instance using many of the
    capabilities available in RDF/XML:</p>

    <blockquote>
      <pre><code>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE rdf:RDF [&lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#"&gt;]&gt;
&lt;rdf:RDF
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:example="http://example.com/example#"
  xmlns:foaf="http://xmlns.com/foaf/0.1/"
  xmlns:xhtml="http://www.w3.org/1999/xhtml"
&gt;
  &lt;foaf:Person rdf:about="http://example.com/example#janedoe"&gt;
    &lt;foaf:nick xml:lang="pt-BR"&gt;Janinha&lt;/foaf:nick&gt;
    &lt;example:age rdf:datatype="&amp;xsd;integer"&gt;23&lt;/example:age&gt;
    &lt;example:birthdate rdf:datatype="&amp;xsd;date"&gt;1980-04-05&lt;/example:birthdate&gt;
    &lt;example:motto rdf:parseType="Literal"&gt;Do it. Do it &lt;xhtml:em&gt;right&lt;/xhtml:em&gt;.&lt;/example:motto&gt;
    &lt;example:favoriteSites rdf:parseType="Collection"&gt;
      &lt;rdf:Description rdf:about="http://www.globalmentor.com/"/&gt;
      &lt;rdf:Description rdf:about="http://www.garretwilson.com/"/&gt;
    &lt;/example:favoriteSites&gt;
    &lt;example:possibleVacationDestinations&gt;
      &lt;rdf:Alt&gt;
        &lt;rdf:li&gt;Paris&lt;/rdf:li&gt;
        &lt;rdf:li&gt;Rome&lt;/rdf:li&gt;
      &lt;/rdf:Alt&gt;
    &lt;/example:possibleVacationDestinations&gt;
  &lt;/foaf:Person&gt;
&lt;/rdf:RDF&gt;</code></pre>
    </blockquote>

    <p>The following URF information represented in TURF is semantically
    equivalent to the RDF information in the previous example represented in
    RDF/XML:</p>

    <blockquote>
      <pre><code>`URF:
  "urf"~&lt;http://urf.name/urf&gt;,
  "content"~&lt;http://urf.name/content&gt;,
  "dc"~&lt;http://purl.org/dc/elements/1.1/&gt;,
  "example"~&lt;http://example.com/example&gt;,
  "foaf"~&lt;http://xmlns.com/foaf/0.1/&gt;
;
¤
  example.janedoe(foaf.Person):
    example.age=#23,
    example.birthdate=@1980-04-05,
    example.favoriteSites=
    [
      «http://www.globalmentor.com/»,
      «http://www.garretwilson.com/»
    ],
    example.motto="Do it. Do it &lt;xhtml:em xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"&gt;right&lt;/xhtml:em&gt;.":
      content.type`=«"text/xml-external-parsed-entity"(content.MediaType)»
    ;,
    example.possibleVacationDestinations=
    {
      "Paris",
      "Rome"
    },
    nick="Janinha":
      dc.language`=«"pt-BR"(urf.Language)»
    ;
  ;
.</code></pre>
    </blockquote>

    <p>Note that, rather than use special literal types or general strings,
    URF promotes the representation of resources by URIs. Thus the language
    tag "pt-BR" for Brazilian Portuguese is represented as a resource a URI
    <code>urf.Language</code> lexical namespace, and the integer value
    <code>23</code> is represented as a resource with a URI in the
    <code>urf.Integer</code> lexical namespace (shown here in its short form,
    <code>#23</code>).</p>

    <h3 id="vcardExample">VCard</h3>

    <p>The URF <a href="#vcard">VCard Ontology</a> provides a representation
    of VCard [<a href="#rfc2426">RFC 2426</a>] within a semantic framework.
    The following is VCard information in traditional vCard MIME Directory
    Profile syntax as specified by [<a href="#rfc2426">RFC 2426</a>].</p>

    <blockquote>
      <pre><code>BEGIN:vCard
VERSION:3.0
FN:Jane Doe
N:Doe;Jane;Mary,Ann;Dr.;M.D.,Ph.D.
ORG:Example Corporation;North American Division;Business Development
TITLE:Directory of Business Development
ADR;TYPE=WORK,POSTAL,PARCEL:;Suite 45;123 Some Street;Someplace;CA;12345-6789;USA
LABEL="123 Some Street\nSuite 45\nSomeplace, CA 12345-6789"
TEL;TYPE=PREF;VOICE,WORK:+1-234-567-8910
TEL;TYPE=VOICE,HOME,CELL:+1-234-567-8911
EMAIL;PREF:janedoe@example.com
EMAIL:jdoe@example.org
URL:http://www.example.com/home/jane/
BDAY=1980-02-02T09:45:00
CATEGORY:Internet,B2B,P2P,Web2.0,ABCD
END:vCard</code></pre>
    </blockquote>

    <p>The same vCard information in its URF VCard formulation is shown below
    for the resource <code>«http://example.com/example#janedoe»</code>. Note
    that the URF VCard version provides more semantics by using true classes
    and properties to describe what [<a href="#rfc2426">RFC 2426</a>] calls
    <dfn>structured values</dfn>.</p>

    <blockquote>
      <pre><code>`URF:
  "vcard"~&lt;http://urf.com/vcard&gt;,
  "example"~&lt;http://example.com/example&gt;
;
¤
  example.janedoe:
    vcard.fn="Jane Doe",
    vcard.n=(vcard.Name):
      vcard.familyName="Doe",
      vcard.givenName="Jane",
      vcard.additionalName=\"Mary", "Ann"\,
      vcard.honoraryPrefix="Dr.",
      vcard.honorarySuffix=\"M.D.", "Ph.D."\
    ;,
    vcard.org=\"Example Corporation", "North American Division", "Business Development"\,
    vcard.title="Directory of Business Development",
    vcard.adr=(vcard.Adr):
      vcard.adrType=«"work"(vcard.AdrType)»,
      vcard.adrType=«"postal"(vcard.AdrType)»,
      vcard.adrType=«"parcel"(vcard.AdrType)»,
      vcard.extendedAddress="Suite 45",
      vcard.streetAddress="123 Some Street",
      vcard.locality="Someplace",
      vcard.region="CA",
      vcard.postalCode="12345-6789",
      vcard.countryName="USA"
    ;,
    vcard.label="123 Some Street\nSuite 45\nSomeplace, CA 12345-6789",
    vcard.tel=
    \
      «tel:+1-234-567-8910»:
        vcard.telType=«"voice"(vcard.TelType)»,
        vcard.telType=«"work"(vcard.TelType)»
      ;,
      «tel:+1-234-567-8911»:
        vcard.telType=«"voice"(vcard.TelType)»,
        vcard.telType=«"home"(vcard.TelType)»,
        vcard.telType=«"cell"(vcard.TelType)»
      ;
    \,
    vcard.email=\&lt;janedoe@example.com&gt;, &lt;jdoe@example.org&gt;\,
    vcard.url=&lt;http://www.example.com/home/jane/&gt;,
    vcard.bday=@1980-02-02T09:45:00,
    vcard.category="Internet",
    vcard.category="B2B",
    vcard.category="P2P",
    vcard.category="Web2.0",
    vcard.category="ABCD"
  ;
.</code></pre>
    </blockquote>

    <h2>Comparisons</h2>

    <h3>Differences between URF and JSON</h3>

    <ul>
      <li>Any URF resource may be identified by a URI. JSON makes no provision
      for identifying resources.</li>

      <li>URF allows globally consistent semantic properties by identifying
      resources with URIs. JSON properties names are local and may clash with
      semantically distinct property names among resources.</li>

      <li>URF provides a system for grouping resources within a common
      namespace, with the management of control for those namespaces
      facilitated by the Internet domain name system. JSON properties cannot
      be so aportioned, making name clashes more likely.</li>

      <li>URF has a set type, <code>«http://urf.name/urf#Set»</code>. JSON has
      no set type.</li>

      <li>URF has three concrete number types,
      <code>«http://urf.name/urf#Real»</code>,
      <code>«http://urf.name/urf#Integer»</code>, and
      <code>«http://urf.name/urf#Real»</code>. JSON has only a single number
      type.</li>

      <li>URF has a character type,
      <code>«http://urf.name/urf#Character»</code>. JSON has no character
      type.</li>

      <li>URF has several date/time types which are compatible with [<a
      href="#iso8601">ISO 8601</a>], [<a href="#rfc3339">RFC 3339</a>], and
      [<a href="#rfc2445">RFC 2445</a>]. JSON has no date or time type.</li>
    </ul>

    <h3>Differences between URF and RDF</h3>

    <p>URF is a semantic superset of RDF. Anything that can be represented by
    the RDF abstract syntax can be represented by the URF abstract model.
    Converting from URF to RDF is possible but would require special
    URF-related RDF ontologies to encapsulate the extra semantics built into
    the URF abstract model.</p>

    <ul>
      <li>URF considers all resources equal, providing for consistent
      identification and property designation of every resource. RDF considers
      certain resources, such as numbers and strings, to be of special
      <dfn>literal</dfn> resource types which are not identified by URIs (in
      contrast to all other non-literal resources) and to which properties
      cannot be given.</li>

      <li>URF provides a facility for declaring the order of properties. RDF
      has no such facility.</li>

      <li>URF provides for contextual properties. RDF has no such
      concept.</li>

      <li>URF has a character type,
      <code>«http://urf.name/urf#Character»</code>. RDF, which uses XML Schema
      datatypes [<a href="#xmlSchema2">XML Schema 2</a>], has no character
      type.</li>

      <li>URF has a regular expression type,
      <code>«http://urf.name/urf#RegularExpression»</code>. RDF has no regular
      expression type.</li>

      <li>URF has an enumerated type, <code>«http://urf.name/urf#Enum»</code>,
      as well as a facility for declaring enumerated values. RDF has no
      dedicated enumerated type. The RDF <dfn>typed literal</dfn> may be used
      to mimic enumerated types, but RDF provides no built-in facility for
      creating a new enumerated type or declaring its values.</li>

      <li>URF allows a knowledge community to be named and described. RDF does
      not provide such a "named graph" facility.</li>
    </ul>

    <h3>Differences between URF and XML</h3>

    <ul>
      <li>URF provides a single type of subrelation: properties. XML provides
      two types of subrelations: attributes and child elements.</li>

      <li>URF uses global URIs to identify nodes in a graph. XML uses string
      IDs local to the defining document.</li>
    </ul>

    <h3>Differences between TURF and RDF/XML</h3>

    <ul>
      <li>TURF allows any resource, including strings and other resources in
      lexical namespaces, to be labeled for later reference. RDF/XML does not
      allow so-called RDF literal resources to be labeled.</li>

      <li>TURF allows any resource to appear in a list. RDF/XML does not allow
      so-called RDF literal resources to appear in a list.</li>
    </ul>

    <h2>References</h2>

    <dl>
      <dt id="dcmiNamespace">DCMI Namespace</dt>

      <dd>Andy Powell and Harry Wagner. <a
      href="http://dublincore.org/documents/dcmi-namespace/"><cite>Namespace
      Policy for the Dublin Core Metadata Initiative (DCMI)</cite></a>. Dublin
      Core Namespace Initiative, 2007.</dd>

      <dt id="guise">Guise</dt>

      <dd><a href="http://www.guiseframework.com/"><cite>Guise™ Internet
      Application Framework</cite></a>. GlobalMentor, Inc.</dd>

      <dt id="iso8601">ISO 8601</dt>

      <dd><cite>ISO 8601:2004(E): Data elements and interchange formats —
      Information interchange — Representation of dates and times</cite>.
      International Organization for Standardization, 2004-12-01.</dd>

      <dt id="rdfxml">RDF/XML</dt>

      <dd>Dave Beckett. <a
      href="http://www.w3.org/TR/rdf-syntax-grammar/"><cite>RDF/XML Syntax
      Specification (Revised)</cite></a>. World Wide Web Consortium,
      2006-02-10.</dd>

      <dt id="rfc2046">RFC 2046</dt>

      <dd>N. Freed and N. Borenstein. <a
      href="http://www.ietf.org/rfc/rfc2046.txt"><cite>RFC 2046: Multipurpose
      Internet Mail Extensions (MIME) Part Two: Media Types</cite></a>.
      Internet Engineering Task Force, 1996.</dd>

      <dt id="rfc2426">RFC 2426</dt>

      <dd>F. Dawson and T. Howes. <a
      href="http://www.ietf.org/rfc/rfc2426.txt"><cite>RFC 2426: vCard MIME
      Directory Profile</cite></a>. Internet Engineering Task Force,
      1998.</dd>

      <dt id="rfc2445">RFC 2445</dt>

      <dd>F. Dawson and and D. Stenerson. <a
      href="http://www.ietf.org/rfc/rfc2426.txt"><cite>RFC 2445: Internet
      Calendaring and Scheduling Core Object Specification
      (iCalendar)</cite></a>. Internet Engineering Task Force, 1998.</dd>

      <dt id="rfc3339">RFC 3339</dt>

      <dd>G. Klyne and C. Newman. <a
      href="http://www.ietf.org/rfc/rfc3339.txt"><cite>RFC 3339: Date and Time
      on the Internet: Timestamps</cite></a>. Internet Engineering Task Force,
      2002.</dd>

      <dt id="rfc3966">RFC 3966</dt>

      <dd>H. Schulzrinne. <a
      href="http://www.ietf.org/rfc/rfc3966.txt"><cite>RFC 3966: The tel URI
      for Telephone Numbers</cite></a>. Internet Engineering Task Force,
      2004.</dd>

      <dt id="rfc3986">RFC 3986</dt>

      <dd>T. Berners-Lee, R. Fielding, and L. Masinter. <a
      href="http://www.ietf.org/rfc/rfc3986.txt"><cite>RFC 3986: Uniform
      Resource Identifier (URI): Generic Syntax</cite></a>. Internet
      Engineering Task Force, 2005.</dd>

      <dt id="rfc4627">RFC 4627</dt>

      <dd>D. Crockford. <a
      href="http://www.ietf.org/rfc/rfc4627.txt"><cite>RFC 4627: The
      application/json Media Type for JavaScript Object Notation
      (JSON)</cite></a>. Internet Engineering Task Force, 2006.</dd>

      <dt id="rfc4646">RFC 4646</dt>

      <dd>A. Phillips and M. Davis. <a
      href="http://www.ietf.org/rfc/rfc4646.txt"><cite>RFC 4646: Tags for
      Identifying Languages</cite></a>. Internet Engineering Task Force,
      2006.</dd>

      <dt id="rfc4648">RFC 4648</dt>

      <dd>S. Josefsson. <a
      href="http://www.ietf.org/rfc/rfc4648.txt"><cite>RFC 4648: The Base16,
      Base32, and Base64 Data Encodings</cite></a>. Internet Engineering Task
      Force, 2006.</dd>

      <dt id="unicodeBOMFAQ">Unicode BOM FAQ</dt>

      <dd>Asmus Freytag and Mark Davis. <a
      href="http://www.unicode.org/unicode/faq/utf_bom.html#BOM"><cite>Unicode
      Byte Order Mark (BOM) FAQ</cite></a>. Unicode, Inc., Retrieved
      2006-06-07.</dd>

      <dt id="xmlSchema2">XML Schema 2</dt>

      <dd>Paul V. Biron and Ashok Malhotra. <a
      href="http://www.w3.org/TR/xmlschema-2/"><cite>XML Schema Part 2:
      Datatypes Second Edition</cite></a>. World Wide Web Consortium,
      2004-10-28.</dd>
    </dl>

    <h2>Acknowledgements</h2>

    <p>Brad Neuberg encouraged the creation of an alternate RDF serialization;
    Frank Manola made convincing arguments for using ordinals instead of
    integers as list element predicates.</p>

    <h2>History</h2>

    <dl>
      <dt>2007-??-??</dt>

      <dd><ul>
          <li>Changed TURF preamble delimiters.</li>

          <li>Changed TURF namespace association delimiter.</li>

          <li>Changed syntax for <code>urf.Boolean</code> short form.</li>
        </ul></dd>

      <dt>2007-11-22</dt>

      <dd><ul>
          <li>Changed syntax for <code>urf.Boolean</code> short form.</li>

          <li>Changed the TURF preface delimiter.</li>
        </ul></dd>

      <dt>2007-11-18</dt>

      <dd><ul>
          <li>Added TURF preamble.</li>

          <li>Improved TURF name grammar.</li>

          <li>Simplified TURF name namespace inheritance rules.</li>

          <li>Changed <code>urf.MediaType</code> to
          <code>content.MediaType</code>.</li>

          <li>Simplified PLOOP processing rules.</li>

          <li>Addressed merging of ordered properties.</li>

          <li>Changed syntax for <code>urf.Enum</code> value
          declarations.</li>

          <li>Introducted <code>urf.Community</code>.</li>

          <li>Reframed semantics of scoped properties in terms of URF
          communities.</li>

          <li>Added <code>urf.Proposition</code> short form.</li>

          <li>Changed comment syntax.</li>

          <li>Expanded rules for URI namespace determination.</li>

          <li>Changed syntax for <code>urf.Boolean</code> short form.</li>
        </ul></dd>

      <dt>2007-10-16</dt>

      <dd><ul>
          <li>Changed order of TURF properties declaration.</li>

          <li>Added <code>urf.init</code> property.</li>

          <li>Added PLOOP specification.</li>

          <li>Improved and clarified TURF namespace inheritance rules.</li>

          <li>Added list of ontologies along with links to their TURF
          definitions.</li>

          <li>Added RDF/XML example.</li>

          <li>Added PLOOP example.</li>

          <li>Added reference implementation links.</li>

          <li>Improved and simplified TURF URI and URI reference lexical form
          representation.</li>

          <li>Clarified and extended <code>urf.Temporal</code> types.</li>

          <li>Changed base lexical namespace URI to
          <code>&lt;http://urf.name/lexical/&gt;</code>.</li>

          <li>Added <code>urf.Language</code> type.</li>

          <li>Added <code>urf.MediaType</code> type.</li>

          <li>Changed PLOOP example to use <code>java:</code> URIs.</li>

          <li>Removed trailing delimiter from TURF temporal short forms.</li>

          <li>Added <code>urf.Enum</code> description.</li>
        </ul></dd>

      <dt>2007-10-05</dt>

      <dd><ul>
          <li>Added TURF Internet media type.</li>

          <li>Removed requirement that TURF strings must escape control
          characters.</li>

          <li>Added period to set of name characters.</li>

          <li>Added comments to TURF.</li>

          <li>Clarified and expanded TURF Unicode control escape
          sequences.</li>

          <li>Clarified and expanded namespace rules.</li>

          <li>Added <code>urf.Binary</code> type.</li>

          <li>Added <code>urf.Ordinal</code> type.</li>

          <li>Changed arrays to use ordinal indexes.</li>

          <li>Removed trailing delimiter from TURF number short forms.</li>

          <li>Removed trailing delimiter from TURF boolean short forms.</li>

          <li>Changed TURF boolean short form delimiter.</li>

          <li>Changed TURF name short form prefix delimiter.</li>

          <li>Changed TURF properties section delimiter.</li>

          <li>Improved TURF name grammar.</li>

          <li>Added <code>urf.Set</code> type.</li>

          <li>Renamed <code>urf.Array</code> to <code>urf.List</code>.</li>

          <li>Clarified TURF name reference namespace inheritance.</li>
        </ul></dd>

      <dt>2007-09-15</dt>

      <dd><ul>
          <li>Switched to <code>info:lexical</code> lexical namespaces.</li>
        </ul></dd>

      <dt>2007-09-14</dt>

      <dd><ul>
          <li>Added name reference short form.</li>

          <li>Modified syntax for sequences.</li>

          <li>Switched to <code>info:lexis</code> lexical namespaces.</li>

          <li>Changed property type for array indexes.</li>

          <li>Clarified number types.</li>

          <li>Added delimiters to boolean and number types.</li>

          <li>Added the ID namespace.</li>

          <li>Clarified array grammar.</li>

          <li>Added URF abstract model grammar.</li>

          <li>Added JSON example.</li>
        </ul></dd>

      <dt>2007-09-08</dt>

      <dd><ul>
          <li>Modified and simplified syntax for resource URI references and
          type declarations.</li>

          <li>Changed <dfn>contextual properties</dfn> to <dfn>scoped
          properties</dfn>.</li>
        </ul></dd>

      <dt>2007-09-02</dt>

      <dd><ul>
          <li>First public release of URF.</li>
        </ul></dd>
    </dl>
  </body>
</html>