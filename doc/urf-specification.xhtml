<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Uniform Resource Framework (URF)</title>
  </head>

  <body>
    <h1>Uniform Resource Framework (URF)</h1>

    <p>Copyright © 2007 GlobalMentor, Inc. This specification may be freely
    used but only in unmodifed form.</p>

    <p>Editor: Garret Wilson</p>

    <p>Version 2007-09-25</p>

    <p>The Uniform Resource Framework (URF) provides a consistent way for
    representing resources and their relationships. URF and its interchange
    formats are useful for data storage, data interchange, data querying, and
    logical inferences. URF together with its interchange formats provides a
    more powerful yet in many ways simpler and more consistent replacement for
    data-oriented XML, RDF, and JSON.</p>

    <p>This document defines the Uniform Resource Framework (URF) as an
    abstract model, and also defines a text-based representation format, Text
    URF (TURF). This document does not yet provide a description of the binary
    representation format Serial URF (SURF), or the XML-based format XML URF
    (XMURF).</p>

    <h2>Conventions</h2>

    <p>When this document refers to "URF", it indicates the URF model abstract
    from any representation format. When this document refers to "TURF", it
    indicates the textual representation of URF. Because abstract concepts
    must be textualized to be communicated in a text-based specification, at
    times a description of the URF abstract model will use TURF notation for
    clarification of the model.</p>

    <h2>TURF Quick Start</h2>

    <p>The following is the URI <code>http://urf.name/urf#janedoe</code>:</p>

    <blockquote>
      <pre><code>&lt;http://example.com/example#janedoe&gt;</code></pre>
    </blockquote>

    <p>The following is the resource identified by the URI
    <code>http://urf.name/urf#janedoe</code>:</p>

    <blockquote>
      <pre><code>«http://example.com/example#resource»</code></pre>
    </blockquote>

    <p>The following is the same resource with a label, <code>jd</code>:</p>

    <blockquote>
      <pre><code>|jd|«http://example.com/example#janedoe»</code></pre>
    </blockquote>

    <p>The following is the same resource with the example namespace used in
    short reference form. The result is that two resources are identified: the
    namespace URI, and the resource that uses the namespace in its URI.</p>

    <blockquote>
      <pre><code>|example|&lt;http://example.com/example&gt;,
|jd|«|example|#janedoe»</code></pre>
    </blockquote>

    <p>For namespaced resource URIs, the reference can be replaced with a
    simple name. The following is semantically identical to the previous
    example:</p>

    <blockquote>
      <pre><code>|example|&lt;http://example.com/example&gt;,
|jd|example:janedoe</code></pre>
    </blockquote>

    <p>The following is the same resource with a type of
    <code>foaf:Person</code> and with other properties declared. Strings and
    numbers are resources and can themselves be described. The salary value
    resource is given a scoped property indicating the currency. The currency
    resource is identified using a lexical namespace for the
    <code>example:Currency</code> type. Comments are surrounded by
    asterisks.</p>

    <blockquote>
      <pre><code>*declare and label the example and foaf namespaces*
|example|&lt;http://example.com/example&gt;,
|foaf|&lt;http://xmlns.com/foaf/0.1/&gt;,

*describe a FOAF person identified by the URI &lt;http://example.com/example#janedoe&gt;*
example:janedoe(foaf:Person)
{
  example:name="Jane Doe",
  example:birthday=@1980-01-01@,
  example:salary=#1000000#
  {
    example:currency~«"usd"|example|#Currency»
  }
}</code></pre>
    </blockquote>

    <p>The following is semantically equivalent to the preceding example but
    uses longer TURF forms (and no comments):</p>

    <blockquote>
      <pre><code>«http://example.com/example#janedoe»
{
  «http://www.urf.name/urf#type»=«http://xmlns.com/foaf/0.1/Person»,
  «http://example.com/example#name»=«info:lexical/http%3A%2F%2Furf.name%2Furf%23String#Jane%20Doe»,
  «http://example.com/example#birthday»=«info:lexical/http%3A%2F%2Furf.name%2Furf%23String#1980-01-01»,
  «http://example.com/example#salary»=«info:lexical/http%3A%2F%2Furf.name%2Furf%23Integer#1000000»
  {
    «http://example.com/example#currency»~«info:lexical/http%3A%2F%2Fexample.com%2Fexample%23Currency#usd»
  }
}</code></pre>
    </blockquote>

    <h2>Primer</h2>

    <h3>Resources</h3>

    <dl>
      <dt>URF</dt>

      <dd><p>Everything that can be described by URF is referred to as a
      <dfn>resource</dfn>. Every resource is an instance of the class
      <code>urf:Resource</code>.</p></dd>

      <dt>TURF</dt>

      <dd><p>A resource can be described by curly brackets. Multiple resources
      are separated by commas. The following example refers to an anonymous
      resource:</p><blockquote>
          <pre><code>{}</code></pre>
        </blockquote><p>A resource can optionally be given a label which can
      be used as a short representation to refer the resource only within the
      interchange document. A resource label is a series of <a
      href="#namechar">name characters</a> placed in front of a resource
      description and surrounded by vertical bars, as in the following
      example:</p><blockquote>
          <pre><code>|label|{}</code></pre>
        </blockquote></dd>
    </dl>

    <h3>Resource Identification</h3>

    <dl>
      <dt>URF</dt>

      <dd><p>A resource may be <dfn>anonymous</dfn> or may be identified by a
      URI.</p></dd>

      <dt>TURF</dt>

      <dd><p>A URI is indicated by angle brackets. The following example
      indicates the URI represented by the characters
      <code>http://example.com/example#resource</code>:</p><blockquote>
          <pre><code>&lt;http://example.com/example#resource&gt;</code></pre>
        </blockquote><p>A resource may be identified by placing its URI
      characters within angle quotes, in which the curly brackets are optional
      if the resource has no properties. The following example refers to the
      resource identified by the URI
      <code>&lt;http://urf.name/urf#resource&gt;</code>.</p><blockquote>
          <pre><code>«http://example.com/example#resource»</code></pre>
        </blockquote><p>All URIs may be relative references, which are
      resolved to the base URI of the interchange document. URIs that have
      been given a label may also be used as a base reference against which
      the rest of the relative reference is resolved, by placing the base URI
      label at the beginning of the relative reference. The following example
      uses a labeled URI, defined in the first line, as a base URI in the
      second line to resolve into the same resource identified
      above:</p><blockquote>
          <pre><code>|example|&lt;http://example.com/example&gt;,
«|example|#resource»</code></pre>
        </blockquote></dd>
    </dl>

    <h3>Namespaces</h3>

    <dl>
      <dt>URF</dt>

      <dd><p>A set of resources (those part of a particular
      <dfn>ontology</dfn>, for example) may be grouped together for
      identification purposes by using a common <dfn>namespace</dfn>. A
      namespace is a URI that serves as a base for the formation of URIs
      within that namespace. If a resource lies within a namespace, the
      resource's <var>local name</var> is the part appearing after the pound
      sign in the URI fragment identifier. A namespace URI therefore may not
      have a fragment identifier. A URI within a namespace is formed by
      appending a pound sign followed by the resource's local name to the
      namespace URI. This allows the namespace and local name to be
      unambiguously determined given any URI within a namespace. For example,
      the URI <code>&lt;http://urf.name/urf#Resource&gt;</code> is within the
      namespace <code>&lt;http://urf.name/urf&gt;</code>. Not all resource
      URIs are part of some namespace.</p></dd>

      <dt>TURF</dt>

      <dd><p>TURF facilitates identification of a resource within a namespace
      using the URI resolution process described above. If
      <code>&lt;http://example.com/example&gt;</code> identifies a namespace
      and is given the label <code>example</code>, for example, the reference
      <code>«|example|#resource»</code> would indicate the same resource as
      would the reference
      <code>«http://example.com/example#resource»</code>.</p><p>A resource
      within a namespace can be identified in an even shorter format by
      listing the unencoded local name of the resource, with an optional
      prefix separated by a colon. The prefix, if present, is the name of the
      label of a previously labeled URI. If no prefix is present, the
      namespace is considered to be the namespace of the type of the subject
      resource for properties, or the namespace of the corresponding property
      for property values. If <code>&lt;http://example.com/example&gt;</code>
      identifies a namespace and is given the label <code>example</code>, for
      example, the reference <code>example:resource</code> would indicate the
      same resource as would the references <code>«|example|#resource»</code>
      and <code>«http://example.com/example#resource»</code></p></dd>
    </dl>

    <p>This specification uses resources in the following namespaces, with
    corresponding labels:</p>

    <dl>
      <dt><code>|example|&lt;http://example.com/example&gt;</code></dt>

      <dd>An example namespace; used for hypothetical situations.</dd>

      <dt><code>|urf|&lt;http://www.urf.name/urf&gt;</code></dt>

      <dd>The URF namespace for resource and properties related to the
      framework abstract model itself.</dd>
    </dl>

    <h3>Properties</h3>

    <dl>
      <dt>URF</dt>

      <dd><p>A resource may be related to another resource by the use of a
      <dfn>property</dfn>. Every property is itself a resource, although it is
      not implicitly an instance of the class <code>urf:Property</code> unless
      declared to be so. A resource <dfn>subject</dfn>, a property
      <dfn>predicate</dfn>, and the related resource <dfn>object</dfn>
      together make an <dfn>assertion</dfn> about the universe being
      described.</p><p>An infinite number of assertions may be made about a
      single subject resource. Repeated assertions about a subject resource
      with the same same predicate property and the same object resource are
      considered identical.</p></dd>

      <dt>TURF</dt>

      <dd><p>Assertions about a particular subject resource are presented
      within curly brackets and separated by commas. Each predicate property
      and object resource pair of an assertion are separated by an equals
      character. Object resources, like resources in other contexts, can serve
      as the subject of other property assertions. In the following example,
      the resource <code>«http://example.com/example#resource»</code> has a
      single property <code>«http://example.com/example#property»</code>,
      which has as its value another resource,
      <code>«http://example.com/example#value»</code>:</p><blockquote>
          <pre><code>«http://example.com/example#resource»
{
  «http://example.com/example#property»=«http://example.com/example#value»
}</code></pre>
        </blockquote><p>Were the label <code>example</code> defined to
      indicate the namespace <code>&lt;http://example.com/example&gt;</code>,
      the above example could be represented in the following shorthand
      representation:</p><blockquote>
          <pre><code>|example|&lt;http://example.com/example&gt;,
example:resource
{
  example:property=example:value
}</code></pre>
        </blockquote></dd>
    </dl>

    <h3>Classes</h3>

    <dl>
      <dt>URF</dt>

      <dd><p>A resource may represent a <dfn>class</dfn> or set of resources
      containing instances of other resources. As stated earlier, for example,
      all resources are implicitly instances of the class
      <code>urf:Resource</code>. Any resource may be explicitly asserted to be
      an instance of some class by identifying the class resource as a value
      of the <code>urf:type</code> property.</p></dd>

      <dt>TURF</dt>

      <dd><p>It can be asserted that a resource is an instance of a class by
      normal representation of the <code>urf:type</code> property. In the
      following example, the resource <code>example:resource</code> is
      asserted to be an instance of the class
      <code>example:Class</code>:</p><blockquote>
          <pre><code>|urf|&lt;http://www.urf.name/urf&gt;,
|example|&lt;http://example.com/example&gt;,
example:resource
{
  urf:type=example:Class,
  example:property=example:value
}</code></pre>
        </blockquote><p>As a shorthand representation, that a resource is an
      instance of one or more classes may be represented by placing the class
      resource after resource reference, surrounded by parentheses. Multiple
      classes may be separated by commas. The following example is
      semantically identical to the preceding example. Note also that, because
      the properties of <code>example:resource</code> are in the same
      namespace as its class <code>example:Class</code> presented in the class
      short form, the properties do not need name prefixes; their namespaces
      are understood to be the same as that of
      <code>example:Class</code>.</p><blockquote>
          <pre><code>|example|&lt;http://example.com/example&gt;,
example:resource(example:Class)
{
  property=example:value
}</code></pre>
        </blockquote></dd>
    </dl>

    <h3>URF Types</h3>

    <p>URF comes with several built-in types, including:</p>

    <dl>
      <dt><code>urf:Array</code></dt>

      <dd>Array resources are resources that contain other <dfn>element</dfn>
      resources at certain <dfn>indexes</dfn> of the array. An array, like
      normal resources, may have any property, but the properties representing
      the contents of the array lie in the integer namespace
      <code>&lt;info:lexical/http%3A%2F%2Furf.name%2Furf%23Integer&gt;</code>,
      each representing the integer index of the element. That is, if an array
      contains an element at index 5, the element resource will appear as a
      value of the property
      <code>«info:lexical/http%3A%2F%2Furf.name%2Furf%23Integer#5»</code>
      (that is, the property <code>«"5"|urf|#Integer»</code>, or simply
      <code>#5#</code>). Although many uses cases will prefer a continuous,
      unduplicated sequence of index properties beginning with
      <code>#5#</code>, this is not an URF requirement.</dd>

      <dt><code>urf:Boolean</code></dt>

      <dd>There are two boolean resources, the binary values <code>true</code>
      and <code>false</code>. Boolean resources are identified by lexical
      namespace URIs with lexical representations of <code>"true"</code> and
      <code>"false"</code>, respectively.</dd>

      <dt><code>urf:Character</code></dt>

      <dd>Character resources are the Unicode code points, and their lexical
      forms are the Unicode characters represented by those code points.</dd>

      <dt><code>urf:Integer»</code></dt>

      <dd>Integer resources are the positive whole numbers, the negative whole
      numbers, and zero. They are identified by lexical namesapce URIs with a
      lexical representation in the form
      <code><strong>[</strong>-<strong>]</strong><var>romandigit</var><strong>+</strong></code>.
      The integer class is a subclass of the class
      <code>urf:Number</code>.</dd>

      <dt><code>urf:Real</code></dt>

      <dd>Real number are all of the measuring numbers and may include decimal
      fractional parts. They are identified by lexical namesapce URIs with a
      lexical representation in the form
      <strong>[</strong>-<strong>]</strong><var>romandigit</var><strong>+</strong>.<var>romandigit</var><strong>+[</strong>e<strong>[</strong>+<strong>|</strong>-<strong>]</strong><var>romandigit</var><strong>+]</strong>.
      The integer class is a subclass of the class
      <code>urf:Number</code>.</dd>

      <dt><code>urf:Property</code></dt>

      <dd>Not every resource used as a predicate is an instance of the class
      <code>urf:Property</code>, but a resource may be declared to be of the
      property type to further specify its semantics and expected domain and
      range.</dd>

      <dt><code>urf:RegularExpression</code></dt>

      <dd>Regular expression resources are text-based patterns that define
      rules for the content of strings. These are lexical namespace
      resources.</dd>

      <dt><code>urf:Resource</code></dt>

      <dd>Every resource is implicitly an instance of the class
      <code>urf:Resource</code>. The resources <code>urf:Property</code> and
      <code>urf:Resource</code> are both instances of the class
      <code>urf:Resource</code>.</dd>

      <dt><code>urf:String</code></dt>

      <dd>String resources are sequences of Unicode code points or text and
      lie in the corresponding lexical namespace.</dd>

      <dt><code>urf:Timestamp</code></dt>

      <dd>Timestamp resources, which use a lexical namespace, are particular
      points in time and have a lexical form defined in [<a
      href="#rfc3339">RFC 3339</a>].</dd>
    </dl>

    <h3 id="lexical">Lexical Namespaces</h3>

    <dl>
      <dt>URF</dt>

      <dd><p>Some resource types contain resource instances that in day-to-day
      life have customarily been identified by character sequences or
      <dfn><dfn>lexical representations</dfn></dfn>. For example, the integer
      <code>123</code> has historically been represented by the character
      sequence <code>"123"</code>, although the number itself is an abstract
      concept, not a series of characters. Similarly, the two boolean values
      are usually represented as the character sequences <code>"true"</code>
      and <code>"false"</code>. URF provides for a series of namespaces to
      identify resources that are typically identified by lexical
      representations. Each lexical namespace is an <code>info</code> [<a
      href="#rfc4452">RFC 4452</a>] URI with an info-identifier namespace of
      <code>lexical</code>, and have the following format,</p><blockquote>
          <pre><code>info:lexical/<var>encodedTypeURI</var>#<var>encodedLexicalForm</var></code></pre>
        </blockquote><p>where <var>encodedTypeURI</var> is the URI path
      segment-encoded form of the full type URI of the resource, and
      <var>encodedLexicalForm</var> is the URI path segment-encoded canonical
      lexical form of the resource as defined by the indicated type. For
      example, the integer 123, which is of the type
      <code>«http://urf.name/urf#Integer»</code>, is represented in URF using
      the following URI:</p><blockquote>
          <pre><code>info:lexical/http%3A%2F%2Furf.name%2Furf%23Integer#123</code></pre>
        </blockquote><p>A resource in a lexical namespace is implicitly an
      instance of the type indicated in the <var>encodedTypeURI</var> section
      of the URI. In all other aspects resources in lexical namespaces are no
      different from resources not in a lexical namespace; these resources are
      <em>not</em> instances of a special resource type solely because their
      namespaces are lexical namespaces. Lexical namespaces provide a
      framework for easily and consistently formulating identifying URIs for
      resources that are traditionally identified in lexical form; lexical
      namespaces in themselves imply no additional semantics.</p></dd>

      <dt>TURF</dt>

      <dd><p>Any representation of a resource in a lexical namespace also
      implicitly asserts the type of the resource. A resource in a lexical
      namespace can be identified by its URI as with any other resource.For
      example, the integer 123 can be identified by its URI
      <code>&lt;info:lexical/http%3A%2F%2Furf.name%2Furf%23Integer#123&gt;</code>
      as in the following example:</p><blockquote>
          <pre><code>«info:lexical/http%3A%2F%2Furf.name%2Furf%23Integer#123»</code></pre>
        </blockquote><p>Rather than indicating directly the URI of a resource
      in a lexical namespace, the resource may be identified by indicating the
      canonical lexical form of the resource, followed by the contents of the
      URI of the type of the resource. The integer 123 may therefore be
      represented in the following short form:</p><blockquote>
          <pre><code>«"123"|urf|#Integer»</code></pre>
        </blockquote><p>The lexical namespaces for several types have
      additional short representations. The examples below assume that the
      label <code>urf</code> has been assigned to the URF namespace.</p><dl>
          <dt><code>urf:Boolean</code></dt>

          <dd><p>An boolean resource may be identified by its lexical form
          surrounded by exclamation points. For example, the following short
          representation,</p><blockquote>
              <pre><code>!true!</code></pre>
            </blockquote><p>is equivalent to the following long
          representation,</p><blockquote>
              <pre><code>«info:lexical/http%3A%2F%2Furf.name%2Furf%23Boolean#true»</code></pre>
            </blockquote><p>which is also equivalent to the following general
          short representation for resources in a lexical
          namespace:</p><blockquote>
              <pre><code>«"true"|urf|#Boolean»</code></pre>
            </blockquote></dd>

          <dt><code>urf:Character</code></dt>

          <dd><p>A character resource may be identified by its <a
          href="#charactershort">character-escaped lexical form</a> with
          surrounding single quotes. For example, the following short
          representation,</p><blockquote>
              <pre><code>'x'</code></pre>
            </blockquote><p>is equivalent to the following long
          representation,</p><blockquote>
              <pre><code>«info:lexical/http%3A%2F%2Furf.name%2Furf%23Character#x»</code></pre>
            </blockquote><p>which is also equivalent to the following general
          short representation for resources in a lexical
          namespace:</p><blockquote>
              <pre><code>«"x"|urf|#Character»</code></pre>
            </blockquote></dd>

          <dt><code>urf:Number</code></dt>

          <dd><p>Number resources, including integer and real number
          resources, may be identified by their lexical forms sounded by
          number signs. The specific type of number resource yielded depends
          on the lexical form used. For example, the following short
          representations,</p><blockquote>
              <pre><code>#123#
#123.45#</code></pre>
            </blockquote><p>are equivalent to the following long
          representations, respectively,</p><blockquote>
              <pre><code>«info:lexical/http%3A%2F%2Furf.name%2Furf%23Integer#123»
«info:lexical/http%3A%2F%2Furf.name%2Furf%23Real#123.45»</code></pre>
            </blockquote><p>which are also equivalent to the following general
          short representations for resources in a lexical namespace,
          respectively:</p><blockquote>
              <pre><code>«"123"|urf|#Integer»
«"123.45"|urf|#Real»</code></pre>
            </blockquote></dd>

          <dt><code>urf:Timestamp</code></dt>

          <dd><p>A timestamp resource may be identified by its [<a
          href="#rfc3339">RFC 3339</a>] lexical form with surrounding at signs
          (<code>'@'</code>). For example, the following short
          representation,</p><blockquote>
              <pre><code>@1996-12-19T16:39:57-08:00@</code></pre>
            </blockquote><p>is equivalent to the following long
          representation,</p><blockquote>
              <pre><code>«info:lexical/http%3A%2F%2Furf.name%2Furf%23String#1996-12-19T16%3A39%3A57-08%3A00»</code></pre>
            </blockquote><p>which is also equivalent to the general short
          representation for resources in a lexical namespace:</p><blockquote>
              <pre><code>«"1996-12-19T16:39:57-08:00"|urf|#Timestamp»</code></pre>
            </blockquote></dd>

          <dt><code>urf:RegularExpression</code></dt>

          <dd><p>A regular expression resource may be identified by its <a
          href="#regexshort">regular expression-escaped lexical form</a>
          surrounded by slashes ('/'). For example, the following short
          representation,</p><blockquote>
              <pre><code>/a?b+c*/</code></pre>
            </blockquote><p>is equivalent to the following long
          representation,</p><blockquote>
              <pre><code>«info:lexical/http%3A%2F%2Furf.name%2Furf%23RegularExpression#a%3Fb%2Bc*»</code></pre>
            </blockquote><p>which is also equivalent to the general short
          representation for resources in a lexical namespace:</p><blockquote>
              <pre><code>«"a?b+c*"|urf|#RegularExpression»</code></pre>
            </blockquote></dd>

          <dt><code>urf:String</code></dt>

          <dd><p>A string resource may be identified by its <a
          href="#stringshort">string-escaped lexical form</a> with surrounding
          quotes. For example, the following short
          representation,</p><blockquote>
              <pre><code>"apple"</code></pre>
            </blockquote><p>is equivalent to the following long
          representation,</p><blockquote>
              <pre><code>«info:lexical/http%3A%2F%2Furf.name%2Furf%23String#apple»</code></pre>
            </blockquote><p>which is also equivalent to the general short
          representation for resources in a lexical namespace:</p><blockquote>
              <pre><code>«"apple"|urf|#String»</code></pre>
            </blockquote></dd>

          <dt><code>urf:URI</code></dt>

          <dd><p>A URI resource may be identified by its lexical form with
          surrounding angle brackets <code>'&lt;'</code> and
          <code>'&gt;'</code>. For example, the following short
          representation,</p><blockquote>
              <pre><code>&lt;http://urf.name/urf#type&gt;</code></pre>
            </blockquote><p>is equivalent to the following long
          representation,</p><blockquote>
              <pre><code>«info:lexical/http%3A%2F%2Furf.name%2Furf%23URI#http%3A%2F%2Furf.name%2Furf%23type»</code></pre>
            </blockquote><p>which is also equivalent to the general short
          representation for resources in a lexical namespace:</p><blockquote>
              <pre><code>«"http://urf.name/urf#type"|urf|#URI»</code></pre>
            </blockquote></dd>
        </dl></dd>
    </dl>

    <h3>Reification</h3>

    <dl>
      <dt>URF</dt>

      <dd><p>Propositions may be described without actually asserting those
      propositions. The sentence, "John believes that the sky is purple," for
      example, does not assert that the skye is purple, but merely that John
      believes this to be the case. The proposition "the sky is purple" may be
      described like any other resource, using the URF class
      <code>urf:Proposition</code> and the URF properties
      <code>urf:subject</code>, <code>urf:predicate</code>, and
      <code>urf:object</code>.</p></dd>

      <dt>TURF</dt>

      <dd><p>The following example asserts that John believes the sky to have
      the color purple without asserting that the sky actually has that
      color:</p><blockquote>
          <pre><code>|urf|&lt;http://www.urf.name/urf&gt;,
|example|&lt;http://example.com/example&gt;,
example:john
{
  example:believes=(urf:Proposition)
  {
    subject=example:sky,
    predicate=example:color,
    object=example:purple
  }
}</code></pre>
        </blockquote><p>Any proposition that is asserted can be reified by
      placing a label before the equals sign in a property definition. The
      label will then identify a proposition that is the reification of the
      property assertion. For example, the label <code>proposition</code>
      identifies the asserted proposition with subject
      <code>example:juan</code>, predicate <code>example:name</code>, and
      object <code>"John"</code>. This labeled resource can then be used in
      any other situation in which a resource is expected.</p><blockquote>
          <pre><code>|example|&lt;http://example.com/example&gt;,
example:juan
{
  example:name|proposition|="John"
}</code></pre>
        </blockquote></dd>
    </dl>

    <h3>Proposition Scope</h3>

    <dl>
      <dt>URF</dt>

      <dd><p>Some assertions are only valid within a certain scope; they
      cannot be "seen", or rather, they are not considered asserted outside
      the context of the subject serving as the value of some other resource's
      property. For example, if Juan has an English name of
      <code>"John"</code>, Juan could specify a <code>example:name</code> of
      <code>"John"</code> with an <code>example:lang</code> of
      <code>example:english</code>. Because the string <code>"John"</code> may
      not represent an English string in all contexts, its property
      <code>example:lang</code> should be considered to be in the scope of the
      relationship between Juan and the <code>example:name</code>
      <code>"John"</code>. The assertion, "the string 'John' is in English",
      is contextual to the string "John" being the name of Juan. Similarly,
      Juan could specify a <code>example:weight</code> of <code>#72#</code>
      with an <code>example:unit</code> of <code>example:kilogram</code>.
      Because the integer <code>#72#</code> may not represent a unit of
      kilograms in all contexts, its property <code>example:unit</code> should
      be considered to be in the scope of the relationship between Juan and
      the <code>example:weight</code> <code>#72#</code>. The assertion, "the
      integer 72 is in kilograms", is contextual to the integer 72 being the
      weight of Juan.</p></dd>

      <dt>TURF</dt>

      <dd><p>To restrict a particular property assignment to the scope of the
      subject serving as the value of some other resource's property, the
      tilde character <code>'~'</code> is used instead of the equals sign
      <code>'='</code> in the property declaration:</p><blockquote>
          <pre><code>|example|&lt;http://example.com/example&gt;,
{
  example:name="John"
  {
    example:lang~example:english
  }
  example:weight=#72#
  {
    example:unit~example:kilogram
  }
}</code></pre>
        </blockquote></dd>
    </dl>

    <h3>Ordered Properties</h3>

    <dl>
      <dt>URF</dt>

      <dd>Although all resource property assertions of a particular subject
      have no inherent order, URF provides a facility for declaring property
      order using scoped properties. Each property that should be considered
      to have an order relative to other assertions of the same property is
      given a scoped property <code>urf:order</code> with a value of type
      <code>urf:Integer</code>, representing the relative order in which the
      property should be interpreted. The interpretation of the property's
      order is specific to the property in question. Although many uses cases
      will prefer a continuous, unduplicated sequence of order property values
      beginning with <code>0</code>, this is not an URF requirement.</dd>

      <dt>TURF</dt>

      <dd>Ordered properties may be indicated using the general representation
      for contextual properties. The following example indicates that a
      resource has two names, "William" and "Bill", and that "Will" comes
      before "Bill". (What it means that a name "comes before" another name
      depends on the definition of the name property being used. Perhaps one
      name comes before the other if used simultaneously, or perhaps one name
      has a higher priority or is considered the "default" name.) <blockquote>
          <pre><code>|urf|&lt;http://www.urf.name/urf&gt;,
|example|&lt;http://example.com/example&gt;,
{
  example:name="William"
  {
    urf:order~#0#
  },
  example:name="Bill"
  {
    urf:order~#1#
  }
}</code></pre>
        </blockquote>The same information may be presented in short
      representation in the form of a <dfn>sequence</dfn> by placing the
      ordered values within matching backslash characters. A sequence does not
      result in a new type of value, but rather indicates that the given
      predicate should be asserted for each value, each with a scoped property
      of <code>urf:order</code> with values starting at <code>#0#</code> and
      continuing sequentially. The following example represents information
      semantically identical to the previous example:<blockquote>
          <pre><code>|urf|&lt;http://www.urf.name/urf&gt;,
|example|&lt;http://example.com/example&gt;,
{
  example:name=\"William",  "Bill"\
}</code></pre>
        </blockquote></dd>
    </dl>

    <h2>URF</h2>

    <p>Everything that is described in URF is referred to as a
    <dfn>resource</dfn>. For purposes of description within URF, each resource
    may be identified using a URI.</p>

    <h3>Grammar</h3>

    <p>The following grammar indicates variables in emphasized text and
    grammar symbols in strong text.</p>

    <p>The URF abstract model can be conceptualized as a series of assertions.
    Each assertion consists of a particular scope, for which is asserted an
    object resource for a particular predicate resource.</p>

    <blockquote>
      <p><code><var>URF</var> ⇒
      <var>assertion</var><strong>*</strong></code></p>
    </blockquote>

    <blockquote>
      <p><code><var>assertion</var> ⇒ <var>scope</var><strong>,</strong>
      <var>predicate</var><strong>,</strong> <var>object</var></code></p>
    </blockquote>

    <p>A scope consists of a base resource and a series of subject-predicate
    combinations, or <dfn>scope chain</dfn>. The subject of each assertion is
    the last object in the scope chain, or the base resource if there is no
    scope chain; but the assertion is only visible and is only considered to
    exist within the context of its scope. The simplest scope is a resource
    itself.</p>

    <blockquote>
      <p><code><var>scope</var> ⇒ <var>base</var><strong>,</strong>
      <strong>(</strong><var>predicate</var><strong>,</strong>
      <var>object</var><strong>)</strong><strong>*</strong></code></p>
    </blockquote>

    <blockquote>
      <p><code><var>base</var> ⇒ <var>resource</var></code></p>
    </blockquote>

    <blockquote>
      <p><code><var>predicate</var> ⇒ <var>resource</var></code></p>
    </blockquote>

    <blockquote>
      <p><code><var>object</var> ⇒ <var>resource</var></code></p>
    </blockquote>

    <h2>TURF</h2>

    <p>TURF is the text interchange format for URF. TURF emphasizes terseness
    and consistency while maintaining human readability, with a preference for
    using symbols from existing interchange formats such as JSON and
    programming languages such as Java and C#.</p>

    <h3>Internet Media Type</h3>

    <p>The Internet media type general URF information encoded as TURF is:</p>

    <blockquote>
      <p><code>application/turf</code></p>
    </blockquote>

    <p>For any application-specific URF data encoded as TURF should be
    represented as <code>application/<var>applicationName</var>+turf</code> to
    allow the data to be recognized as such, where <var>applicationName</var>
    is the application-specific identifier for the URF information. <em>Note:
    These Internet media types have yet to be registered with the
    IANA.</em></p>

    <h3>Encoding</h3>

    <p>TURF may use any encoding in a closed environment in which all relevant
    parties are aware of the encoding being used. In situations where the
    encoding may not be readily known to a processor, such as in a general
    file stored in a file system, TURF must use the UTF-8 character encoding.
    TURF interchange document files should use a UTF-8 U+FEFF signature (the
    so-called UTF-8 Byte Order Mark or BOM) at their beginning to notify
    general text processing agents that may not be aware of TURF that UTF-8
    encoding is being used.</p>

    <h3>Grammar</h3>

    <p>The following grammar indicates literals in normal style, variables in
    emphasized text, and grammar symbols in strong text.</p>

    <p>Any two TURF tokens may be separated by separator or whitespace Unicode
    characters, or a TURF comment.</p>

    <blockquote>
      <p><code><var>SEPARATOR</var> ⇒ Unicode Paragraph Separator
      <strong>|</strong> Unicode Segment Separator <strong>|</strong> Unicode
      Whitespace <strong>|</strong> <var>comment</var></code></p>
    </blockquote>

    <blockquote>
      <p><code><var>comment</var> ⇒ *<strong>[</strong><var>Unicode character
      except '*'</var><strong>]*</strong>*</code></p>
    </blockquote>

    <p>A TURF interchange document is encoded in UTF-8, and is composed of one
    or more resource descriptions, separated by commas.</p>

    <blockquote>
      <p><code><var>TURF</var> ⇒
      <var>resource</var><strong>[</strong>,<var>resource</var><strong>]*</strong></code></p>
    </blockquote>

    <p>Each resource description must have at least one of the following
    optional components: a label, a reference, a type, a list of array
    elements, and a list of property definitions.</p>

    <blockquote>
      <p><code><var>resource</var> ⇒
      <strong>[</strong>|<var>label</var>|<strong>]</strong><strong>[</strong><var>reference</var><strong>]</strong><strong>[</strong>(<var>type</var>)<strong>]</strong><strong>[</strong><var>arrayshort</var><strong>]</strong><strong>[</strong>{<var>properties</var>}<strong>]</strong></code></p>
    </blockquote>

    <p>A label consists of one or more name characters.</p>

    <blockquote>
      <p><code><var>label</var> ⇒
      <var>namechar</var><strong>+</strong></code></p>
    </blockquote>

    <p>A name character is any letter, digit, underscore, or period.</p>

    <blockquote id="namechar">
      <p><code><var>namechar</var> ⇒ <var>Unicode Letter</var>
      <strong>|</strong> <var>Unicode Decimal Digit Number</var>
      <strong>|</strong> _ <strong>|</strong> .</code></p>
    </blockquote>

    <p>A resource reference is a URI reference or one of several short
    representations.</p>

    <blockquote>
      <p><code><var>reference</var> ⇒ <var>urireference</var>
      <strong>|</strong> <var>nameshort</var> <strong>|</strong>
      <var>urishort</var> <strong>|</strong> <var>stringshort</var>
      <strong>|</strong> <var>booleanshort</var> <strong>|</strong>
      <var>numbershort</var> <strong>|</strong> <var>charactershort</var>
      <strong>|</strong> <var>regexshort</var> <strong>|</strong>
      <var>timestampshort</var></code></p>
    </blockquote>

    <p>A resource URI reference is enclosed in angle quotes. The contents is
    either the text of a URI (or relative reference); the text of a URI
    preceded by the label of a base URI; or a string containing the lexical
    representation of a resource in a lexical namespace, immediately followed
    by the text of the URI of the type of the resource. Any URI reference that
    includes a lexical representation is equivalent to a URI reference in the
    form
    <code>«info:lexical/<var>encodedTypeURI</var>#<var>encodedLexicalForm</var></code>».</p>

    <blockquote>
      <p><code><var>urireference</var> ⇒
      «<strong>[</strong><var>stringshort</var><strong>]</strong><strong>[</strong>|<var>label</var>|<strong>]</strong><var>urichar</var><strong>+</strong>»</code></p>
    </blockquote>

    <p>A name short reference is a sequence of name characters together
    representing the local name of a resource, optionally preceded by other
    name characters ending with the ':' character, together representing the
    name of a label of a predeclared namespace URI. If no prefix is present,
    the namespace is the same as the namespace of the predicate resource for
    object resources; or the namespace of the first type short form of the
    subject resource for predicate resources. The local name is the unencoded
    form of the fragment to be appended to the namespace URI.</p>

    <blockquote>
      <p><code><var>nameshort</var> ⇒
      <strong>[</strong>prefix:<strong>]</strong>localName</code></p>
    </blockquote>

    <blockquote>
      <p><code><var>prefix</var> ⇒
      <var>namechar</var><strong>+</strong></code></p>
    </blockquote>

    <blockquote>
      <p><code><var>localName</var> ⇒
      <var>namechar</var><strong>+</strong></code></p>
    </blockquote>

    <p>A string short form is a sequence of Unicode characters, using the
    backslash as an escape character, enclosed in double quotes. The double
    quotation mark (<code>'"'</code>) and backslash (<code>'\\'</code>)
    characters must be escaped. Any Unicode code point may be represented by
    the four lowercase hexadecimal representation following the character
    sequence <code>"\u"</code>, or if the code point is not in the Basic
    Multilingual Plane, two such sequences representing UTF-16 surrogate pair.
    A string short form is equivalent to a resource of type
    <code>urf:String</code> using the corresponding lexical namespace. The
    string short form <code>"example"</code> is the equivalent of the string
    resource <code>«"example"|urf|#String»</code>.</p>

    <blockquote id="stringshort">
      <p><code><var>stringshort</var> ⇒ "<strong>[</strong><var>Unicode
      character except double quote and backslash</var> <strong>|</strong> \"
      <strong>|</strong> \\ <strong>|</strong> \b <strong>|</strong> \t
      <strong>|</strong> \r <strong>|</strong> \n <strong>|</strong> \f
      <strong>|</strong> \u<var>xxxx</var><strong>]*</strong>"</code></p>
    </blockquote>

    <p>A character short form is a single Unicode characters, using the
    backslash as an escape character, enclosed in a single quote. The single
    quote (<code>'\''</code>) and backslash (<code>'\\'</code>) characters
    must be escaped. Any Unicode code point may be represented by the four
    lowercase hexadecimal representation following the character sequence
    <code>"\u"</code>, or if the code point is not in the Basic Multilingual
    Plane, two such sequences representing UTF-16 surrogate pair. A string
    short form is equivalent to a resource of type <code>urf:Character</code>
    using the corresponding lexical namespace. The character short form
    <code>'x'</code> is the equivalent of the character resource
    <code>«"x"|urf|#Character»</code>.</p>

    <blockquote id="charactershort">
      <p><code><var>charactershort</var> ⇒ '<strong>[</strong><var>Unicode
      character except single quote and backslash</var> <strong>|</strong> \'
      <strong>|</strong> \\ <strong>|</strong> \b <strong>|</strong> \t
      <strong>|</strong> \r <strong>|</strong> \n <strong>|</strong> \f
      <strong>|</strong> \u<var>xxxx</var><strong>]*</strong>'</code></p>
    </blockquote>

    <p>A URI short form is a sequence of character constituting a
    syntactically correct URI or a relative reference, surrounded by the angle
    brackets <code>'&lt;'</code> and <code>'&gt;'</code>. If a relative
    reference is provided, it is resolved against the base URI of the TURF
    document according to the rules specified in [<a
    href="#rdfxml">RDF/XML</a>] <cite>5.3 Resolving URIs</cite>. If a label
    appears at the beginning of the URI characters and that label refers to a
    previously defined URI resource, the remaining characters are interpreted
    as a relative reference and resolved against the URI to which the label
    refers. A single relative reference is resolved to the base URI of the
    interchange document. A URI short form is equivalent to a resource of type
    <code>urf:URI</code> using the corresponding lexical namespace. The URI
    short form <code>&lt;http://example.com&gt;</code> is the equivalent of
    the URI resource <code>«"http://example.com"|urf|#URI»</code>.</p>

    <blockquote>
      <p><code><var>urishort</var> ⇒
      &lt;<strong>[</strong>|<var>label</var>|<strong>]</strong><var>urichar</var><strong>+</strong>&gt;</code></p>
    </blockquote>

    <p>A boolean short form is the character sequence <code>true</code> or
    <code>false</code> surrounded by the <code>'!'</code> character. A boolean
    short form is equivalent to a resource of type <code>urf:Boolean</code>
    using the corresponding lexical namespace. The boolean short form
    <code>!true!</code> is the equivalent of the boolean resource
    <code>«"true"|urf|#Boolean»</code>.</p>

    <blockquote>
      <p><code><var>booleanshort</var> ⇒
      !true!<strong>|</strong>!false!</code></p>
    </blockquote>

    <p>A number short form consists of roman digits with an optional decimal
    with an optional exponent, all surrounded by the number sign
    <code>'#'</code>. A number short form is equivalent to a resource of type
    <code>urf:Integer</code> or <code>urf:Real</code>, depending on the
    lexical form used, using the corresponding lexical namespace. The number
    short form <code>#123#</code> is the equivalent of the number resource
    <code>«"123"|urf|#Integer»</code>, and the number short form
    <code>#123.45#</code> is the equivalent of the number resource
    <code>«"123.45"|urf|#Real»</code>.</p>

    <blockquote>
      <p><code><var>numbershort</var> ⇒
      <strong>[</strong>-<strong>]</strong><var>romandigit</var><strong>+[</strong>.<var>romandigit</var><strong>+][</strong>e<strong>[</strong>+<strong>|</strong>-<strong>]</strong><var>romandigit</var><strong>+]</strong></code></p>
    </blockquote>

    <p>A regular expression short form is a sequence of Unicode characters,
    using the backslash as an escape character, enclosed in forward slash
    (<code>'/'</code>) characters. The slash (<code>'/'</code>) and backslash
    (<code>'\\'</code>) characters must be escaped. Any Unicode code point may
    be represented by the four lowercase hexadecimal representation following
    the character sequence <code>"\u"</code>, or if the code point is not in
    the Basic Multilingual Plane, two such sequences representing UTF-16
    surrogate pair. A regular expression short form is equivalent to a
    resource of type <code>urf:RegularExpression</code> using the
    corresponding lexical namespace. The regular expression short form
    <code>/a?b+c*/</code> is the equivalent of the string resource
    <code>«"a?b+c*"|urf|#RegularExpression»</code>.</p>

    <blockquote id="regexshort">
      <p><code><var>regexshort</var> ⇒ /<strong>[</strong><var>Unicode
      character except slash and backslash</var> <strong>|</strong> \/
      <strong>|</strong> \\ <strong>|</strong> \b <strong>|</strong> \t
      <strong>|</strong> \r <strong>|</strong> \n <strong>|</strong> \f
      <strong>|</strong> \u<var>xxxx</var><strong>]*</strong>/</code></p>
    </blockquote>

    <p>Type consists of zero or more resource specifications between parenthes
    characters <code>'('</code> and <code>')'</code>, each resource indicating
    a type of the resource being described. Indicating a type in this manner
    is equivalent to indicating the type as the value of a
    <code>urf:type</code> property.</p>

    <blockquote>
      <p><code><var>type</var> ⇒
      (<strong>[</strong><var>resource</var><strong>[,</strong><var>resource</var><strong><strong>]*</strong>]</strong>)</code></p>
    </blockquote>

    <p>An array short form consists of a bracketed sequence of element
    resources separated by commas. Each listed element resource represents the
    value of an index property, in sequence beginning with the integer
    property <code><code>#0#</code></code>.</p>

    <blockquote>
      <p><code><var>arrayshort</var> ⇒
      [<strong>[</strong>resource<strong>[</strong>,resource<strong>]*]</strong>]</code></p>
    </blockquote>

    <p>Properties consist of a comma-separated list of predicate resource and
    object resource pairs. Within each of these pairs, the separator
    <code>'='</code> is used to denote normal properties, and the separator
    <code>'~'</code> is used to denote scoped properties in the scope of the
    property's subject resource and its respective predicate resource and
    subject resource. If a label is provided, it identifies the proposition
    represented by the reification of the assertion.</p>

    <blockquote>
      <p><code><var>properties</var> ⇒
      <strong>[</strong><var>property</var><strong>[,</strong><var>property</var><strong><strong>]*</strong>]</strong></code></p>
    </blockquote>

    <blockquote>
      <p><code><var>property</var> ⇒
      <var>resource</var><strong>[</strong>|<var>label</var>|<strong>]</strong><strong>(</strong>=<strong>|</strong>~<strong>)</strong><strong>(</strong><var>sequenceshort</var><strong>|</strong><var>resource</var><strong>)</strong></code></p>
    </blockquote>

    <p>A sequence short form consists of a sequence of element resources
    separated by commas and surrounded by the backslash character
    <code>'\\'</code>. Each listed element resource indicates another
    assertion of the given predicate with the given element resource as the
    value, each with a contextual property of <code>urf:order</code> with
    values starting at <code>#0#</code> and continuing sequentially.</p>

    <blockquote>
      <p><code><var>sequenceshort</var> ⇒
      \<strong>[</strong>resource<strong>[</strong>,resource<strong>]*]</strong>\</code></p>
    </blockquote>

    <h2>Examples</h2>

    <h3>JSON</h3>

    <p>In the JavaScript Object Notation (JSON) [<a href="#rfc4627">RFC
    4627</a>], every object besides strings, numbers, and booleans are
    associative arrays using string keys. The following is a complex JSON
    object, using every JSON data type available:</p>

    <blockquote>
      <pre><code>{
  "length":1234,
  "valid":true,
  "status":"processing",
  "results":[false, 5, "dog", {"code":9.8}]
}</code></pre>
    </blockquote>

    <p>While this representation has some undesirable traits (e.g. strings are
    not recommended as general property identifiers), the following URF
    representation is semantically identical to the JSON example above:</p>

    <blockquote>
      <pre><code>{
  "length"=#1234,
  "valid"=!true!,
  "status"="processing",
  "results"=[!false!, #5#, "dog", {"code":#9.8#}]
}</code></pre>
    </blockquote>

    <p>There is one slight semantic descrepancy between these two examples:
    for arrays URF adds each element as the value of a property that is a true
    integer; JSON adds each array element as the value of a string containing
    the lexical form of an integer.</p>

    <h3>VCard</h3>

    <p>The VCard [<a href="#rfc2426">RFC 2426</a>] name example,</p>

    <blockquote>
      <pre><code>N:Stevenson;John;Philip,Paul;Dr.;Jr.,M.D.,A.C.P.</code></pre>
    </blockquote>

    <p>can be represented in the following URF formulation, with added type
    and subproperty information:</p>

    <blockquote>
      <pre><code>|urf|&lt;http://urf.name/urf&gt;,
|vcard|&lt;http://urf.com/vcard&gt;,
{
  vcard:n=(vcard:Name)
  {
    familyName="Stevenson",
    givenName="John",
    additionalName=\"Philip", "Paul"\,
    honoraryPrefix="Dr.",
    honorarySuffix=\"Jr.", "M.D.", "A.C.P."\
  }
}</code></pre>
    </blockquote>

    <h2>Comparisons</h2>

    <h3>Differences between URF and JSON</h3>

    <p></p>

    <ul>
      <li>Any URF resource may be identified by a URI. JSON makes no provision
      for identifying resources.</li>

      <li>URF allows globally consistent semantic properties by identifying
      resources with URIs. JSON properties names are local and may clash with
      semantically distinct property names among resources.</li>

      <li>URF provides a system for grouping resources within a common
      namespace, with the management of control for those namespaces
      facilitated by the Internet domain name system. JSON properties cannot
      be so aportioned, making name clashes more likely.</li>

      <li>URF has two concrete number types,
      <code>«http://urf.name/urf#Integer»</code> and
      <code>«http://urf.name/urf#Real»</code>. JSON has only a single number
      type.</li>

      <li>URF has a character type,
      <code>«http://urf.name/urf#Character»</code>. JSON has no character
      type.</li>

      <li>URF has a timestamp type,
      <code>«http://urf.name/urf#Timestamp»</code>. JSON has no date or time
      type.</li>
    </ul>

    <h3>Differences between URF and RDF</h3>

    <p>URF is a semantic superset of RDF. Anything that can be represented by
    the RDF abstract syntax can be represented by the URF abstract model.
    Converting from URF to RDF is possible but would require special
    URF-related RDF ontologies to encapsulate the extra semantics built into
    the URF abstract model.</p>

    <ul>
      <li>URF considers all resources equal, providing for consistent
      identification and property designation of every resource. RDF considers
      certain resources, such as numbers and strings, to be of special
      <dfn>literal</dfn> resource types which are not identified by URIs (in
      contrast to all other non-literal resources) and to which properties
      cannot be given.</li>

      <li>URF provides a facility for declaring the order of properties. RDF
      has no such facility.</li>

      <li>URF provides for contextual properties. RDF has no such
      concept.</li>

      <li>URF has a character type,
      <code>«http://urf.name/urf#Character»</code>. RDF, which uses XML Schema
      data types (TODO cite), has no character type.</li>

      <li>URF has a regular expression type,
      <code>«http://urf.name/urf#RegularExpression»</code>. RDF has no regular
      expression type.</li>
    </ul>

    <h3>Differences between URF and XML</h3>

    <p></p>

    <ul>
      <li>URF provides a single type of subrelation: properties. XML provides
      two types of subrelations: attributes and child elements.</li>

      <li>URF uses global URIs to identify nodes in a graph. XML uses string
      IDs local to the defining document.</li>
    </ul>

    <h3>Differences between TURF and RDF/XML</h3>

    <p></p>

    <ul>
      <li>TURF allows any resource, including strings and other resources in
      lexical namespaces, to be labeled for later reference. RDF/XML does not
      allow so-called RDF literal resources to be labeled.</li>

      <li>TURF allows any resource to appear in a its ordered type, the array.
      RDF/XML does not allow so-called RDF literal resources to appear in its
      ordered type, the list.</li>
    </ul>

    <h2>References</h2>

    <p></p>

    <dl>
      <dt id="rfc2426">IETF RFC 2426</dt>

      <dd>F. Dawson and T. Howes. <a
      href="http://www.ietf.org/rfc/rfc2426.txt"><cite>RFC 2426: vCard MIME
      Directory Profile</cite></a>. Internet Engineering Task Force,
      1998.</dd>

      <dt id="rfc3339">IETF RFC 3339</dt>

      <dd>G. Klyne and C. Newman. <a
      href="http://www.ietf.org/rfc/rfc3339.txt"><cite>RFC 3339: Date and Time
      on the Internet: Timestamps</cite></a>. Internet Engineering Task Force,
      2002.</dd>

      <dt id="rfc4452">IETF RFC 4452</dt>

      <dd>H. Van de Sompel, T. Hammond, E. Neylon, and S. Weibel. <a
      href="http://www.ietf.org/rfc/rfc4452.txt"><cite>RFC 4452: The "info"
      URI Scheme for Information Assets with Identifiers in Public
      Namespaces</cite></a>. Internet Engineering Task Force, 2006.</dd>

      <dt id="rfc4627">IETF RFC 4627</dt>

      <dd>D. Crockford. <a
      href="http://www.ietf.org/rfc/rfc4627.txt"><cite>RFC 4627: The
      application/json Media Type for JavaScript Object Notation
      (JSON)</cite></a>. Internet Engineering Task Force, 2006.</dd>

      <dt id="rdfxml">RDF/XML</dt>

      <dd>Dave Beckett. <a
      href="http://www.w3.org/TR/rdf-syntax-grammar/"><cite>RDF/XML Syntax
      Specification (Revised)</cite></a>. World Wide Web Consortium, 10
      February 2006.</dd>
    </dl>

    <h2>History</h2>

    <p></p>

    <dl>
      <dt>2007-09-??</dt>

      <dd><ul>
          <li>Added TURF Internet media type.</li>

          <li>Removed requirement that TURF strings must escape control
          characters.</li>

          <li>Added period to set of name characters.</li>

          <li>Added comments to TURF.</li>
        </ul></dd>

      <dt>2007-09-15</dt>

      <dd><ul>
          <li>Switched to <code>info:lexical</code> lexical namespaces.</li>
        </ul></dd>

      <dt>2007-09-14</dt>

      <dd><ul>
          <li>Added name reference short form.</li>

          <li>Modified syntax for sequences.</li>

          <li>Switched to <code>info:lexis</code> lexical namespaces.</li>

          <li>Changed property type for array indexes.</li>

          <li>Clarified number types.</li>

          <li>Added delimiters to boolean and number types.</li>

          <li>Added the ID namespace.</li>

          <li>Clarified array grammar.</li>

          <li>Added URF abstract model grammar.</li>

          <li>Added JSON example.</li>
        </ul></dd>

      <dt>2007-09-08</dt>

      <dd><ul>
          <li>Modified and simplified syntax for resource URI references and
          type declarations.</li>

          <li>Changed <dfn>contextual properties</dfn> to <dfn>scoped
          properties</dfn>.</li>
        </ul></dd>

      <dt>2007-09-02</dt>

      <dd><ul>
          <li>First public release of URF.</li>
        </ul></dd>
    </dl>
  </body>
</html>