<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
	<meta charset="UTF-8" />
	<meta name="author" content="Garret Wilson" />
	<title>URF Specification Draft</title>
	<link type="text/css" rel="stylesheet" href="../../pub/css/globalmentor-doc.css" />
</head>

<body>
	<h1>Uniform Resource Framework (URF) Specification</h1>
	<p>Copyright © 2007-2009 <a href="http://www.globalmentor.com/">GlobalMentor, Inc.</a> This specification may be freely used but only in unmodifed form.</p>
	<dl>
		<dt>Author</dt>
		<dd><a href="http://www.garretwilson.com/">Garret Wilson</a></dd>
		<dt>Version</dt>
		<dd>2009-09-06</dd>
	</dl>
	<p>The Uniform Resource Framework (URF) provides a consistent way for representing resources and their relationships. URF and its interchange formats are useful for data storage, data interchange, data querying, and logical inferences. URF together with its interchange formats provides a more powerful yet in many ways simpler and more consistent replacement for data-oriented XML, RDF, and JSON.</p>
	<p>This document defines the Uniform Resource Framework (URF) as an abstract model, and also defines a text-based representation format, Text URF (TURF). This document does not yet provide a description of the binary representation format Serial URF (SURF), or the XML-based format XML URF (XMURF).</p>
	<h2>Conventions</h2>
	<p>When this document refers to "URF", it indicates a model for representing a community of knowledge abstract from any representation format. When this document refers to "TURF", it indicates the textual representation of URF. Because abstract concepts must be textualized to be communicated in a text-based specification, at times a description of the URF abstract model will use TURF notation for clarification of the model.</p>
	<h2>Ontologies</h2>
	<p>The following are official URF ontologies sanctioned by this specification, with links to their formal definitions in TURF:</p>
	<dl>
		<dt><a href="urf.turf">URF</a></dt>
		<dd>The core URF ontology for defining resources.</dd>
		<dt><a href="content.turf">Content</a></dt>
		<dd>The URF ontology for describing the content of a resource, such as content type, size, and actual content bytes.</dd>
		<dt><a href="select.turf">Select</a></dt>
		<dd>The URF ontology for selecting resources and other objects.</dd>
		<dt><a href="vcard.turf">VCard</a></dt>
		<dd>The URF ontology for describing person resource or white-pages type of directory information as described in [<a href="#rfc2426">RFC 2426</a>].</dd>
	</dl>
	<h2>Primer</h2>
	<h3>Resources</h3>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>Everything that can be described by URF is referred to as a <dfn>resource</dfn>. Every resource is an instance of the class <code>urf.Resource</code>. A group of described resources is referred to as an <dfn>URF instance</dfn>.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>A resource can be described within a colon-semicolon pair. Multiple resources are separated by commas and/or newlines. The following example refers to an anonymous resource:</p>
			<figure>
				<pre><code class="language-turf">:;</code></pre>
			</figure>
			<p>A resource can optionally be given a label which can be used as a short representation to refer the resource only within the interchange document. A resource label is a <a href="#name">name</a> placed in front of a resource description and surrounded by vertical bars, as in the following example:</p>
			<figure>
				<pre><code class="language-turf">|label|:;</code></pre>
			</figure>
		</dd>
	</dl>
	<h3>Resource Identification</h3>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>A resource may be <dfn>anonymous</dfn> or may be identified by a URI.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>A URI is indicated by angle brackets. The following example indicates the URI represented by the characters <code>http://example.com/example/resource</code>:</p>
			<figure>
				<pre><code class="language-turf">&lt;http://example.com/example/resource&gt;</code></pre>
			</figure>
			<p>A resource may be identified by placing its URI characters within angle quotes; when the resource URI is given, the the colon and semicolon are optional if the resource has no properties. All URIs may be relative references, which are resolved to the base URI of the interchange document. The following example refers to the resource identified by the URI <code>&lt;http://urf.name/urf/resource&gt;</code>.</p>
			<figure>
				<pre><code class="language-turf">«http://example.com/example/resource»</code></pre>
			</figure>
			<p>A resource identified by URI may also be given a label and/or description:</p>
			<figure>
				<pre><code class="language-turf">|label|«http://example.com/example/resource»:;</code></pre>
			</figure>
			<p>There can be no newline characters between each of these elements, although there may be newlines <em>inside</em> individual elements if appropriate:</p>
			<figure>
				<pre><code class="language-turf">|label|«http://example.com/example/resource»:;</code></pre>
			</figure>
		</dd>
	</dl>
	<h3>Ontologies and Namespaces</h3>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>A set of resources related to the same domain may be grouped together into an <dfn>ontology</dfn>. If all resources within an ontology to have similar URIs, each constructed relative to the ontology URI, the URI of the ontology is said to be a <dfn>namespace URI</dfn>, and each resource is said to have a <dfn>local name</dfn> which is combined with the namespace to create the resource URI. Not all resource URIs are part of some namespace.</p>
			<p>URF only allows namespace URIs that are collection URIs, ending in a slash character <code>'/'</code>. the URI is formed by URI-encoding all non-<var>pchar</var> characters of the local name according to [<a href="#rfc3986">RFC 3986</a>] and appending the result to the namespace URI. For example, a namespace URI of <code>&lt;http://purl.org/dc/elements/1.1/&gt;</code> and a local name of <code>"title"</code> yield a resource URI of <code>&lt;http://purl.org/dc/elements/1.1/title&gt;</code>. These rules allow the namespace and local name to be unambiguously determined given any URI within a namespace.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>A resource within a namespace can be identified by a <dfn>name reference</dfn> by listing the unencoded local name of the resource, with an optional prefix separated by full stop or period. The prefix, if present, is a string that has been associated with some namespace URI using a tilde character <code>'~'</code> in the TURF preamble, which is surrounded by colon <code>':'</code> and semicolon <code>';'</code> characters. If a property name reference has no prefix, the namespace is the URF default namespace, <code>&lt;http://urf.name/default/&gt;</code>.</p>
			<p>In the following example, the name reference <code>component.Button</code> is equivalent to the URI reference <code>«java:/com/guiseframework/component/Button»</code>, and the name reference of its sole property, <code>label</code>, is equivalent to the URI reference <code>«http://urf.name/default/label»</code>. Another resource is also described that uses name references with prefixes for its URI, type, and property.</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "component"~&lt;java:/com/guiseframework/component/&gt;
  "example"~&lt;http://example.com/example/&gt;
  "foaf"~&lt;http://xmlns.com/foaf/0.1/&gt;
;¤
  *component.Button:
    label="Convert"
  ;
  example.janedoe*foaf.Person:
    example.name="Jane Doe"
  ;
.</code></pre>
			</figure>
			Namespace declarations within a TURF document are purely syntactical, and their assigned namespace prefixes make no separate appearance in the resulting URF instance.</dd>
	</dl>
	<p>This specification uses resources in the following namespaces, with corresponding prefixes:</p>
	<dl>
		<dt><code>"dc"~&lt;http://purl.org/dc/elements/1.1/&gt;</code></dt>
		<dd>The Dublin Core Metadata Initiative namespace [<a href="#dcmiNamespace">DCMI Namespace</a>].</dd>
		<dt><code>"example"~&lt;http://example.com/example/&gt;</code></dt>
		<dd>An example namespace; used for hypothetical situations.</dd>
		<dt><code>"urf"~&lt;http://urf.name/urf/&gt;</code></dt>
		<dd>The URF namespace for resource and properties related to the framework abstract model itself.</dd>
	</dl>
	<p>The default namespace URI <code>&lt;http://urf.name/default/&gt;</code> is associated with no prefix (that is, the absense of a prefix).</p>
	<h3>Properties</h3>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>A resource may be related to another resource by the use of a <dfn>property</dfn>. Every property is itself a resource, although it is not implicitly an instance of the class <code>urf.Property</code> unless declared to be so. A resource <dfn>subject</dfn>, a property <dfn>predicate</dfn>, and the related resource <dfn>object</dfn> together make an <dfn>assertion</dfn> about the universe being described.</p>
			<p>An infinite number of assertions may be made about a single subject resource. Repeated assertions about a subject resource with the same same predicate property and the same object resource are considered identical.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>Assertions about a particular subject resource are presented within a colon-semicolon pair and separated by commas and/or newlines. Each predicate property and object resource pair of an assertion are separated by an equals character. Object resources, like resources in other contexts, can serve as the subject of other property assertions. In the following example, the resource <code>«http://example.com/example/resource»</code> has a single property <code>«http://example.com/example/property»</code>, which has as its value another resource, <code>«http://example.com/example/value»</code>:</p>
			<figure>
				<pre><code class="language-turf">`URF¤
  «http://example.com/example/resource»:
    «http://example.com/example/property»=«http://example.com/example/value»
  ;
.</code></pre>
			</figure>
			<p>By associating the namespace <code>&lt;http://example.com/example/&gt;</code> with the prefix string <code>"example"</code>, the above example could be represented in the following representation:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.resource:
    example.property=example.value
  ;
.</code></pre>
			</figure>
		</dd>
	</dl>
	<h3>Classes</h3>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>A resource may represent a <dfn>class</dfn> or set of resources containing instances of other resources. As stated earlier, for example, all resources are implicitly instances of the class <code>urf.Resource</code>. Any resource may be explicitly asserted to be an instance of some class by identifying the class resource as a value of the <code>urf.type</code> property. A resource that is an instance of the class <code>urf.Class</code> may indicate that it is a subclass of some other class by indicating that class resource as the value of the <code>urf.subClassOf</code> property. A resource that is an instance of the class <code>urf.Class</code> may indicate that it is an implementation of some interface by indicating that interface resource as the value of the <code>urf.implementationOf</code> property.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>It can be asserted that a resource is an instance of a class and a subclass of some other class by normal representation of the <code>urf.type</code> and urf.subClassOf property. In the following example, the resource <code>example.resource</code> is asserted to be an instance of the class <code>example.MyClass</code>:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.resource:
    urf.type=example.MyClass
    example.property=example.value
  ;
.</code></pre>
			</figure>
			<p>As a shorthand representation, that a resource is an instance of one or more classes may be represented by placing a reference to the class resources after the resource reference, each preceded by an asterisk (<code>'*'</code>). The following example is semantically identical to the preceding example.</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.resource*example.MyClass:
    example.property=example.value
  ;
.</code></pre>
			</figure>
			<p>There also exists a shorthand representation for the <code>urf.subClassOf</code> and <code>urf.implementationOf</code> properties, using the circumflex accent <code>'^'</code> and the greater than symbol <code>'&gt;'</code>, respectivly. The following example indicates that <code>example.MyClass</code> is a class that is a subclass of <code>example.SuperClass</code> and an implementation of the interface <code>example.MyInterface</code>:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.MyClass*urf.Class^example.MySuperClass&gt;example.MyInterface
.</code></pre>
			</figure>
		</dd>
	</dl>
	<h3>URF Types</h3>
	<p>URF and its standard ontologies comes with several built-in types, including:</p>
	<dl>
		<dt><code>urf.Binary</code></dt>
		<dd>Binary resources represent arbitrarily long sequences of bytes. Binary resources use the appropriate inline namespace for their type, with a lexical form of the <dfn>base64url</dfn> encoding of the binary data without line breaks according to [<a href="#rfc4648">RFC 4648</a>].</dd>
		<dt><code>urf.Boolean</code></dt>
		<dd>There are two boolean resources, the values <code>true</code> and <code>false</code>. Boolean resources are identified by URIs in the Boolean inline namespace with lexical representations of <code>"true"</code> and <code>"false"</code>, respectively.</dd>
		<dt><code>urf.Character</code></dt>
		<dd>Character resources are the Unicode code points, and their lexical forms are the Unicode characters represented by those code points.</dd>
		<dt><code>urf.Class</code></dt>
		<dd>Not every resource used as a class is an instance of the class <code>urf.Class</code>, but a resource may be declared to be of the class type to further specify its semantics. The class <code>urf.Class</code> is a subclass of the class <code>urf.Resource</code>.</dd>
		<dt><code>urf.Date</code></dt>
		<dd>Date resources represent calendar dates in terms of calendar year, calendar month, and calendar day of month. They use an inline namespace with a lexical form consistent with [<a href="#rfc3339">RFC 3339</a>] of <code><var>YYYY</var>-<var>MM</var>-<var>DD</var></code> as defined in [<a href="#iso8601">ISO 8601</a>].</dd>
		<dt><code>urf.DateTime</code></dt>
		<dd>A date time resource represents a time of day on a particular calendar date. They use an inline namespace with a lexical form combining the lexical forms of <code>urf.Date</code> and <code>urf.Time</code> separated by <code>T</code>: <code><var>YYYY</var>-<var>MM</var>-<var>DD</var>T<var>hh:</var><var>mm</var>:ss<strong>[</strong>.s<strong>+</strong><strong>]</strong><strong>[</strong><strong>(</strong>+<strong>|</strong>-<strong>)</strong><var>hh</var>:<var>mm</var><strong>]</strong></code> with optional UTC offset as defined in [<a href="#iso8601">ISO 8601</a>]. A form without the optional UTC offset is said to be <dfn>floating</dfn> as defined in [<a href="#rfc2445">RFC 2445</a>], and should not be used unless a time independent of a time zone is to be specified. In most cases a <dfn>fixed time</dfn> is appropriate and a form with the UTC offset should be used. The hours component represents midnight as <code>00</code> and must not have a value larger than <code>23</code>. The UTC offset <code>-00:00</code> is not allowed; <code>+00:00</code> must be used instead.</dd>
		<dt><code>urf.Duration</code></dt>
		<dd>Duration resources represent lengths of time. They use an inline namespace with a lexical form consistent with [<a href="#rfc2445">RFC 2445</a>] and [<a href="#iso8601">ISO 8601</a>] of <code>P<strong>[</strong><var>n</var>Y<var>n</var>M<var>n</var>D<strong>]</strong><strong>[</strong>T<var>n</var>H<var>n</var>M<var>n</var><strong>[</strong>.<var>n</var><strong>]</strong>S<strong>]</strong></code>, where <var>n</var> is some positive number of roman digits and at least the date or time section is present.</dd>
		<dt><code>urf.Enum</code></dt>
		<dd>The base class of class resources having inline URIs the lexical forms of which are enumerated as class list elements.</dd>
		<dt><code>urf.Integer</code></dt>
		<dd>Integer resources are the positive whole numbers, the negative whole numbers, and zero. They are identified by inline namespace URIs with a lexical representation in the form <code><strong>[</strong>-<strong>]</strong><var>romandigit</var><strong>+</strong></code>. The integer class is a subclass of the class <code>urf.Number</code>.</dd>
		<dt><code>urf.Language</code></dt>
		<dd>Language resources represent human langages and use inline namespace URIs. The lexical form of each is the corresponding <dfn>language tag</dfn> described in [<a href="#rfc4646">RFC 4646</a>].</dd>
		<dt><code>urf.List</code></dt>
		<dd>List resources are resources that contain other <dfn>element</dfn> resources at certain <dfn>indexes</dfn> of the list. A list, like normal resources, may have any property, but the properties representing the elements of the list lie in the ordinal namespace <code>&lt;http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Ordinal/&gt;</code>, each representing the ordinal index of the element. That is, if a list contains an element at index 5, the element resource will appear as a value of the property <code>«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Ordinal/%225%22»</code> (that is, the property <code>«(urf.Ordinal)"5"»</code>, or simply <code>º5</code>). Although many uses cases will prefer a continuous, unduplicated sequence of index properties beginning with <code>º5</code>, this is not an URF requirement.</dd>
		<dt><code>urf.Map</code></dt>
		<dd>A resource containing associations between keys and values. Each association is represented by an instance of <code>urf.MapEntry</code>, which indicates a value for the property <code>urf.key</code> and the property <code>urf.value</code>. Each map entry is the value of an <code>urf.entry</code> property of the map resource.</dd>
		<dt><code>urf.Ordinal</code></dt>
		<dd>Ordinal resources are numbers that represent the position of an element in a sequence. URF currently only supports finite ordinals, which means that there will be a corresponding ordinal for every positive whole numbers and zero. Ordinals are identified by inline namespace URIs with a lexical representation in the form <code><var>romandigit</var><strong>+</strong></code>. The ordinal class is a subclass of the class <code>urf.</code>Number.</dd>
		<dt><code>urf.Property</code></dt>
		<dd>Not every resource used as a predicate is an instance of the class <code>urf.Property</code>, but a resource may be declared to be of the property type to further specify its semantics and expected domain and range. The class <code>urf.Property</code> is a subclass of the class <code>urf.Class</code>.</dd>
		<dt><code>urf.Rational</code></dt>
		<dd>Rational number are all of the measuring numbers and may include decimal fractional parts. They are identified by inline namespace URIs with a lexical representation in the form <strong>[</strong>-<strong>]</strong><var>romandigit</var><strong>+</strong>.<var>romandigit</var><strong>+[</strong>e<strong>[</strong>+<strong>|</strong>-<strong>]</strong><var>romandigit</var><strong>+]</strong>. The integer class is a subclass of the class <code>urf.Number</code>.</dd>
		<dt><code>urf.RegularExpression</code></dt>
		<dd>Regular expression resources are text-based patterns that define rules for the content of strings. These are inline namespace resources.</dd>
		<dt><code>urf.Resource</code></dt>
		<dd>Every resource is implicitly an instance of the class <code>urf.Resource</code>. The resources <code>urf.Property</code> and <code>urf.Resource</code> are both instances of the class <code>urf.Resource</code>.</dd>
		<dt><code>urf.Set</code></dt>
		<dd>Set resources are resources that contain at most one instance of other <dfn>element</dfn> resources. A set, like normal resources, may have any property, but the properties representing the elements of the set appear as values of the <code>urf.element</code> property.</dd>
		<dt><code>urf.String</code></dt>
		<dd>String resources are sequences of Unicode code points or text and lie in the corresponding inline namespace.</dd>
		<dt><code>urf.Time</code></dt>
		<dd>Time resources represent time of day. They use a inline namespace with a lexical form consistent with [<a href="#rfc3339">RFC 3339</a>] of <code><var>hh:</var><var>mm</var>:ss<strong>[</strong>.s<strong>+</strong><strong>]</strong><strong>[</strong><strong>(</strong>+<strong>|</strong>-<strong>)</strong><var>hh</var>:<var>mm</var><strong>]</strong></code> with optional UTC offset as defined in [<a href="#iso8601">ISO 8601</a>]. A form without the optional UTC offset is said to be <dfn>floating</dfn> as defined in [<a href="#rfc2445">RFC 2445</a>], and should not be used unless a time independent of a time zone is to be specified. In most cases a <dfn>fixed time</dfn> is appropriate and a form with the UTC offset should be used. The hours component represents midnight as <code>00</code> and must not have a value larger than <code>23</code>. The UTC offset <code>-00:00</code> is not allowed; <code>+00:00</code> must be used instead.</dd>
		<dt><code>urf.URI</code></dt>
		<dd>URI resources are sequences of Unicode code points that function as resource identifiers and conform to [<a href="#rfc3986">RFC 3986</a>]. They lie in the corresponding inline namespace with a lexical form specified by [<a href="#rfc3986">RFC 3986</a>].</dd>
		<dt><code>urf.UTCOffset</code></dt>
		<dd>UTC offset resources represent an offset from UTC to local time. They use an inline namespace with a lexical form of <strong>(</strong>+<strong>|</strong>-<strong>)</strong><var>hh</var>:<var>mm</var> with semantics corresponding to the UTC offset described in [<a href="#rfc2426">RFC 2426</a>] and [<a href="#rfc2445">RFC 2445</a>]. The UTC offset <code>-00:00</code> is not allowed; <code>+00:00</code> must be used instead.</dd>
		<dt><code>content.Charset</code></dt>
		<dd>The name of the mapping of integer values to a set of characters. This is equivalent to the <dfn>charset</dfn> Internet media type parameter described by [<a href="#rfc2046">RFC 2046</a>] and further elaborated in [<a href="#rfc2278">RFC 2278</a>] Section 2.3. A charset encapsulates both the concept of a <dfn>coded character set</dfn> and a <dfn>character encoding scheme</dfn>, as specified in [<a href="#rfc2130">RFC 2130</a>] Section 3.2. The lexical form is the canonical charset name specified by [<a href="#ianaCharsetRegistry">IANA Charset Registry</a>], such as <code>UTF-16BE</code>.</dd>
		<dt><code>content.MediaType</code></dt>
		<dd>A media type resource is an Internet media types described by [<a href="#rfc2046">RFC 2046</a>]. Internet media types are also known as <dfn>MIME types</dfn> and <dfn>content types</dfn>. Media type resources use inline namespace URIs, and each has a lexical form corresponding to its [<a href="#rfc2046">RFC 2046</a>] representation without any media type parameters.</dd>
	</dl>
	<h3>Selectors</h3>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>A resource may have a <dfn>selector</dfn> that indicates how a specific instance of a class is to be selected. A selector for an instance of a particular class is represented by the <code>urf.List</code> value of a scoped <code>urf.selector</code> property in the scope of the resource's <code>urf.type</code> property for the class instance being selected.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>A selector for a particular type may be represented in short form by one or more comma-separated resources withing parenthesis after the type short form. The following example selects an instance of the type <code>example.Point</code> using the selector <code>[#5#, #8#]</code>, assumedly indicating five units along the X axis and eight units along the Y axis.</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "example"~&lt;http://example.com/example/&gt;
;¤
  *example.Point(#5#, #8#)
.</code></pre>
			</figure>
			<p>The following example is semantically equivalent to the short form above:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "example"~&lt;http://example.com/example/&gt;
;¤
  :
    urf.type=example.Point:
      urf.selector`=[#5#, #8#]
    ;
  ;
.</code></pre>
			</figure>
		</dd>
	</dl>
	<h3>Inline Resource URIs</h3>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>Some resource types are singletons that are unambiguously identified by their selectors. These resources are identified by <dfn>inline</dfn> URIs that contain both the resource type and the identifying selector within the URI itself. The most common type of resource that use inline URIs are those that in day-to-day life have customarily been identified by character sequences or <dfn><dfn>lexical representations</dfn></dfn>. For example, the integer <code>123</code> has historically been represented by the character sequence <code>"123"</code>, although the number itself is an abstract concept, not a series of characters. Similarly, the two boolean values are usually represented as the character sequences <code>"true"</code> and <code>"false"</code>.</p>
			<p>Each inline namespace URI begins with the base URF inline namespace URI <code>&lt;http://urf.name/inline/&gt;</code> and has the following format,</p>
			<figure>
				<pre><code class="language-turf">http://urf.name/inline/<var>encodedTypeURI</var>/<var>encodedTURFLexicalForm</var></code></pre>
			</figure>
			<p>where <var>encodedTypeURI</var> is the URI path segment-encoded form of the full type URI of the resource; and <var>encodedTURFLexicalForm</var> is the URI path segment-encoded canonical lexical form of the resource as defined by the indicated type, in its TURF short string form. For example, the integer 123, which is of the type <code>«http://urf.name/urf/Integer»</code>, has a lexical form of <code>"123"</code>. This TURF string representation, encoded for a URI, yields <code>%22123%22</code>, which results in  the following inline URI:</p>
			<figure>
				<pre><code class="language-turf">http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Integer/%22123%22</code></pre>
			</figure>
			<p>A resource in an inline namespace is implicitly an instance of the type indicated in the <var>encodedTypeURI</var> section of the URI. In all other aspects resources in inline namespaces are no different from resources not in an inline namespace; these resources are <em>not</em> instances of a special resource type solely because their namespaces are inline namespaces. Inline namespaces provide a framework for easily and consistently formulating identifying URIs for resources that are traditionally identified in lexical form; inline namespaces in themselves imply no additional semantics.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>Any representation of a resource in an inline namespace also implicitly asserts the type of the resource. A resource in an inline namespace can be identified by its URI as with any other resource. For example, the integer 123 can be identified by its URI <code>&lt;http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Integer/%22123%22&gt;</code> as in the following example:</p>
			<figure>
				<pre><code class="language-turf">«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Integer/%22123%22»</code></pre>
			</figure>
			<p>Rather than indicating directly the URI of a resource in an inline namespace, the resource may be identified by indicating the type of the resource preceded by an asterisk inside the URI reference, followed by the canonical lexical form of the resource as a string inside parentheses. In essence, a type an selector is being used to generate a corresponding URI. The integer 123 may therefore be represented as either of the following short forms:</p>
			<figure>
				<pre><code class="language-turf">«*«http://urf.name/urf/Integer»("123")»</code></pre>
				<pre><code class="language-turf">«*urf.Integer("123")»</code></pre>
			</figure>
			<p>The inline namespaces for several types have additional short representations. The examples below assume that the label <code>urf</code> has been assigned to the URF namespace.</p>
			<dl>
				<dt><code>urf.Binary</code></dt>
				<dd>
					<p>An binary resource may be identified by its [<a href="#rfc4648">RFC 4648</a>] base64url lexical form surrounded by percent signs. For example, the series of bytes <code>64</code>, <code>63</code>, <code>62</code>, <code>61</code> produce the lexical form, <code>"QD8-PQ=="</code>; the corresponding short representation,</p>
					<figure>
						<pre><code class="language-turf">%QD8-PQ==%</code></pre>
					</figure>
					<p>is equivalent to the following long representation,</p>
					<figure>
						<pre><code class="language-turf">«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Binary/%22QD8-PQ%3D%3D%22»</code></pre>
					</figure>
					<p>which is also equivalent to the following general short representation for resources in an inline namespace:</p>
					<figure>
						<pre><code class="language-turf">«*urf.Binary("QD8-PQ==")»</code></pre>
					</figure>
				</dd>
				<dt><code>urf.Boolean</code></dt>
				<dd>
					<p>An boolean resource may be identified by its lexical form surrounded by matching underscore characters (<code>'_'</code>). For example, the following short representation,</p>
					<figure>
						<pre><code class="language-turf">_true_</code></pre>
					</figure>
					<p>is equivalent to the following long representation,</p>
					<figure>
						<pre><code class="language-turf">«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Boolean/%22true%22»</code></pre>
					</figure>
					<p>which is also equivalent to the following general short representation for resources in an inline namespace:</p>
					<figure>
						<pre><code class="language-turf">«*urf.Boolean("true")»</code></pre>
					</figure>
				</dd>
				<dt><code>urf.Character</code></dt>
				<dd>
					<p>A character resource may be identified by its <a href="#charactershort">character-escaped lexical form</a> with surrounding single quotes. For example, the following short representation,</p>
					<figure>
						<pre><code class="language-turf">'x'</code></pre>
					</figure>
					<p>is equivalent to the following long representation,</p>
					<figure>
						<pre><code class="language-turf">«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Character/%22x%22»</code></pre>
					</figure>
					<p>which is also equivalent to the following general short representation for resources in an inline namespace:</p>
					<figure>
						<pre><code class="language-turf">«*urf.Character("x")»</code></pre>
					</figure>
				</dd>
				<dt><code>urf.Number</code></dt>
				<dd>
					<p>Integer and rational number resources may be identified by their lexical forms surrounded by matching number signs (<code>'#'</code>). The specific type of number resource yielded depends on the lexical form used. For example, the following short representations,</p>
					<figure>
						<pre><code class="language-turf">#123#
#123.45#</code></pre>
					</figure>
					<p>are equivalent to the following long representations, respectively,</p>
					<figure>
						<pre><code class="language-turf">«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Integer/%22123%22»
«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Rational/%22123.45%22»</code></pre>
					</figure>
					<p>which are also equivalent to the following general short representations for resources in an inline namespace, respectively:</p>
					<figure>
						<pre><code class="language-turf">«*urf.Integer("123")»
«*urf.Rational("123.45")»</code></pre>
					</figure>
				</dd>
				<dt><code>urf.Ordinal</code></dt>
				<dd>
					<p>Ordinal number resources may be identified by their lexical forms surrounded by matching ordinal characters <code>'º'</code>. For example, the following short representation,</p>
					<figure>
						<pre><code class="language-turf">º5º</code></pre>
					</figure>
					<p>is equivalent to the following long representation,</p>
					<figure>
						<pre><code class="language-turf">«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Ordinal/%225%22»</code></pre>
					</figure>
					<p>which are also equivalent to the following general short representation for resources in an inline namespace:</p>
					<figure>
						<pre><code class="language-turf">«*urf.Ordinal("5")»</code></pre>
					</figure>
				</dd>
				<dt><code>urf.RegularExpression</code></dt>
				<dd>
					<p>A regular expression resource may be identified by its <a href="#regexshort">regular expression-escaped lexical form</a> surrounded by slashes (<code>'/'</code>). For example, the following short representation,</p>
					<figure>
						<pre><code class="language-turf">/a?b+c*/</code></pre>
					</figure>
					<p>is equivalent to the following long representation,</p>
					<figure>
						<pre><code class="language-turf">«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23RegularExpression/%22a%3Fb%2Bc%2a%22»</code></pre>
					</figure>
					<p>which is also equivalent to the general short representation for resources in an inline namespace:</p>
					<figure>
						<pre><code class="language-turf">«*urf.RegularExpression("a?b+c*")»</code></pre>
					</figure>
				</dd>
				<dt><code>urf.String</code></dt>
				<dd>
					<p>A string resource may be identified by its <a href="#stringshort">string-escaped lexical form</a> with surrounding quotes. For example, the following short representation,</p>
					<figure>
						<pre><code class="language-turf">"apple"</code></pre>
					</figure>
					<p>is equivalent to the following long representation,</p>
					<figure>
						<pre><code class="language-turf">«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23String/%22apple%22»</code></pre>
					</figure>
					<p>which is also equivalent to the general short representation for resources in an inline namespace:</p>
					<figure>
						<pre><code class="language-turf">«*urf.String("apple")»</code></pre>
					</figure>
				</dd>
				<dt><code>urf.Temporal</code></dt>
				<dd>
					<p>A temporal resource such as <code>urf.Date</code>, <code>urf.DateTime</code>, <code>urf.Duration</code>, <code>urf.Time</code>, or <code>urf.UTCOffset</code> may be identified by its lexical form surrounded by matching at signs (<code>'@'</code>). The specific temporal type can be determined by the specific lexical form used. For example, the following short representations for <code>urf.Date</code>, <code>urf.Time</code>, <code>urf.DateTime</code>, <code>urf.Duration</code>, and <code>urf.UTFOffset</code>,</p>
					<figure>
						<pre><code class="language-turf">@1980-05-06@
@16:39:57-08:00@
@1980-05-06T16:39:57-08:00@
@P100Y5M3DT8H2M10.5S@
@-08:00@</code></pre>
					</figure>
					<p>are equivalent to the following long representations, respectively,</p>
					<figure>
						<pre><code class="language-turf">«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Date/%221980-05-06%22»
«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Time/%2216%3A39%3A57-08%3A00%22»
«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23DateTime/%221980-05-06T16%3A39%3A57-08%3A00%22»
«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Duration/%22P100Y5M3DT8H2M10.5S%22»
«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23UTCOffset/%22-08:00%22»</code></pre>
					</figure>
					<p>which are also equivalent to the general short representations for resources in an inline namespace:</p>
					<figure>
						<pre><code class="language-turf">«*urf.Date("1980-05-06")»
«*urf.Time("16:39:57-08:00")»
«*urf.DateTime("1980-05-06T16:39:57-08:00")»
«*urf.Duration("P100Y5M3DT8H2M10.5S")»
«*urf.UTCOffset("-08:00")»</code></pre>
					</figure>
				</dd>
				<dt><code>urf.URI</code></dt>
				<dd>
					<p>A URI resource may be identified by its lexical form with surrounding angle brackets <code>'&lt;'</code> and <code>'&gt;'</code>. For example, the following short representation,</p>
					<figure>
						<pre><code class="language-turf">&lt;http://urf.name/urf/type&gt;</code></pre>
					</figure>
					<p>is equivalent to the following long representation,</p>
					<figure>
						<pre><code class="language-turf">«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23URI/http%3A%2F%2Furf.name%2Furf%23type»</code></pre>
					</figure>
					<p>which is also equivalent to the general short representation for resources in an inline namespace:</p>
					<figure>
						<pre><code class="language-turf">«*urf.URI("http://urf.name/urf/type")»</code></pre>
					</figure>
				</dd>
			</dl>
		</dd>
	</dl>
	<h3>Enums</h3>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>URF provides a special class, <code>urf.Enum</code>, for declaring subclasses that have values from a finite set of lexical forms. The URI of each instance of the enum subclass is a normal inline URI, made up of the enum type (the <code>urf.Enum</code> subclass) and the lexical form of the enum value. <code>urf.Enum</code> is in turn a subclass of <code>urf.Set</code>, and the lexical form values of the enum type are specified as set elements of the <code>urf.Enum</code> subclass. For example, the URF class <code>urf.Boolean</code> is a subclass of <code>urf.Enum</code>, and its lexical form values are <code>"false"</code> and <code>"true"</code>. The URI of each <code>urf.Boolean</code> instance is formed following normal URF inline URI rules, resulting in <code>«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Boolean/%22false%22»</code> and <code>«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Boolean/%22true%22»</code>.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>The following is the definition of the <code>urf.Boolean</code> class, which is a typical enum subclass:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
;¤
  urf.Boolean*urf.Class^urf.Enum{
    "false",
    "true"
  }
.</code></pre>
			</figure>
		</dd>
	</dl>
	<h3>Reification</h3>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>Propositions may be described without actually asserting those propositions. The sentence, "John believes that the sky is purple," for example, does not assert that the skye is purple, but merely that John believes this to be the case. The proposition "the sky is purple" may be described like any other resource, using the URF class <code>urf.Proposition</code> and the URF properties <code>urf.subject</code>, <code>urf.predicate</code>, and <code>urf.object</code>.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>The following example asserts that John believes the sky to have the color purple without asserting that the sky actually has that color:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.john:
    example.believes=*urf.Proposition:
      urf.subject=example.sky
      urf.predicate=example.color
      urf.object=example.purple
    ;
  ;
.</code></pre>
			</figure>
			<p>Propositions may be presented in a short form consisting of the subject, predicate, and object enclosed in open double quotation mark <code>'“'</code> and closed double quotation mark <code>'”'</code> characters. The following example is semantically equivalent to the previous one:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;,
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.john:
    example.believes=“example.sky, example.color, example.purple”
  ;
.</code></pre>
			</figure>
			<p>Any proposition that is asserted can be reified by placing a label before the equals sign in a property definition. The label will then identify a proposition that is the reification of the property assertion, and that labeled resource can then be used in any situation in which a resource is expected. The following example first asserts that the sky is purple, using the label <code>skyColorPurple</code> to represent the reified proposition, <code>“example.sky, example.color, example.purple”</code>. Then it is asserted that John believes this proposition; the second assertion is therefore semantically identical to the one in the previous example.</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.sky:
    example:color|skyColorPurple|=example:purple
  ;
  example.john:
    example.believes=|skyColorPurple|
  ;
.</code></pre>
			</figure>
		</dd>
	</dl>
	<h3>Proposition Scope</h3>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>Some assertions are only valid within a certain scope; they are asserted in a separate URF instance related to the context of some other subject and property. For example, if Juan has an English name of <code>"John"</code>, Juan could specify a <code>example.name</code> of <code>"John"</code> with an <code>example.lang</code> of <code>example.english</code>. Because the string <code>"John"</code> may not represent an English string in all contexts, its property <code>example.lang</code> should be considered to be in the scope of the relationship between Juan and the <code>example.name</code> <code>"John"</code>. The assertion, "the string 'John' is in English", is contextual to the string "John" being the name of Juan.</p>
			<p>Similarly, Juan could specify a <code>example.weight</code> of <code>#72#</code> with an <code>example.unit</code> of <code>example.kilogram</code>. Because the integer <code>#72#</code> may not represent a unit of kilograms in all contexts, its property <code>example.unit</code> should be considered to be in the scope of the relationship between Juan and the <code>example.weight</code> <code>#72#</code>. The assertion, "the integer 72 is in kilograms", is contextual to the integer 72 being the weight of Juan.</p>
			<p>Scoped propositions are actually propositions asserted in separate <a href="#communities">knowledge communities</a> created by their context propositions.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>To restrict a particular property assignment to the scope of the subject serving as the value of some other resource's property, the grave accent character <code>'`'</code> is used before the equals sign <code>'='</code> in the property declaration:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.juan:
    example.name="John":
      example.lang`=example.english
    ;
    example.weight=#72#:
      example.unit`=example.kilogram
    ;
  ;
.</code></pre>
			</figure>
		</dd>
	</dl>
	<h3>Ordered Properties</h3>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>Although all resource property assertions of a particular subject have no inherent order, URF provides a facility for declaring property order using scoped properties. Each property that should be considered to have an order relative to other assertions of the same property is given a scoped property <code>urf.order</code> with a value of type <code>urf.Integer</code>, representing the relative order in which the property should be interpreted.</p>
			<p>The interpretation of the property's order is specific to the property in question. Although many uses cases will prefer a continuous, unduplicated sequence of order property values beginning with <code>0</code>, this is not an URF requirement. The result of merging ordered properties is undefined, except that the properties in each group before the merge must still be in the same order relative to each other after the merge.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>Ordered properties may be indicated using the general representation for contextual properties. The following example indicates that a resource has two names, <code>"William"</code> and <code>"Bill"</code>, and that <code>"Will"</code> comes before <code>"Bill"</code>. (What it means that a name "comes before" another name depends on the definition of the name property being used. Perhaps one name comes before the other if used simultaneously, or perhaps one name has a higher priority or is considered the "default" name.)</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.billy:
    example.name="William":
      urf.order`=#0#
    ;
    example.name="Bill":
      urf.order`=#1#
    ;
  ;
.</code></pre>
			</figure>
			The same information may be presented in short representation in the form of a <dfn>sequence</dfn> by placing the ordered values within matching backslash characters. A sequence does not result in a new type of value, but rather indicates that the given predicate should be asserted for each value, each with a scoped property of <code>urf.order</code> with values starting at <code>#0#</code> and continuing sequentially. The following example represents information semantically identical to the previous example:
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.billy:
    example.name=\"William",  "Bill"\
  ;
.</code></pre>
			</figure>
		</dd>
	</dl>
	<h3>Programming Languages</h3>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>URF provides inherent support for describing how to instantiate objects from programming languages such as Java. When an ontology of a semantic framework such as URF is used to represent programming language objects, the ontology is referred to as a Programming Language Ontology for Objects and Properties, or <a href="#ploop">PLOOP</a>. A class can be identified as an object's type using a URI that identifies the type, such as <code>«java:/com/example/package/ExampleClass»</code> for the Java class <code>com.example.package.ExampleClass</code>. The <code>urf.List</code> value of the selector property <code>urf.selector</code> specifies the resources to be used for object initialization using a constructor with parameters matching the given values.</p>
			<p>URF properties specify programming language properties, which may be virtual properties using "getter" and "setter" methods such as with JavaBeans. Programming languages usually have properties relative to each class rather than absolute for all classes. URF uses properties in the default namespace to represent these relative properties. For example, the Java property represented by the JavaBean method <code>com.example.package.ExampleClass.setProperty(java.lang.String)</code> would be represented by an URF property with the URI <code>«http://urf.name/default/property»</code>. Some values may be language-specific; Java, for example, provides a global <code>null</code> value represented in URF by <code>«java:null»</code>.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>The TURF selector shorthand notation specifies constructor arguments for a class instance if a non-default constructor is desired. The class <code>com.guiseframework.Category</code> of the Guise Internet application framework [<a href="#guise">Guise</a>], for example, does not have a default constructor. The following example provides an <code>urf.selector</code> <code>urf.List</code> property containing a single element of type <code>urf.String</code>, which can be converted to a <code>java.lang.String</code> object and used as arguments for the <code>com.guiseframework.Category(java.lang.String, java.lang.String)</code> constructor. Properties of that class will then be set, recursively converting values such as <code>urf.List</code> to the equivalent Java object such as <code>java.util.List</code>.</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "guise"~&lt;java:/com/guiseframework/&gt;
;¤
  *guise.Category("category1", "First Category"):
    categories=[
      *guise.Category("subcategoryA")
      *guise.Category("subcategoryB")
    ]
  ;
.</code></pre>
			</figure>
			<p>This is equivalent to the following TURF long form:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "guise"~&lt;java:/com/guiseframework/&gt;
;¤
  :
    urf.type=guise.Category:
      urf.selector`=["category1", "First Category"]
    ;
    categories=[
      :
        urf.type=guise.Category:
          urf.selector`=["subcategoryA"]
        ;
      ;
      :
        urf.type=guise.Category:
          urf.selector`=["subcategoryB"]
        ;
      ;
    ]
  ;
.</code></pre>
			</figure>
		</dd>
	</dl>
	<h3>Knowledge Communities</h3>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>The class <code>urf.Community</code> represents a body of knowledge accepted within a certain context. The <code>urf.Community</code> class is a subclass of <code>urf.Set</code>; its elements are instances of <code>urf.Proposition</code>. The propositions an <code>urf.Community</code> contains are considered to be asserted within that community.</p>
			<p>The class <code>urf.Proposition</code> is a subclass of <code>urf.Community</code>, which means that each proposition is itself a knowledge community providing a context for asserted propositions. Scoped propositions are propositions that are contained within another instance of <code>urf.Proposition</code>.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>In a TURF interchange document, every root resource and its recursive properties (excluding those within other <code>urf.Community</code> instances), represent propositions asserted in a default knowledge community. For example, the following example asserts that Punxsutawney Phil predicts the weather. ("Punxsutawney Phil" the name given to a marmot in Punxsutawney, Philadelphia, USA. On the American holiday Groundhog Day, whether Punxsutawney Phil sees his shadow is considered to be a prognostication regarding the onset of spring weather.)</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "punx"~&lt;http://example.com/punxsutawney/&gt;
;¤
  punx.Phil:
    punx.predicts=punx.weather
  ;
.</code></pre>
			</figure>
			<p>It may instead be asserted that some other community, possibly identified, asserts a set of propositions. The currency symbol <code>'¤'</code> and full stop <code>'.'</code> characters indicate that the properties and resources between them are reified as propositions and serve as elements of the given <code>urf.Community</code> instance—which in turn is taken to mean that the propositions are asserted by the given knowledge community. (All TURF exchange documents have a common <dfn>instance community</dfn> in which root assertions are made.) For example, rather than directly asserting that Punxsutawney Phil predicts the weather, the following example asserts that <em>the community of Punxsutawney</em> asserts (believes or holds) that Punxsutawney Phil predicts the weather (the <code>urf.Community</code> specification is redundant here, because the community short form implies the <code>urf.Community</code> type):</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "punx"~&lt;http://example.com/punxsutawney/&gt;
;¤
  punx.Punxsutawney*urf.Community¤
    punx.Phil:
      punx.predicts=punx.weather
  .
.</code></pre>
			</figure>
			<p>Semantics identical to those the previous example can be represented in the following longer form, with the propositions (shown here in short form) that are asserted in the community explicitly reified:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "punx"~&lt;http://example.com/punxsutawney/&gt;
;¤
  punx.Punxsutawney*urf.Community{
    “punx.Phil, punx.predicts, punx.weather”
  }
.</code></pre>
			</figure>
			<p>Because scoped properties are really propositions asserted in the knowledge community that is some other proposition, scoped properties may be represented in the same manner as other knowledge community representations. The following is the scoped property example given earlier in its short form:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.juan:
    example.name="John":
      example.lang`=example.english
    ;
    example.weight=#72#:
      example.unit`=example.kilogram
    ;
  ;
.</code></pre>
			</figure>
			<p>Because each <code>urf.Proposition</code> instance is also an instance of <code>urf.Community</code>, reifying the propositions <code>example.name="John"</code> and <code>example.weight</code> provides two separate knowledge communities, in this case asserting the scoped properties. This is illustrated in the following example, which uses labels to indicate the reification of the asserted propositions relating to <code>example.juan</code>:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.juan:
    example.name|juanNameJohn|="John"
    |juanNameJohn|¤
      "John":
        example.lang=example.english
      ;
    .
    example.weight|juanWeight72|=#72#
    |juanWeight72|¤
      #72#:
        example.unit=example.kilogram
      ;
    .
  ;
.</code></pre>
			</figure>
			<p>Referring to labeled assertions represent the reification of those propositions, and property declarations within a community (which itself may be another reified proposition) represent reified propositions asserted within that community. Therefore, the previous example can be represented in a more fully reified form (using proposition short forms):</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.juan:
    example.name="John"
    example.weight=#72#
    “example.juan, example.name, "John"”{
      “"John", example.lang, example.english”
    }
    “example.juan, example.weight, #72#”{
      “#72#, example.unit, example.kilogram”
    }
  ;
.</code></pre>
			</figure>
			<p>Note that <code>example.name="John"</code> and <code>example.weight=#72#</code> are listed separately as assertions of John's name and weight; those two propositions are later explicitly reified as propositions and serve as separate knowledge communities containing other assertions about the name <code>"John"</code> and the weight <code>#72#</code>.</p>
		</dd>
	</dl>
	<h2>URF</h2>
	<p>Everything that is described in URF is referred to as a <dfn>resource</dfn>. For purposes of description within URF, each resource may be identified using a URI [<a href="#rfc3986">RFC 3986</a>]. Resources are described by a set of <dfn>assertions</dfn>, each of which is a proposition, an instance of <code>urf.Proposition</code>. Each proposition contains a <dfn>subject</dfn>, a <dfn>predicate</dfn>, and an <dfn>object</dfn>.</p>
	<p>A particular group of assertions is called an <dfn>URF instance</dfn>. Each asserted proposition exists in some URF <dfn>knowledge community</dfn> as an element of <code>urf.Community</code>. Each <code>urf.Proposition</code> is itself a subclass of <code>urf.Community</code>, and may therefore contain other <dfn>scoped assertions</dfn> that are contextual to the first proposition. The root assertions of an URF instance are part of the <dfn>instance community</dfn> and may be considered to be asserted in the same knowledge community as the instance community of all other URF instances.</p>
	<h2>TURF</h2>
	<p>TURF is the text interchange format for URF. TURF emphasizes terseness and consistency while maintaining human readability, with a preference for using symbols from existing interchange formats such as JSON and programming languages such as Java and C#. TURF has several useful properties, including:</p>
	<ul>
		<li>TURF has a signature character sequence, <code>`URF</code>, for easy recognition.</li>
		<li>TURF has unambiguous beginning and end delimiters, allowing TURF to be embedded in existing text-based content.</li>
		<li>Whitespace separators and comments may be removed with no loss of semantics, resulting in an extremely compact representation.</li>
		<li>Standard delimiters are used, such as <code>{…}</code> for sets, <code>[…]</code> for lists, <code>"…"</code> for strings, <code>&lt;…&gt;</code> for URIs, <code>#…#</code> for numbers, and <code>º…º</code> for ordinals.</li>
	</ul>
	<h3>Internet Media Type</h3>
	<p>The Internet media type [<a href="#rfc2046">RFC 2046</a>] of general URF information encoded as TURF is:</p>
	<figure>
		<p><code>text/urf</code></p>
	</figure>
	<p>TURF differs from general [<a href="draft.xhtml#rfc2046">RFC 2046</a>] text media types in the following:</p>
	<ul>
		<li>The default charset of TURF is UTF-8 rather that US-ASCII.</li>
		<li>TURF allows any Unicode newline character [<a href="draft.xhtml#utr13">UTR #13</a>] to represent newlines rather than only <code>CRLF</code>.</li>
	</ul>
	<p>For any application-specific URF data encoded as TURF should be represented as <code>application/<var>applicationName</var>+turf</code> to allow the data to be recognized as such, where <var>applicationName</var> is the application-specific identifier for the URF information. <em>Note: These Internet media types have yet to be registered with the IANA.</em></p>
	<h3>Encoding</h3>
	<p>TURF may use any encoding in a closed environment in which all relevant parties are aware of the encoding being used. In situations where the encoding may not be readily known to a processor, such as in a general file stored in a file system, TURF must use the UTF-8 character encoding. TURF interchange document files should use a UTF-8 U+FEFF sequence (the so-called UTF-8 Byte Order Mark or BOM) at their beginning to notify general text processing agents that may not be aware of TURF that UTF-8 encoding is being used [<a href="#unicodeBOMFAQ">Unicode BOM FAQ</a>].</p>
	<h3>Signature</h3>
	<p>Every TURF interchange document must begin with the signature character sequence, <code>`URF</code>, which must appear as the first characters of the document after the Byte Order Mark (BOM), if any [<a href="#unicodeBOMFAQ">Unicode BOM FAQ</a>].</p>
	<h3>Grammar</h3>
	<p>The following grammar indicates literals in normal style, variables in emphasized text, and grammar symbols in strong text.</p>
	<p>Any two TURF tokens may be separated by <dfn>filler</dfn>: Unicode separator or Unicode whitespace characters, or a TURF comment, which is a string surrounded by the dagger <code>'†'</code> and double dagger <code>'‡'</code> characters.</p>
	<figure>
		<p><code><var>filler</var> ⇒ Unicode Paragraph Separator <strong>|</strong> Unicode Segment Separator <strong>|</strong> Unicode Whitespace <strong>|</strong> <var>comment</var></code></p>
		<p><code><var>comment</var> ⇒ †"<strong>[</strong><var>Unicode character except double dagger and backslash</var> <strong>|</strong> <var>escapedunicode</var> <strong>|</strong> <var>escapedcontrol</var><strong>]*</strong>‡</code></p>
	</figure>
	<p>Between elements in a list, filler has a caveat: Unicode newline characters [<a href="draft.xhtml#utr13">UTR #13</a>] function as a <dfn>list separator</dfn>, which is at least one newline character and/or at most a single comma character (<code>','</code>), optionally surrounded by other filler characters:</p>
	<figure>
		<p><code><var>listseparator</var> ⇒ Unicode Newline</code><code><strong>+ </strong></code><code><strong>|</strong> ,</code></p>
	</figure>
	<p>A TURF interchange document is encoded in UTF-8 and begins with the TURF signature <code>`URF</code> followed by the description of the instance community, which consists of optional properties and a required community short representation.</p>
	<figure>
		<p><code><var>TURF</var> ⇒ signature <strong>[</strong>:<var>properties</var>;<strong>]</strong> <var>communityshort</var></code></p>
		<p><code><var>signature</var> ⇒ `URF</code></p>
	</figure>
	<p>The community short form, the grammar of which is below, is delimited by the currency character <code>'¤'</code> and the full stop character <code>'.'</code> and contains zero or more resource descriptions, separated by list separators. Each resource description must have at least one of the following optional components, any may have any or all of them: a label, a reference, one or more type short forms, a set of property definitions, a community short form, a proposition form, a list short form, a set short form, and a map short form. <em>No Unicode newline characters are allowed between elements of a resource description.</em></p>
	<figure>
		<p><code><var>resource</var> ⇒ <strong>[</strong><var>label</var><strong>]</strong> <strong>[</strong><var>reference</var><strong>]</strong> <strong>[</strong><var>type</var>s<strong>]</strong> <strong>[</strong><var>superclasses</var><strong>]</strong> <strong>[</strong><var>interfaces</var><strong>]</strong> <strong>[</strong><var>properties</var><strong>]</strong> <strong>[</strong><var>communityshort</var><strong>]</strong> <strong>[</strong><var>propositionshort</var><strong>]</strong> <strong>[</strong><var>listshort</var><strong>]</strong> <strong>[</strong><var>setshort</var><strong>]</strong> <strong>[</strong>mapshort<strong>]</strong></code></p>
	</figure>
	<p>A label consists of a name surrounded by matching vertical bars (<code>'|'</code>).</p>
	<figure>
		<p><code><var>label</var> ⇒ |<var>name</var>|</code></p>
	</figure>
	<p>A name is any letter followed by any number of letters, digits, or connectors such as the underscore character <code>'_'</code>.</p>
	<figure>
		<p><code><var>name</var> ⇒ <var>namebeginchar</var><strong>(</strong><var>namechar</var><strong>)</strong><strong>*</strong></code></p>
		<p><code><var>namebeginchar</var> ⇒ <var>Unicode Letter</var></code></p>
		<p><code><var>namechar</var> ⇒ <var>Unicode Letter</var> <strong>|</strong> <var>Unicode Decimal Digit Number</var> <strong>|</strong> <var>Unicode Connector Punctuation</var></code></p>
	</figure>
	<p>A resource reference is a URI reference, a name reference, or one of several short representations.</p>
	<figure>
		<p><code><var>reference</var> ⇒ <var>urireference</var> <strong>|</strong> <var>namereference</var> <strong>|</strong> <var>urishort</var> <strong>|</strong> <var>stringshort</var> <strong>|</strong> <var>charactershort</var> <strong>|</strong> <var>booleanshort</var> <strong>|</strong> <var>numbershort</var> <strong>|</strong> <var>ordinalshort</var> <strong>|</strong> <var>regexshort</var> <strong>|</strong> <var>temporalshort</var></code></p>
	</figure>
	<p>A resource URI reference is enclosed in angle quotes. The contents is either the text of a URI (or relative reference); or a resource reference to an inline type preceded by an asterisk <code>'*'</code>, immediately followed by a string containing the lexical representation of a resource, surrounded by parentheses <code>'('</code> and <code>')'</code>. If a relative reference is provided, it is resolved against the base URI of the TURF document according to the rules specified in [<a href="#rdfxml">RDF/XML</a>] <cite>5.3 Resolving URIs</cite>. Any URI reference that includes a lexical representation is equivalent to a URI reference in the form <code>«http://urf.name/inline/<var>encodedTypeURI</var>/<var>encodedTURFLexicalForm</var></code>».</p>
	<figure>
		<p><code><var>urireference</var> ⇒ «<strong>(</strong>*<var><var>type</var></var>(<var>stringshort</var>)<strong>)</strong> <strong>|</strong> <strong>(</strong><var>urichar</var><strong>+</strong><strong>)</strong>»</code></p>
		<p><code><var>type</var> ⇒ <var>reference</var></code></p>
	</figure>
	<p>A name reference is a <var>name</var> representing the local name of a resource, optionally preceded by a <var>name</var> ending with the full stop or period character <code>'.'</code>, together representing the URI of a resource. The prefix, if present, must have been associated with a namespace URI in using the tilde character <code>'~'</code> either in the properties of the current resource or one of its subject resources. If no prefix is present for a property, the namespace is the URI of the first type of the subject resource. A prefix must be present in all other name references. The local name is the unencoded form of the fragment to be appended to the namespace URI.</p>
	<figure>
		<p><code><var>namereference</var> ⇒ <strong>[</strong>prefix.<strong>]</strong>localName</code></p>
		<p><code><var>prefix</var> ⇒ <var>name</var></code></p>
		<p><code><var>localName</var> ⇒ <var>name</var></code></p>
	</figure>
	<p>A string short form is a sequence of Unicode characters, using the backslash as an escape character, enclosed in double quotes. The double quotation mark (<code>'"'</code>) and backslash (<code>'\\'</code>) characters must be escaped. A string short form is equivalent to a resource of type <code>urf.String</code> using the corresponding inline namespace. The string short form <code>"example"</code> is the equivalent of the string resource <code>«(urf.String)"example"»</code>.</p>
	<figure>
		<p><code><var>stringshort</var> ⇒ "<strong>[</strong><var>Unicode character except double quote and backslash</var> <strong>|</strong> \" <strong>|</strong> \\ <strong>|</strong> <var>escapedunicode</var> <strong>|</strong> <var>escapedcontrol</var><strong>]*</strong>"</code></p>
	</figure>
	<p>Any Unicode code point may be represented in string and other short representations where indicated by the four lowercase hexadecimal representation following the character sequence <code>"\u"</code>, or if the code point is not in the Basic Multilingual Plane, two such sequences representing UTF-16 surrogate pair.</p>
	<figure>
		<p><code><var>escapedunicode</var> ⇒ \u<var>xxxx</var></code></p>
	</figure>
	<p>Several control characters have escaped forms which can be used in string and other short representations where indicated.</p>
	<figure>
		<p><code><var>escapedcontrol</var> ⇒ \b <strong>|</strong> \t <strong>|</strong> \n <strong>|</strong> \f <strong>|</strong> \r <strong>|</strong> \“ <strong>|</strong> \”</code></p>
		<p><code>\b †\\\u0062‡ ⇒ \u0008 †backspace‡</code></p>
		<p><code>\t †\\\u0074‡ ⇒ \u0009 †character tabulation‡</code></p>
		<p><code>\n †\\\u006e‡ ⇒ \u000a †line feed (LF)‡</code></p>
		<p><code>\f †\\\u0066‡ ⇒ \u000c †form feed (FF)‡</code></p>
		<p><code>\r †\\\u0072‡ ⇒ \u000d †carriage return (CR)‡</code></p>
		<p><code>\“ †\\\u201c‡ ⇒ \u0098 †start of string (SOS)‡</code></p>
		<p><code>\” †\\\u201d‡ ⇒ \u009c †string terminator (ST)‡</code></p>
	</figure>
	<p>A character short form is a single Unicode characters, using the backslash as an escape character, enclosed in a single quote. The single quote (<code>'\''</code>) and backslash (<code>'\\'</code>) characters must be escaped. A character short form is equivalent to a resource of type <code>urf.Character</code> using the corresponding inline namespace. The character short form <code>'x'</code> is the equivalent of the character resource <code>«(urf.Character)"x"»</code>.</p>
	<figure>
		<p><code><var>charactershort</var> ⇒ '<strong>[</strong><var>Unicode character except single quote and backslash</var> <strong>|</strong> \' <strong>|</strong> \\ <strong>|</strong> <var>escapedunicode</var> <strong>|</strong> <var>escapedcontrol</var><strong>]*</strong>'</code></p>
	</figure>
	<p>A URI short form is a sequence of character constituting a syntactically correct URI or a relative reference, surrounded by the angle brackets <code>'&lt;'</code> and <code>'&gt;'</code>. Alternatively, a type and selector may be provided with identical syntax to a resource URI reference. If a relative reference is provided, it is resolved against the base URI of the TURF document according to the rules specified in [<a href="#rdfxml">RDF/XML</a>] <cite>5.3 Resolving URIs</cite>. A URI short form is equivalent to a resource of type <code>urf.URI</code> using the corresponding inline namespace. The URI short form <code>&lt;http://example.com&gt;</code> is the equivalent of the URI resource <code>«(urf.URI)"http://example.com"»</code>.</p>
	<figure>
		<p><code><var>urishort</var> ⇒ &lt;<strong>(</strong>*<var><var>type</var></var>(<var>stringshort</var>)<strong>)</strong> <strong>|</strong> <strong>(</strong><var>urichar</var><strong>+</strong><strong>)</strong>&gt;</code></p>
	</figure>
	<p>A boolean short form is the character sequence <code>true</code> or <code>false</code> surrounded by matching underscore characters <code>'_'</code>. A boolean short form is equivalent to a resource of type <code>urf.Boolean</code> using the corresponding inline namespace. The boolean short form <code>_true_</code> is the equivalent of the boolean resource <code>«(urf.Boolean)"true"»</code>.</p>
	<figure>
		<p><code><var>booleanshort</var> ⇒ _true_<strong>|</strong>_false_</code></p>
	</figure>
	<p>A number short form consists of Roman digits, optionally preceded by a minus sign, with an optional decimal and optional exponent, all surrounded by matching number signs <code>'#'</code>. A number short form is equivalent to a resource of type <code>urf.Integer</code> or <code>urf.Rational</code>, depending on the lexical form used, using the corresponding inline namespace. The number short form <code>#123#</code> is the equivalent of the number resource <code>«(urf.Integer)"123"»</code>, and the number short form <code>#123.45#</code> is the equivalent of the number resource <code>«(urf.Rational)"123.45"»</code>.</p>
	<figure>
		<p><code><var>numbershort</var> ⇒ #<strong>[</strong>-<strong>]</strong><var>n</var><strong>[</strong>.<var>n</var><strong>][</strong>e<strong>(</strong>+<strong>|</strong>-<strong>)</strong><var>n</var><strong>]</strong>#</code></p>
		<p><code><var>n</var> ⇒ <var>romandigit</var><strong>+</strong></code></p>
	</figure>
	<p>An ordinal short form consists of roman digits surrounded by matching ordinal signs <code>'º'</code>. An ordinal short form is equivalent to a resource of type <code>urf.Ordinal</code> using the corresponding inline namespace. The ordinal short form <code>º27º</code> is the equivalent of the ordinal resource <code>«(urf.Ordinal)"27"»</code>.</p>
	<figure>
		<p><code><var>ordinalshort</var> ⇒ º<var>n</var>º</code></p>
	</figure>
	<p>A regular expression short form is a sequence of Unicode characters, using the backslash as an escape character, enclosed in forward slash (<code>'/'</code>) characters. The slash (<code>'/'</code>) and backslash (<code>'\\'</code>) characters must be escaped. A regular expression short form is equivalent to a resource of type <code>urf.RegularExpression</code> using the corresponding inline namespace. The regular expression short form <code>/a?b+c*/</code> is the equivalent of the string resource <code>«(urf.RegularExpression)"a?b+c*"»</code>.</p>
	<figure>
		<p><code><var>regexshort</var> ⇒ /<strong>[</strong><var>Unicode character except slash and backslash</var> <strong>|</strong> \/ <strong>|</strong> \\ <strong>|</strong> <var>escapedunicode</var> <strong>|</strong> <var>escapedcontrol</var><strong>]*</strong>/</code></p>
	</figure>
	<p>A temporal short form consists of the lexical form of a temporal resource such as <code>urf.Date</code>, <code>urf.DateTime</code>, <code>urf.Duration</code>, <code>urf.Time</code>, or <code>urf.UTCOffset</code>, surrounded by matching at signs (<code>'@'</code>). An <code>urf.Duration</code> requires at least the date or the time section to be present. The hours component represents midnight as <code>00</code> and must not have a value larger than <code>23</code>. The UTC offset <code>-00:00</code> is not allowed; <code>+00:00</code> must be used instead. A temporal short form is equivalent to a resource of the corresponding urf.Temporal type, based upon the specific lexical form used. The temporal short form <code>@1999-03-04@</code> is the equivalent of the number resource <code>«(urf.Date)"1999-03-04"»</code>, for example.</p>
	<figure>
		<p><code><var>temporalshort</var> ⇒ @<strong>(</strong><var>YYYY</var>-<var>MM</var>-<var>DD</var><strong>)</strong> <strong>|</strong> <strong>(</strong><var>YYYY</var>-<var>MM</var>-<var>DD</var><code>T<var>hh:</var><var>mm</var>:ss<strong>[</strong>.s<strong>+</strong><strong>]</strong><strong>[</strong><strong>(</strong>+<strong>|</strong>-<strong>)</strong><var>hh</var>:<var>mm</var><strong>]</strong></code><strong>)</strong> <strong>|</strong> <strong>(</strong><var>hh:</var><var>mm</var>:ss<strong>[</strong>.s<strong>+</strong><strong>]</strong><strong>[</strong><strong>(</strong>+<strong>|</strong>-<strong>)</strong><var>hh</var>:<var>mm</var><strong>]</strong><strong>)</strong> <strong>|</strong> <strong>(</strong>P<strong>[</strong><var>n</var>Y<var>n</var>M<var>n</var>D<strong>]</strong><strong>[</strong>T<var>n</var>H<var>n</var>M<var>n</var><strong>[</strong>.<var>n</var><strong>]</strong>S<strong>]</strong><strong>)</strong> <strong>|</strong> <strong>(</strong><strong>(</strong>+<strong>|</strong>-<strong>)</strong><var>hh</var>:<var>mm</var><strong>)</strong>@</code>
		</p>
	</figure>
	<p>The types declaration consists of one or more resource references, each preceded by an asterisk <code>'*'</code>. Each type reference is equivalent to the reference asserted as the object of the <code>urf.type</code> property. Each type reference may optionally specify comma-separated selector resources between parentheses characters <code>'('</code> and <code>')'</code> following the type reference. The selector resources are equivalent to the values of <code>urf.List</code> value of a scoped <code>urf.selector</code> property in the context of the resource's <code>urf.type</code> property for which the type is a value.</p>
	<figure>
		<p><code><var>types</var> ⇒ <var>typeshort</var><var><strong><strong>*</strong></strong></var></code></p>
		<p><code><var>typeshort</var> ⇒ *<var>typereference</var><strong>[</strong>(<strong>[</strong><var>selectorresource</var><strong>[</strong>,<var>selectorresource</var><strong>]</strong><strong>*</strong><strong>]</strong>)<strong>]</strong></code></p>
		<p><code><var>typereference</var> ⇒ <var>reference</var></code></p>
		<p><code><var>selectorresource</var> ⇒ <var>resource</var></code></p>
	</figure>
	<p>The superclasses declaration consists of one or more resource references, each preceded by a circumflex accent <code>'^'</code>. Each superclass reference is equivalent to the reference asserted as the object of the <code>urf.subClassOf</code> property.</p>
	<figure>
		<p><code><var>superclasses</var> ⇒ <var>superclassshort</var><var><strong><strong>*</strong></strong></var></code></p>
		<p><code><var>superclassshort</var> ⇒ ^<var>reference</var></code></p>
	</figure>
	<p>The interfaces declaration consists of one or more resource references, each preceded by a greater-than symbol <code>'&gt;'</code>. Each interface reference is equivalent to the reference asserted as the object of the <code>urf.implementationOf</code> property.</p>
	<figure>
		<p><code><var>interfaces</var> ⇒ <var>interfaceshort</var><var><strong><strong>*</strong></strong></var></code></p>
		<p><code><var>interfaceshort</var> ⇒ *<var>reference</var></code></p>
	</figure>
	<p>Properties consist of a list of predicate resource and object resource pairs between the color character <code>':'</code> and the semicolon character <code>';'</code>, each separated by the equals sign <code>'='</code>. If the grave character <code>'`'</code> is present before the equals sign, it indicates that the property is scoped in the context of the property's subject resource and its respective predicate resource and subject resource. If a label is provided, it identifies the proposition represented by the reification of the assertion.</p>
	<figure>
		<p><code><var>properties</var> ⇒ :<strong>[</strong><var>property</var><strong>[</strong></code><code>listseparator</code><code> <var>property</var><strong><strong>]*</strong>]</strong>;</code></p>
		<p><code><var>property</var> ⇒ <var>resource</var><strong>[</strong><var>label</var><strong>]</strong><strong>[</strong>`<strong>]</strong>=<strong>(</strong><var>sequenceshort</var><strong>|</strong><var>resource</var><strong>)</strong></code></p>
	</figure>
	<p>A sequence short form consists of a sequence of element resources separated by list separators and surrounded by the backslash character <code>'\\'</code>. Each listed element resource indicates another assertion of the given predicate with the given element resource as the value, each with a contextual property of <code>urf.order</code> with values starting at <code>#0#</code> and continuing sequentially.</p>
	<figure>
		<p><code><var>sequenceshort</var> ⇒ \<strong>[</strong><var>resource</var><strong>[</strong></code><code><var>listseparator</var></code><code> <var>resource</var><strong>]*]</strong>\</code></p>
	</figure>
	<p>A community short form consists of a sequence of resources surrounded by the currency symbol <code>'¤'</code> and the full stop character <code>'.'</code>, separated by list separators. Each listed resource represents an unreified proposition that is a value of the <code>urf.element</code> property. The presence of a community short form implies a type of <code>urf.Community</code> if no other types have yet been specified, either implicitly or explicitly.</p>
	<figure>
		<p><code><var>communityshort</var> ⇒ ¤<strong>[</strong><var>resource</var><strong>[</strong></code><code>listseparator</code><code> <var>resource</var><strong>]*].</strong></code></p>
	</figure>
	<p>A proposition short form lists the subject, predicate, and object of a proposition inside the open double quotation mark <code>'“'</code> and closed double quotation mark <code>'”'</code> characters, separated by list separators. A proposition short form is equivalent to setting the resource <code>urf.Subject</code>, <code>urf.Predicate</code>, and <code>urf.Object</code> propoerties to the three listed resources within the proposition short form. The presence of a proposition short form implies a type of <code>urf.Proposition</code> if no other types have yet been specified, either implicitly or explicitly.</p>
	<figure>
		<p><code><var>propositionshort</var> ⇒ “<var>subject</var> </code><code>listseparator</code><code> <var>predicate</var> </code><code>listseparator</code><code> <var>object</var>”</code></p>
		<p><code><var>subject</var> ⇒ <var>resource</var></code></p>
		<p><code><var>predicate</var> ⇒ <var>resource</var></code></p>
		<p><code><var>object</var> ⇒ <var>resource</var></code></p>
	</figure>
	<p>A list short form consists of a sequence of element resources surrounded by bracket characters <code>'['</code> and <code>']'</code> and separated by list separators. Each listed element resource represents the value of an ordinal index property, in sequence beginning with the ordinal property <code><code>º0º</code></code>. The presence of a list short form implies a type of <code>urf.List</code> if no other types have yet been specified, either implicitly or explicitly.</p>
	<figure>
		<p><code><var>listshort</var> ⇒ [<strong>[</strong>resource<strong>[</strong></code><code>listseparator</code><code> resource<strong>]*]</strong>]</code></p>
	</figure>
	<p>A set short form consists of a sequence of element resources surrounded by curly bracket characters <code>'{'</code> and <code>'}'</code> and separated by list separators. Each listed element resource represents a value of the <code>urf.element</code> property. The presence of a set short form implies a type of <code>urf.Set</code> if no other types have yet been specified, either implicitly or explicitly.</p>
	<figure>
		<p><code><var>setshort</var> ⇒ {<strong>[</strong>resource<strong>[</strong></code><code>listseparator</code><code> resource<strong>]*]</strong>}</code></p>
	</figure>
	<p>A map short form consists of a sequence of key/value associations surrounded by tortoise shell bracket characters <code>'〔'</code> and <code>'〕'</code>. Each key is separated from its value using the equals sign <code>'='</code>, and the key/value combinations are separated by list separators. Each key/value association represents a resource of type <code>urf.MapEntry</code> as a value of the <code>urf.entry</code> property of the map resource, with key a value of the map entry <code>urf.key</code> property, and the value a value of the map entry <code>urf.value</code> property. The presence of a map short form implies a type of <code>urf.Map</code> if no other types have yet been specified, either implicitly or explicitly.</p>
	<figure>
		<p><code><var>mapshort</var> ⇒ 〔<strong>[</strong><var>mapentry</var><strong>[</strong></code><code>listseparator</code><code> <var>mapentry</var><strong><strong>]*</strong>]</strong>〕</code></p>
		<p><code><var>mapentry</var> ⇒ <var>key</var>=<var>value</var></code></p>
		<p><code><var>key</var> ⇒ <var>resource</var></code></p>
		<p><code><var>value</var> ⇒ <var>resource</var></code></p>
	</figure>
	<h2>PLOOP</h2>
	<p>It is possible to use URF as a Programming Language Ontology for Objects and Properties (PLOOP), allowing long-term storage and/or object tree instance descriptions of programming languages using TURF, for example. The following specifies a canonical set of rules a processor must follow for for constructing a hierarchy of programming language objects based upon an URF description. All examples are represented using TURF and are given in the Java programming language using the Guise Internet application framework [<a href="#guise">Guise</a>]. A complete <a href="#ploopExample">PLOOP example</a> is provided at the end of this specification.</p>
	<h3>Classes</h3>
	<p>The URI of an URF class must indicate the complete package name and class name of a programming language class to instantiate. In the following example, the Java class <code>com.guiseframework.component.Layoutpanel</code> should be instantiated using its default constructor:</p>
	<figure>
		<pre><code class="language-turf">`URF¤
  *«java:/com/guiseframework/component/LayoutPanel»
.</code></pre>
	</figure>
	<p>If a resource has a scoped <code>urf.selector</code> property with an <code>urf.List</code> value in the context of an <code>urf.type</code> declaration, a PLOOP processor must use all the corresponding values as arguments to the constructor of the specified type, converted the URF selector resources into programming language values as needed. A PLOOP instance would use the following example to indicate that an instance of the Guise class <code>com.guiseframework.Category</code> should be constructed using <code>new Category("category1", "First Category")</code>:</p>
	<figure>
		<pre><code class="language-turf">`URF¤
  *«java:/com/guiseframework/Category»("category1", "First Category")
.</code></pre>
	</figure>
	<h3>Properties</h3>
	<p>URF allows identification of programming language properties through use of the default URF namespace <code>&lt;http://urf.name/default/&gt;</code>. A PLOOP processor must use normal get/set conventions for the language in question for interpreting the read/write properties available for a particular class. For example, the local name of the property <code>«http://urf.name/default/label»</code> for a resource of type <code>«java:/com/guiseframework/component/Button»</code> is considered a property name for getting or setting a value of an instance of the <code>Button</code> class:</p>
	<figure>
		<pre><code class="language-turf">`URF¤
  *«java:/com/guiseframework/component/Button»:
    label="Push Me"
  ;
.</code></pre>
	</figure>
	<h3>Values</h3>
	<p>In general, URF resources with URIs that are recognized must be converted to the equivalent type in the programming language. For example, in Java all resources of type <code>urf.Integer</code> must be converted to instances of java.lang.Integer. Likewise in Java <code>urf.List</code>, <code>urf.Set</code>, and <code>urf.Map</code> resources must be converted to <code>java.util.List</code>, <code>java.util.Set</code>, and <code>java.util.Map</code> instances, respectively, with each element or entry recursively instantiated or converted as needed. A resource with an inline URI must be converted if possible to a programming language type functioning as a lexical identifier, if its inlin type indicates such an enumerated type. In the following example, the Guise Java class <code>com.guiseframework.component.layout.FlowLayout</code> has a <code>setFlow(com.guiseframework.component.layout.Flow)</code> method. The inline URI <code>«*layout.Flow("LINE")»</code> indicates a type of <code>com.guiseframework.component.layout.Flow</code>, which is a Java enum class. A PLOOP processor must construct a <code>com.guiseframework.component.layout.Flow</code> object from the string "LINE" and assign it to the instance of <code>com.guiseframework.component.layout.FlowLayout</code> using <code>com.guiseframework.component.layout.FlowLayout.setFlow(com.guiseframework.component.layout.Flow)</code>.</p>
	<figure>
		<pre><code class="language-turf">`URF¤
  («java:/com/guiseframework/component/layout/FlowLayout»:
    flow=«*layout.Flow("LINE")»
  ;
.</code></pre>
	</figure>
	<h2>Reference Implementation</h2>
	<p>GlobalMentor, Inc. maintains an open-source reference implementation for processing URF. The library provides an API and source code for parsing URF from TURF, parsing URF from RDF/XML, creating a Java instance tree from URF, generating TURF from URF, generating URF from a Java instance tree, and manipulating URF in-memory. The reference implementation source code may be downloaded from the GlobalMentor Subversion repository at &lt;<a href="https://svn.globalmentor.com/java/src/com/globalmentor/urf/">https://svn.globalmentor.com/java/src/com/globalmentor/urf/</a>&gt;. The API documentation may be found at &lt;<a href="http://www.guiseframework.com/doc/api/com/globalmentor/urf/package-summary.html">http://www.guiseframework.com/doc/api/com/globalmentor/urf/package-summary.html</a>&gt;. The Guise Internet application framework [<a href="#guise">Guise</a>] development library contains the URF reference implementation already compiled, and is available at &lt;<a href="http://www.guiseframework.com/com.guiseframework-unlicensed.jar">http://www.guiseframework.com/com.guiseframework-unlicensed.jar</a>&gt;.</p>
	<p>GlobalMentor also maintains an online demonstration of live, dynamic URF processing and exploration. The demonstration uses the Guise Internet application framework [<a href="#guise">Guise</a>] and allows TURF or RDF/XML to be processed and displayed as URF assertions, TURF, and a dynamic tree or resources and properties. This URF processing demonstration is available at &lt;<a href="http://www.guiseframework.com/demo/urfprocess">http://www.guiseframework.com/demo/urfprocess</a>&gt;.</p>
	<h2>Examples</h2>
	<h3>JSON</h3>
	<p>In the JavaScript Object Notation (JSON) [<a href="#rfc4627">RFC 4627</a>], every object besides strings, numbers, and booleans are associative arrays using string keys. The following is a complex JSON object, using every JSON data type available:</p>
	<figure>
		<pre><code class="language-json">{
  "length":1234,
  "valid":true,
  "status":"processing",
  "results":[false, 5, "dog", {"code":9.8}]
}</code></pre>
	</figure>
	<p>While this representation has some undesirable traits (e.g. strings are not recommended as general property identifiers except in the case of resources used as maps), the following TURF representation is semantically identical to the JSON example above:</p>
	<figure>
		<pre><code class="language-turf">`URF¤
  :
    "length"=#1234#,
    "valid"=_true_,
    "status"="processing",
    "results"=[_false_, #5#, "dog", :"code"=#9.8#;]
  ;
.</code></pre>
	</figure>
	<p>Note that, unlike JSON, in TURF the commas separating the values are optional if the values appear on separate lines.</p>
	<p>There is one slight semantic descrepancy between these two examples: URF uses a true ordinal property for each list element, while JSON adds each array element as the value of a string containing the lexical form of an integer.</p>
	<p>Although the above TURF representation replicates the simple semantics of the given JSON example, a better formulation that takes advantage of URF semantics would most importantly use actual properties rather than associative array string key pseudo-properties. An improved formulation would also indicate the type of the resources. Such improvements are illustrated in the following reformulation (assuming the <code>"code"</code> string in the list was intended to actually be a key in a map):</p>
	<figure>
		<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "example"~&lt;http://example.com/example/&gt;
;¤
  *example.Class:
    example.length=#1234#
    example.valid=_true_
    example.status="processing"
    example.results=[_false_, #5#, "dog", 〔"code"=#9.8#〕]
  ;
.</code></pre>
	</figure>
	<h3>PLOOP</h3>
	<p>The following TURF example uses URF as <a href="#ploop">PLOOP</a> for the Guise Internet application framework [<a href="#guise">Guise</a>] using the Java programming language. It defines a panel of Guise components that allow temperature to be converted between Celsius and Fahrenheit. (The control listeners and temperature conversion logic would be defined elsewhere.)</p>
	<figure>
		<pre><code class="language-turf">`URF:
  "component"~&lt;java:/com/guiseframework/component/&gt;
  "layout"~&lt;java:/com/guiseframework/component/layout/&gt;
  "validator"~&lt;java:/com/guiseframework/validator/&gt;
  "demo"~&lt;java:/com/guiseframework/demo/&gt;
;¤
  *demo.TemperatureConversionPanel2:
    label="Guise™ Demonstration: Temperature Conversion"
    layout=*layout.FlowLayout:
      flow=«*layout.Flow("LINE")»
    ;
    name="temperatureConversionPanel"
    children=[
      *component.LayoutPanel:
        layout=*layout.FlowLayout:
          flow=«*layout.Flow("PAGE")»
        ;
        name="inputPanel"
        children=[
          *component.TextControl(«java:/java/lang/Double»):
            label="Input Temperature"
            name="temperatureInput"
            validator=*validator.ValueRequiredValidator
          ;
          *component.TextControl(«java:/java/lang/Double»):
            editable=_false_
            label="Output Temperature"
            name="temperatureOutput"
          ;
        ]
      ;,
      *component.LayoutPanel:
        layout=*layout.FlowLayout:
          flow=«*layout.Flow("PAGE")»
        ;
        name="conversionPanel"
        children=[
          *component.GroupPanel:
            label="Input Scale"
            layout=*layout.FlowLayout:
              flow=«*layout.Flow("PAGE")»
            ;
            name="scalePanel"
            children=[
              *component.CheckControl:
                checkType="ellipse"
                label="Calsius"
                name="celsiusCheckControl"
              ;
              *component.CheckControl:
                checkType="ellipse"
                label="Fahrenheit"
                name="fahrenheitCheckControl"
              ;
            ]
          ;
          *component.Button:
            label="Convert"
            name="conversionButton"
          ;
        ]
      ;
    ]
  ;
.</code></pre>
	</figure>
	<p>The preceding example, when processed by an URF PLOOP processor, will produce an object instance graph identical to that produced by the following Java code:</p>
	<figure>
		<pre><code class="language-java">import com.guiseframework.component.*;
import com.guiseframework.component.layout.*;
import com.guiseframework.validator.*;

DefaultNavigationPanel navigationPanel=new DefaultNavigationPanel();
navigationPanel.setName("temperatureConversionPanel");
navigationPanel.setLayout(new FlowLayout(Flow.LINE));
navigationPanel.setLabel("Guise\u2122 Demonstration: Temperature Conversion");

LayoutPanel inputPanel=new LayoutPanel(new FlowLayout(Flow.PAGE));
TextControl&lt;Double&gt; temperatureInput=new TextControl&lt;Double&gt;(Double.class);
temperatureInput.setName("temperatureInput");
temperatureInput.setLabel("Input Temperature");
temperatureInput.setValidator(new ValueRequiredValidator&lt;Double&gt;());
inputPanel.add(temperatureInput);

TextControl&lt;Double&gt; temperatureOutput=temperatureOutput=new TextControl&lt;Double&gt;(Double.class);
temperatureOutput.setName("temperatureOutput");
temperatureOutput.setLabel("Output Temperature");
temperatureOutput.setEditable(false);
inputPanel.add(temperatureOutput);

navigationPanel.add(inputPanel);

LayoutPanel conversionPanel=new LayoutPanel();
conversionPanel.setLayout(new FlowLayout(Flow.PAGE));

GroupPanel scalePanel=new GroupPanel();
scalePanel.setLayout(new FlowLayout(Flow.PAGE));

scalePanel.setLabel("Input Scale");
CheckControl celsiusCheckControl=celsiusCheckControl=new CheckControl();
celsiusCheckControl.setName("celsiusCheckControl");
celsiusCheckControl.setCheckType(CheckControl.CheckType.ELLIPSE);
celsiusCheckControl.setLabel("Celsius");
scalePanel.add(celsiusCheckControl);
CheckControl fahrenheitCheckControl=fahrenheitCheckControl=new CheckControl();
fahrenheitCheckControl.setName("fahrenheitCheckControl");
fahrenheitCheckControl.setCheckType(CheckControl.CheckType.ELLIPSE);
fahrenheitCheckControl.setLabel("Fahrenheit");
scalePanel.add(fahrenheitCheckControl);

conversionPanel.add(scalePanel);

Button convertButton=new Button();
convertButton.setName("conversionButton");
convertButton.setLabel("Convert");
conversionPanel.add(convertButton);
navigationPanel.add(conversionPanel);
</code></pre> </figure>
	<h3>RDF/XML</h3>
	<p>URF is a semantic superset of RDF, and can represent any construct available in RDF. URF presents equivalents of many RDF classes as well. In terms of representation formats, TURF can represent any semantic information that is available using [<a href="#rdfxml">RDF/XML</a>], yet is more flexible and has less restrictions. The following is a sample RDF/XML representation of an RDF data instance using many of the capabilities available in RDF/XML:</p>
	<figure>
		<pre><code class="language-xml">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE rdf:RDF [&lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#"&gt;]&gt;
&lt;rdf:RDF
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:example="http://example.com/example/"
  xmlns:foaf="http://xmlns.com/foaf/0.1/"
  xmlns:xhtml="http://www.w3.org/1999/xhtml"
&gt;
  &lt;foaf:Person rdf:about="http://example.com/example#janedoe"&gt;
    &lt;foaf:nick xml:lang="pt-BR"&gt;Janinha&lt;/foaf:nick&gt;
    &lt;example:age rdf:datatype="&amp;xsd;integer"&gt;23&lt;/example:age&gt;
    &lt;example:birthdate rdf:datatype="&amp;xsd;date"&gt;1980-04-05&lt;/example:birthdate&gt;
    &lt;example:motto rdf:parseType="Literal"&gt;Do it. Do it &lt;xhtml:em&gt;right&lt;/xhtml:em&gt;.&lt;/example:motto&gt;
    &lt;example:favoriteSites rdf:parseType="Collection"&gt;
      &lt;rdf:Description rdf:about="http://www.globalmentor.com/"/&gt;
      &lt;rdf:Description rdf:about="http://www.garretwilson.com/"/&gt;
    &lt;/example:favoriteSites&gt;
    &lt;example:possibleVacationDestinations&gt;
      &lt;rdf:Alt&gt;
        &lt;rdf:li&gt;Paris&lt;/rdf:li&gt;
        &lt;rdf:li&gt;Rome&lt;/rdf:li&gt;
      &lt;/rdf:Alt&gt;
    &lt;/example:possibleVacationDestinations&gt;
  &lt;/foaf:Person&gt;
&lt;/rdf:RDF&gt;</code></pre>
	</figure>
	<p>The following URF information represented in TURF is semantically equivalent to the RDF information in the previous example represented in RDF/XML:</p>
	<figure>
		<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "content"~&lt;http://urf.name/content/&gt;
  "dc"~&lt;http://purl.org/dc/elements/1.1/&gt;
  "example"~&lt;http://example.com/example/&gt;
  "foaf"~&lt;http://xmlns.com/foaf/0.1/&gt;
;¤
  example.janedoe*foaf.Person:
    example.age=#23#
    example.birthdate=@1980-04-05@
    example.favoriteSites=[
      «http://www.globalmentor.com/»
      «http://www.garretwilson.com/»
    ],
    example.motto="Do it. Do it &lt;xhtml:em xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"&gt;right&lt;/xhtml:em&gt;.":
      content.type`=«*content.MediaType("text/xml-external-parsed-entity")»
    ;
    example.possibleVacationDestinations={
      "Paris",
      "Rome"
    }
    nick="Janinha":
      dc.language`=«*urf.Language("pt-BR")»
    ;
  ;
.</code></pre>
	</figure>
	<p>Note that, rather than use special literal types or general strings, URF promotes the representation of resources by URIs. Thus the language tag "pt-BR" for Brazilian Portuguese is represented as a resource with a URI in the <code>urf.Language</code> inline namespace, and the integer value <code>23</code> is represented as a resource with a URI in the <code>urf.Integer</code> inline namespace (shown here in its short form, <code>#23#</code>).</p>
	<h3>VCard</h3>
	<p>The URF <a href="#vcard">VCard Ontology</a> provides a representation of VCard [<a href="#rfc2426">RFC 2426</a>] within a semantic framework. The following is VCard information in traditional vCard MIME Directory Profile syntax as specified by [<a href="#rfc2426">RFC 2426</a>].</p>
	<figure>
		<pre><code class="language-vcard">BEGIN:vCard
VERSION:3.0
FN:Jane Doe
N:Doe;Jane;Mary,Ann;Dr.;M.D.,Ph.D.
ORG:Example Corporation;North American Division;Business Development
TITLE:Directory of Business Development
ADR;TYPE=WORK,POSTAL,PARCEL:;Suite 45;123 Some Street;Someplace;CA;12345-6789;USA
LABEL="123 Some Street\nSuite 45\nSomeplace, CA 12345-6789"
TEL;TYPE=PREF;VOICE,WORK:+1-234-567-8910
TEL;TYPE=VOICE,HOME,CELL:+1-234-567-8911
EMAIL;PREF:janedoe@example.com
EMAIL:jdoe@example.org
URL:http://www.example.com/home/jane/
BDAY=1980-02-02T09:45:00
CATEGORY:Internet,B2B,P2P,Web2.0,ABCD
END:vCard</code></pre>
	</figure>
	<p>The same vCard information in its URF VCard formulation is shown below for the resource <code>«http://example.com/example/janedoe»</code>. Note that the URF VCard version provides more semantics by using true classes and properties to describe what [<a href="#rfc2426">RFC 2426</a>] calls <dfn>structured values</dfn>.</p>
	<figure>
		<pre><code class="language-turf">`URF:
  "vcard"~&lt;http://urf.com/vcard/&gt;
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.janedoe:
    vcard.fn="Jane Doe"
    vcard.n=*vcard.Name:
      vcard.familyName="Doe"
      vcard.givenName="Jane"
      vcard.additionalName=\"Mary", "Ann"\
      vcard.honoraryPrefix="Dr."
      vcard.honorarySuffix=\"M.D.", "Ph.D."\
    ;
    vcard.org=\"Example Corporation", "North American Division", "Business Development"\
    vcard.title="Directory of Business Development"
    vcard.adr=*vcard.Adr:
      vcard.adrType=«*vcard.AdrType("work")»
      vcard.adrType=«*vcard.AdrType("postal")»
      vcard.adrType=«*vcard.AdrType("parcel")»
      vcard.extendedAddress="Suite 45"
      vcard.streetAddress="123 Some Street"
      vcard.locality="Someplace"
      vcard.region="CA"
      vcard.postalCode="12345-6789"
      vcard.countryName="USA"
    ;
    vcard.label="123 Some Street\nSuite 45\nSomeplace, CA 12345-6789"
    vcard.tel=
    \
      «tel:+1-234-567-8910»:
        vcard.telType`=«*vcard.TelType("voice")»
        vcard.telType`=«*vcard.TelType("work")»
      ;
      «tel:+1-234-567-8911»:
        vcard.telType`=«*vcard.TelType("voice")»
        vcard.telType`=«*vcard.TelType("home")»
        vcard.telType`=«*vcard.TelType("cell")»
      ;
    \
    vcard.email=\&lt;janedoe@example.com&gt;, &lt;jdoe@example.org&gt;\
    vcard.url=&lt;http://www.example.com/home/jane/&gt;
    vcard.bday=@1980-02-02T09:45:00@
    vcard.category="Internet"
    vcard.category="B2B"
    vcard.category="P2P"
    vcard.category="Web2.0"
    vcard.category="ABCD"
  ;
.</code></pre>
	</figure>
	<h2>References</h2>
	<dl>
		<dt>DCMI Namespace</dt>
		<dd>Andy Powell and Harry Wagner. <a href="http://dublincore.org/documents/dcmi-namespace/"><cite>Namespace Policy for the Dublin Core Metadata Initiative (DCMI)</cite></a>. Dublin Core Namespace Initiative, 2007.</dd>
		<dt>Guise</dt>
		<dd><a href="http://www.guiseframework.com/"><cite>Guise™ Internet Application Framework</cite></a>. GlobalMentor, Inc.</dd>
		<dt>IANA Charset Registry</dt>
		<dd><a href="http://www.iana.org/assignments/character-sets"><cite>IANA Charset Registry</cite></a>. Internet Assigned Numbers Authority.</dd>
		<dt>ISO 8601</dt>
		<dd><cite>ISO 8601:2004(E): Data elements and interchange formats — Information interchange — Representation of dates and times</cite>. International Organization for Standardization, 2004-12-01.</dd>
		<dt>RDF/XML</dt>
		<dd>Dave Beckett. <a href="http://www.w3.org/TR/rdf-syntax-grammar/"><cite>RDF/XML Syntax Specification (Revised)</cite></a>. World Wide Web Consortium, 2006-02-10.</dd>
		<dt>RFC 2046</dt>
		<dd>N. Freed and N. Borenstein. <a href="http://www.ietf.org/rfc/rfc2046.txt"><cite>RFC 2046: Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</cite></a>. Internet Engineering Task Force, 1996.</dd>
		<dt>RFC 2130</dt>
		<dd>C. Weider, C. Preston, K. Simonsen, H. Alvestrand, R. Atkinson, M. Crispin, and P. Svanberg. <a href="http://www.ietf.org/rfc/rfc2278.txt"><cite>RFC 2130: The Report of the IAB Character Set Workshop held 29 February - 1 March, 1996</cite></a>. Internet Engineering Task Force, 1997.</dd>
		<dt>RFC 2278</dt>
		<dd>N. Freed and J. Postel. <a href="http://www.ietf.org/rfc/rfc2278.txt"><cite>RFC 2278: IANA Charset Registration Procedures</cite></a>. Internet Engineering Task Force, 1998.</dd>
		<dt>RFC 2426</dt>
		<dd>F. Dawson and T. Howes. <a href="http://www.ietf.org/rfc/rfc2426.txt"><cite>RFC 2426: vCard MIME Directory Profile</cite></a>. Internet Engineering Task Force, 1998.</dd>
		<dt>RFC 2445</dt>
		<dd>F. Dawson and and D. Stenerson. <a href="http://www.ietf.org/rfc/rfc2426.txt"><cite>RFC 2445: Internet Calendaring and Scheduling Core Object Specification (iCalendar)</cite></a>. Internet Engineering Task Force, 1998.</dd>
		<dt>RFC 3339</dt>
		<dd>G. Klyne and C. Newman. <a href="http://www.ietf.org/rfc/rfc3339.txt"><cite>RFC 3339: Date and Time on the Internet: Timestamps</cite></a>. Internet Engineering Task Force, 2002.</dd>
		<dt>RFC 3966</dt>
		<dd>H. Schulzrinne. <a href="http://www.ietf.org/rfc/rfc3966.txt"><cite>RFC 3966: The tel URI for Telephone Numbers</cite></a>. Internet Engineering Task Force, 2004.</dd>
		<dt>RFC 3986</dt>
		<dd>T. Berners-Lee, R. Fielding, and L. Masinter. <a href="http://www.ietf.org/rfc/rfc3986.txt"><cite>RFC 3986: Uniform Resource Identifier (URI): Generic Syntax</cite></a>. Internet Engineering Task Force, 2005.</dd>
		<dt>RFC 4627</dt>
		<dd>D. Crockford. <a href="http://www.ietf.org/rfc/rfc4627.txt"><cite>RFC 4627: The application/json Media Type for JavaScript Object Notation (JSON)</cite></a>. Internet Engineering Task Force, 2006.</dd>
		<dt>RFC 4646</dt>
		<dd>A. Phillips and M. Davis. <a href="http://www.ietf.org/rfc/rfc4646.txt"><cite>RFC 4646: Tags for Identifying Languages</cite></a>. Internet Engineering Task Force, 2006.</dd>
		<dt>RFC 4648</dt>
		<dd>S. Josefsson. <a href="http://www.ietf.org/rfc/rfc4648.txt"><cite>RFC 4648: The Base16, Base32, and Base64 Data Encodings</cite></a>. Internet Engineering Task Force, 2006.</dd>
		<dt>Unicode BOM FAQ</dt>
		<dd>Asmus Freytag and Mark Davis. <a href="http://www.unicode.org/unicode/faq/utf_bom.html#BOM"><cite>Unicode Byte Order Mark (BOM) FAQ</cite></a>. Unicode, Inc., Retrieved 2006-06-07.</dd>
		<dt>UTR #13</dt>
		<dd>Mark Davis. <a href="http://unicode.org/unicode/standard/reports/tr13/tr13-5.html"><cite>Unicode Technical Report #13: Unicode Newline Guidelines</cite><cite></cite></a>. Unicode, Inc., 1999.</dd>
		<dt>XML Schema 2</dt>
		<dd>Paul V. Biron and Ashok Malhotra. <a href="http://www.w3.org/TR/xmlschema-2/"><cite>XML Schema Part 2: Datatypes Second Edition</cite></a>. World Wide Web Consortium, 2004-10-28.</dd>
	</dl>
	<h2>Acknowledgements</h2>
	<p>Brad Neuberg encouraged the creation of an alternate RDF serialization; Frank Manola made convincing arguments for using ordinals instead of integers as list element predicates.</p>
	<h2>History</h2>
	<dl>
		<dt>2009-09-06</dt>
		<dd>
			<ul>
				<li>Change namespace URI rules to only allow namespace URIs that are collection URIs.</li>
				<li>Renamed "lexical namespace/URI" to "inline namespace/URI" and improved the corresponding semantics.</li>
				<li>Renamed <code>urf.Real</code> to <code>urf.Rational</code>.</li>
			</ul>
		</dd>
	</dl>
	<dl>
		<dt>2009-08-24</dt>
		<dd>
			<ul>
				<li>Changed grammar to allow Unicode newline characters as separators.</li>
				<li>Changed TURF content type to <code>text/urf</code>.</li>
			</ul>
		</dd>
	</dl>
	<dl>
		<dt>2008-01-20 </dt>
		<dd>
			<ul>
				<li>Improved semantics of <code>urf.Map</code> by adding map entries to distinguish between properties and map key/value associations.</li>
				<li>Added delimiters for <code>urf.Map</code> TURF short form.</li>
				<li>Changed delimiter of <code>urf.Boolean</code> TURF short form.</li>
				<li>Modified <code>urf.type</code> TURF short form syntax.</li>
				<li>Introduced <code>urf.selector</code> property with TURF short form.</li>
				<li>Removed <code>urf.inits</code> property.</li>
				<li>Documented <code>urf.subClassOf</code> and <code>urf.implementationOf</code> properties.</li>
				<li>Added TURF superclass and interface short forms.</li>
				<li>Renamed <code>content.CharacterEncoding</code> to <code>content.Charset</code>.</li>
			</ul>
		</dd>
		<dt>2007-12-31</dt>
		<dd>
			<ul>
				<li>Added <code>content.CharacterEncoding</code> class.</li>
				<li>Renamed URF reference implementation Java package.</li>
			</ul>
		</dd>
		<dt>2007-12-23</dt>
		<dd>
			<ul>
				<li>Changed TURF preamble delimiters.</li>
				<li>Changed TURF namespace association delimiter.</li>
				<li>Changed syntax for <code>urf.Boolean</code> short form.</li>
				<li>Changed order of string and type in TURF lexical form reference.</li>
				<li>Brought back requirement for ending delimiters for TURF number, temporal, and ordinal short representations to prevent an ambigious grammar.</li>
			</ul>
		</dd>
		<dt>2007-11-22</dt>
		<dd>
			<ul>
				<li>Changed syntax for <code>urf.Boolean</code> short form.</li>
				<li>Changed the TURF preface delimiter.</li>
			</ul>
		</dd>
		<dt>2007-11-18</dt>
		<dd>
			<ul>
				<li>Added TURF preamble.</li>
				<li>Improved TURF name grammar.</li>
				<li>Simplified TURF name namespace inheritance rules.</li>
				<li>Changed <code>urf.MediaType</code> to <code>content.MediaType</code>.</li>
				<li>Simplified PLOOP processing rules.</li>
				<li>Addressed merging of ordered properties.</li>
				<li>Changed syntax for <code>urf.Enum</code> value declarations.</li>
				<li>Introducted <code>urf.Community</code>.</li>
				<li>Reframed semantics of scoped properties in terms of URF communities.</li>
				<li>Added <code>urf.Proposition</code> short form.</li>
				<li>Changed comment syntax.</li>
				<li>Expanded rules for URI namespace determination.</li>
				<li>Changed syntax for <code>urf.Boolean</code> short form.</li>
			</ul>
		</dd>
		<dt>2007-10-16</dt>
		<dd>
			<ul>
				<li>Changed order of TURF properties declaration.</li>
				<li>Added <code>urf.init</code> property.</li>
				<li>Added PLOOP specification.</li>
				<li>Improved and clarified TURF namespace inheritance rules.</li>
				<li>Added list of ontologies along with links to their TURF definitions.</li>
				<li>Added RDF/XML example.</li>
				<li>Added PLOOP example.</li>
				<li>Added reference implementation links.</li>
				<li>Improved and simplified TURF URI and URI reference lexical form representation.</li>
				<li>Clarified and extended <code>urf.Temporal</code> types.</li>
				<li>Changed base lexical namespace URI to <code>&lt;http://urf.name/lexical/&gt;</code>.</li>
				<li>Added <code>urf.Language</code> type.</li>
				<li>Added <code>urf.MediaType</code> type.</li>
				<li>Changed PLOOP example to use <code>java:</code> URIs.</li>
				<li>Removed trailing delimiter from TURF temporal short forms.</li>
				<li>Added <code>urf.Enum</code> description.</li>
			</ul>
		</dd>
		<dt>2007-10-05</dt>
		<dd>
			<ul>
				<li>Added TURF Internet media type.</li>
				<li>Removed requirement that TURF strings must escape control characters.</li>
				<li>Added period to set of name characters.</li>
				<li>Added comments to TURF.</li>
				<li>Clarified and expanded TURF Unicode control escape sequences.</li>
				<li>Clarified and expanded namespace rules.</li>
				<li>Added <code>urf.Binary</code> type.</li>
				<li>Added <code>urf.Ordinal</code> type.</li>
				<li>Changed arrays to use ordinal indexes.</li>
				<li>Removed trailing delimiter from TURF number short forms.</li>
				<li>Removed trailing delimiter from TURF boolean short forms.</li>
				<li>Changed TURF boolean short form delimiter.</li>
				<li>Changed TURF name short form prefix delimiter.</li>
				<li>Changed TURF properties section delimiter.</li>
				<li>Improved TURF name grammar.</li>
				<li>Added <code>urf.Set</code> type.</li>
				<li>Renamed <code>urf.Array</code> to <code>urf.List</code>.</li>
				<li>Clarified TURF name reference namespace inheritance.</li>
			</ul>
		</dd>
		<dt>2007-09-15</dt>
		<dd>
			<ul>
				<li>Switched to <code>info:lexical</code> lexical namespaces.</li>
			</ul>
		</dd>
		<dt>2007-09-14</dt>
		<dd>
			<ul>
				<li>Added name reference short form.</li>
				<li>Modified syntax for sequences.</li>
				<li>Switched to <code>info:lexis</code> lexical namespaces.</li>
				<li>Changed property type for array indexes.</li>
				<li>Clarified number types.</li>
				<li>Added delimiters to boolean and number types.</li>
				<li>Added the ID namespace.</li>
				<li>Clarified array grammar.</li>
				<li>Added URF abstract model grammar.</li>
				<li>Added JSON example.</li>
			</ul>
		</dd>
		<dt>2007-09-08</dt>
		<dd>
			<ul>
				<li>Modified and simplified syntax for resource URI references and type declarations.</li>
				<li>Changed <dfn>contextual properties</dfn> to <dfn>scoped properties</dfn>.</li>
			</ul>
		</dd>
		<dt>2007-09-02</dt>
		<dd>
			<ul>
				<li>First public release of URF.</li>
			</ul>
		</dd>
	</dl>
	<script src="../../pub/js/prism.js"></script>
</body>

</html>
