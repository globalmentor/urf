<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
	<meta charset="UTF-8" />
	<meta name="author" content="Garret Wilson" />
	<title>TURF Specification</title>
	<link type="text/css" rel="stylesheet" href="../../pub/css/globalmentor-doc.css" />
</head>

<body>
	<header>
		<h1>Text URF (TURF) Specification</h1>
		<aside class="important far side">Draft version.</aside>
		<dl>
			<dt>Author</dt>
			<dd><a href="http://www.garretwilson.com/" class="external">Garret Wilson</a> (<a href="http://www.globalmentor.com/" class="external">GlobalMentor, Inc.</a>)</dd>
			<dt>Version</dt>
			<dd>Draft 2019-01-11</dd>
		</dl>
	</header>
	<h2>Introduction</h2>
	<p>TURF is the text interchange format for URF. TURF emphasizes terseness and consistency while maintaining human readability, with a preference for using symbols from existing interchange formats such as JSON and programming languages such as Java and C#. TURF has several useful properties, including:</p>
	<ul>
		<li>TURF has an optional signature character sequence, <code>\URF</code>, for easy recognition.</li>
		<li>TURF has an optional unambiguous end delimiter sequence <code>\.</code>, allowing TURF to be embedded in existing text-based content.</li>
		<li>Whitespace separators and comments may be removed with no loss of semantics, resulting in an extremely compact representation.</li>
		<li>Standard delimiters are used, such as <code>{…}</code> for sets, <code>[…]</code> for lists, <code>"…"</code> for strings, <code>&lt;…&gt;</code> for IRIs, and <code>#…</code> for decimal numbers.</li>
	</ul>
	<h3>Conventions Used in this Document</h3>
	<p>The key words “<span class="spec-must">must</span>”, “<span class="spec-must-not">must not</span>”, “<span class="spec-must">required</span>”, “<span class="spec-must">shall</span>”, “<span class="spec-must-not">shall not</span>”, “<span class="spec-should">should</span>”, “<span class="spec-should-not">should not</span>”, “<span class="spec-should">recommended</span>”, “<span class="spec-may">may</span>”, and “<span class="spec-may">optional</span>” in this document are to be interpreted as described in <a href="#ref-rfc2119" class="ref">RFC 2119</a>. Parts of this specification marked as <span class="note">notes</span> and <span class="annotation">annotations</span> are non-normative.</p>
	<h2>Internet Media Type</h2>
	<aside class="note far third">The charset of a TURF document may therefore be deduced by examining the bytes of the document. If those bytes match the TURF signature in some charset, that is the charset of the document; otherwise, the charset is UTF-8.</aside>
	<p>The Internet media type (<a href="#ref-rfc2046" class="ref">RFC 2046</a>, <a href="#ref-rfc6657" class="ref">RFC 6657</a>) of a TURF document <span class="spec-must">shall</span> be <code>text/urf</code> and <span class="spec-must">must</span> be encoded in UTF-8, UTF-16, or UTF-32. A TURF document <span class="spec-must-not">must not</span> begin with a byte order mark (<abbr>BOM</abbr>) or UTF-8 signature. If encoded in any encoding other than UTF-8, a TURF document <span class="spec-must">must</span> begin with a TURF <a href="#signature">signature</a>.</p>
	<p>TURF differs from general <a href="#ref-rfc2046" class="ref">RFC 2046</a> text media types in the following: </p>
	<ul>
		<li>The default charset of TURF is UTF-8 rather that ASCII.</li>
		<li>TURF allows any Unicode newline character (<a href="#ref-utr13" class="ref">UTR #13</a>) to represent newlines rather than only <code>CRLF</code>.</li>
	</ul>
	<p>For any application-specific URF data encoded as TURF <span class="spec-should">should</span> be represented as <code>application/<var>applicationName</var>+turf</code> to allow the data to be recognized as such, where <code><var>applicationName</var></code> is the application-specific identifier for the URF information.</p>
	<h2>Document</h2>
	<p>A TURF <dfn>document</dfn> encodes an <dfn>URF instance</dfn> (TODO reference URF) as one or more graphs of <dfn>resources</dfn> representing URF statements. A TURF document <span class="spec-may">may</span> be contain no resource representations, in which case it representing no URF statements.</p>
	<h2>Syntax</h2>
	<h3>Whitespace</h3>
	<aside class="note far third">TURF follows the <cite>ECMAScript® 2016</cite> definition of “WhiteSpace”. <span class="see">See <a href="http://www.ecma-international.org/ecma-262/7.0/#sec-white-space"><cite>ECMA-262 7<sup>th</sup> Edition: 11.2 White Space</cite></a>.</span></aside>
	<p>TURF consider the following characters as <dfn>whitespace</dfn>, including characters in the Unicode <code class="name">Space_Separator</code> (<code>Zs</code>) category.</p>
	<ul class="spec-production">
		<li><code class="name">whitespace</code> ⇒ <code class="name">tab</code> | <code class="name">vtab</code> | <code class="name">ff</code> | <code class="name">sp</code> | <code class="name">nbsp</code> | <code class="name">zwnbspr</code> | <code class="name">Space_Separator</code></li>
		<li><code class="name">tab</code> ⇒ <code class="name">CHARACTER TABULATION</code> (<code class="unicode">U+0009</code>)</li>
		<li><code class="name">vtab</code> ⇒ <code class="name">LINE TABULATION</code> (<code class="unicode">U+000B</code>)</li>
		<li><code class="name">ff</code> ⇒ <code class="name">FORM FEED (FF)</code> (<code class="unicode">U+000C</code>)</li>
		<li><code class="name">sp</code> ⇒ <code class="name">SPACE</code> (<code class="unicode">U+0020</code>)</li>
		<li><code class="name">nbsp</code> ⇒ <code class="name">NO-BREAK SPACE</code> (<code class="unicode">U+00A0</code>)</li>
		<li><code class="name">zwnbspr</code> ⇒ <code class="name">ZERO WIDTH NO-BREAK SPACE</code> (<code class="unicode">U+FEFF</code>)</li>
	</ul>
	<h3>Line Endings</h3>
	<p>TURF recognizes both the <code class="name">CARRIAGE RETURN (CR)</code> character (<code class="unicode">U+000D</code>), the <code class="name">LINE FEED (LF)</code> character (<code class="unicode">U+000A</code>), and any Unicode <code class="name">Line_Separator</code> (<code>Zl</code>) or <code class="name">Paragraph_Separator</code> (<code>Zp</code>) character as marking the end of a line. A TURF parser <span class="spec-must">must</span> behave as if every <code class="name">CRLF</code> sequence as well as every <code>CR</code> not followed by a <code class="name">LF</code> were normalized to a single <code class="name">LF</code>. A TURF serializer <span class="spec-should">should</span> use the conventional line ending sequence supported by the platform on which it is running if that sequence is allowed by this specification.</p>
	<ul class="spec-production">
		<li><code class="name">eol</code> ⇒ <code class="name">cr</code> | <code class="name">lf</code> | <code class="name">Line_Separator</code> | <code class="name">Paragraph_Separator</code></li>
		<li><code class="name">cr</code> ⇒ <code class="name">CARRIAGE RETURN (CR)</code> (<code class="unicode">U+000D</code>)</li>
		<li><code class="name">lf</code> ⇒ <code class="name">LINE FEED (LF)</code> (<code class="unicode">U+000A</code>)</li>
	</ul>
	<h3>Comments</h3>
	<h4>Line Comments</h4>
	<p>A line comment <span class="spec-may">may</span> appear before the end of any line. A line comment begins with the <code class="name">EXCLAMATION MARK</code> character <code>!</code> (<code class="unicode">U+0021</code>) and proceeds to the next line ending character.</p>
	<ul class="spec-production">
		<li><code class="name">line_comment</code> ⇒ '!' [^<code class="name">eol</code>]*</li>
	</ul>
	<h3>Filler</h3>
	<aside class="note far third">Most instances of filler appear between items in a <a href="#sequence">sequence</a>.</aside>
	<p>The comments and whitespace that <span class="spec-may">may</span> appear between some structures is referred to as <dfn>filler</dfn>, indicated in this specification using the <code class="name">MIDDLE DOT</code> character <code>·</code>.</p>
	<ul class="spec-production">
		<li>· ⇒ (<code class="name">whitespace</code> | <code class="name">line_comment</code>)*</li>
	</ul>
	<h3>Line Breaks</h3>
	<aside class="tip far third">A parser <span class="spec-may">may</span> simply discard line comments and parse the TURF document as if they were not present.</aside>
	<p>A <dfn>line break</dfn> is any end of line surrounded on either side by filler.</p>
	<ul class="spec-production">
		<li><code class="name">line_break</code> ⇒ · <code class="name">eol</code> ·</li>
	</ul>
	<h3 id="sequence">Sequences</h3>
	<p>Several TURF types allow components to be presented in a <dfn>sequence</dfn>. A sequence is a syntactical construct indicated by the form <code class="name"><var>item</var>-sequence</code>, where <code><var>item</var></code> is the construct that may appear zero or more times in the sequence.</p>
	<aside class="note far third">The sequence separator is a TURF innovation that allows sequences to be represented in compact form using commas in the JSON style, or in a more human-readable format separated by newlines in the YAML style.</aside>
	<p>Any two items in a sequence are separated by a <dfn>sequence separator</dfn>, which is either a <code class="name">COMMA</code> character <code>,</code> (<code class="unicode">U+002C</code>) optionally surrounded by line line breaks; or one or more line breaks without a <code class="name">COMMA</code> character. If a <code class="name">COMMA</code> character is present, an item <span class="spec-must">must</span> follow. <span class="note">This means that one or more line breaks <span class="spec-may">may</span> end a sequence or appear in an empty sequence.</span></p>
	<ul class="spec-production">
		<li><code class="name">item-sequence</code> ⇒ <code class="name">line_break</code>* [ <code class="name">item</code> [ <code class="name">sequence_separator_must</code> <code class="name">item</code> | <code class="name">sequence_separator_may</code> <code class="name">item</code>? ]* ]</li>
		<li><code class="name">sequence_separator_must</code> ⇒ <code class="name">line_break</code>* ',' <code class="name">line_break</code>*</li>
		<li><code class="name">sequence_separator_may</code> ⇒ <code class="name">line_break</code>+</li>
	</ul>
	<h2>Structure</h2>
	<p>A TURF document is divided into two sections: a <dfn>header</dfn> and a <dfn>body</dfn>, both of which are optional. If a header is included, it <span class="spec-must">must</span> appear starting at the first character of the document.</p>
	<ul class="spec-production">
		<li><code class="name">document</code> ⇒ <code class="name">header</code>? <code class="name">body</code>?</li>
	</ul>
	<h3>Header</h3>
	<figure class="far half">
		<figcaption>Example TURF document header.</figcaption>
		<pre class="line-numbers"><code class="language-turf">\URF
! Example TURF document.
\:
  space-dc = &lt;http://purl.org/dc/elements/1.1/&gt;
  space-foaf = &lt;http://xmlns.com/foaf/0.1/&gt;
:

! body of document …</code></pre>
	</figure>
	<h4 id="signature">Signature</h4>
	<p>The header of a document, if present, <span class="spec-must">must</span> begin with a TURF <dfn>signature</dfn>, the character sequence <code>\URF</code> at the beginning of the document. It <span class="spec-may">may</span> optionally be followed, on the same or different line, with a <dfn>directives</dfn> declaration.</p>
	<h4>Directives</h4>
	<p>The directives are a sequence of name-value pairs, with each name an URF handle and a value a TURF literal. <span class="note">The production rules for the description contents are described later in this specification.</span></p>
	<ul class="spec-production">
		<li><code class="name">header</code> ⇒ <code class="name">signature</code> <code class="name">line_break</code>* <code class="name">directives</code>?</li>
		<li><code class="name">signature</code> ⇒ "\URF"</li>
		<li><code class="name">directives</code> ⇒ ':' <code class="name">directive-sequence</code> ';'</li>
		<li><code class="name">directive</code> ⇒ <code class="name">handle</code> <code class="name">line_break</code>* '=' <code class="name">line_break</code>* <code class="name">literal</code></li>
	</ul>
	<p>A directory handle <span class="spec-must-not">must not</span> use a namespace alias prefix. For example a fictional directive <code>foo/bar</code> is not allowed.</p>
	<h5>Namespace Declaration</h5>
	<p>For every directive corresponding a tag in the <code>https://urf.name/space/</code> namespace, the tag name declares a namespace alias prefix to be used with handles within the document body, and the value, which <span class="spec-must">must</span> be an <code>urf-Iri</code> literal, designates the namespace with which the alias is associated.</p>
	<p>For example a directive handle <code>space-dc</code> indicates that <code>dc</code> is to be used as a namespace alias prefix. The example TURF document header in the figure above associates that prefix with the <code>&lt;http://purl.org/dc/elements/1.1/&gt;</code> namespace. Thus if <code>dc/creator</code> were to be used within the body of the example document above, it would indicate the tag <code>&lt;http://purl.org/dc/elements/1.1/creator&gt;</code>.</p>
	<h3>Body</h3>
	<p>The document body contains zero or more <dfn>resources</dfn>, which may recursively contain other resources.</p>
	<h2>Resources</h2>
	<p>A resource consists of an optional <dfn>label</dfn> followed by a <dfn>resource representation</dfn>.</p>
	<ul class="spec-production">
		<li><code class="name">resource</code> ⇒ [<code class="name">label</code>] · <code class="name">resource_representation</code> | <code class="name">label</code></li>
		<li><code class="name">described_resource</code> ⇒ [<code class="name">label</code>] · <code class="name">resource_representation</code> · [<code class="name">description</code>] | <code class="name">label</code></li>
		<li><code class="name">resource_representation</code> ⇒ <code class="name">object</code> | <code class="name">literal</code> | <code class="name">collection</code></li>
		<li><code class="name">literal</code> ⇒ <code class="name">binary</code> | <code class="name">boolean</code> | <code class="name">character</code> | <code class="name">email</code> | <code class="name">iri</code> | <code class="name">number</code> | <code class="name">regex</code> | <code class="name">string</code> | <code class="name">telephone</code> | <code class="name">temporal</code> | <code class="name">uuid</code></li>
		<li><code class="name">collection</code> ⇒ <code class="name">list</code> | <code class="name">map</code> | <code class="name">set</code></li>
	</ul>
	<p> A label consists of an identifier; which is either an URF name, a string, or an IRI; a surrounded by matching <code class="name">VERTICAL LINE</code> characters <code>|</code> (<code class="unicode">U+007C</code>). The first occurrence of a label with a particular identifier <span class="spec-may">may</span> include a resource representation; if no resource representation is present at the first appearance of a label with some identifier, an object with no type and no description is implied. Subsequent appearances of a label with the same identifier <span class="spec-must-not">must not</span> include a resource representation. A nested resource representation <span class="spec-may">may</span> refer to the label of an outer resource in the graph. </p>
	<ul class="spec-production">
		<li><code class="name">label</code> ⇒ '|' <code class="name">alias</code> | <code class="name">id</code> | <code class="name">tag</code> '|'</li>
		<li><code class="name">alias</code> ⇒ <code class="name">name_token</code></li>
		<li><code class="name">id</code> ⇒ <code class="name">string</code></li>
		<li><code class="name">tag</code> ⇒ <code class="name">iri</code></li>
	</ul>
	<p>If a label uses an URF name as its identifier, it indicates an <dfn>alias</dfn> for referencing resources only within the confines of the TURF document. If the identifier is an IRI, it represents the URF <dfn>tag</dfn> of the resource.</p>
	<p>A string as the identifier indicates the URF <dfn>ID</dfn> for a resource. The ID <span class="spec-must">shall</span> be combined with the tag of the resource type to form the resource tag, as prescribed by the URF specification. This implies that an ID <span class="spec-must-not">must not</span> appear in front of any resource representation other than an object, and that the object <span class="spec-must">must</span> indicate a type if an ID is present. Furthermore because of the URF formula for creating resource tags given an ID and a type tag, if a label indicates an ID the object type <span class="spec-must-not">must not</span> itself also indicate an ID.</p>
	<h3>Objects</h3>
	<p>Objects are are general resources with an optional type and that <span class="spec-may">may</span> be described by a description.</p>
	<ul class="spec-production">
		<li><code class="name">object</code> ⇒ '*' · [<code class="name">type</code>]</li>
		<li><code class="name">type</code> ⇒ <code class="name">handle</code></li>
	</ul>
	<h3>Descriptions</h3>
	<p>A description <span class="spec-must-not">must not</span> follow any resource representation other than an object. <span class="annotation">This restriction may be lifted in a future version of TURF.</span> A description <span class="spec-must-not">must not</span> contain more than one <code class="name">property</code> with the same <code class="name">handle</code>, and a TURF parser <span class="spec-must">must</span> consider such a condition as a non-recoverable error.</p>
	<ul class="spec-production">
		<li><code class="name">description</code> ⇒ ':' <code class="name">property-sequence</code> ';'</li>
		<li><code class="name">property</code> ⇒ <code class="name">handle</code> <code class="name">line_break</code>* '=' <code class="name">line_break</code>* <code class="name">resource</code></li>
	</ul>
	<p>TODO update rest of document</p>
	<h2>Signature</h2>
	<p>Every TURF interchange document must begin with the signature character sequence, <code>`URF</code>, which must appear as the first characters of the document after the Byte Order Mark (BOM), if any [<a href="#unicodeBOMFAQ">Unicode BOM FAQ</a>].</p>
	<h2>Grammar</h2>
	<p>The following grammar indicates literals in normal style, variables in emphasized text, and grammar symbols in strong text.</p>
	<p>Any two TURF tokens may be separated by <dfn>filler</dfn>: Unicode separator or Unicode whitespace characters, or a TURF comment, which is a string surrounded by the dagger <code>'†'</code> and double dagger <code>'‡'</code> characters.</p>
	<figure>
		<p><code><var>filler</var> ⇒ Unicode Paragraph Separator <strong>|</strong> Unicode Segment Separator <strong>|</strong> Unicode Whitespace <strong>|</strong> <var>comment</var></code></p>
		<p><code><var>comment</var> ⇒ †"<strong>[</strong><var>Unicode character except double dagger and backslash</var> <strong>|</strong> <var>escapedunicode</var> <strong>|</strong> <var>escapedcontrol</var><strong>]*</strong>‡</code></p>
	</figure>
	<p>Between elements in a list, filler has a caveat: Unicode newline characters [<a href="draft.xhtml#utr13">UTR #13</a>] function as a <dfn>list separator</dfn>, which is at least one newline character and/or at most a single comma character (<code>','</code>), optionally surrounded by other filler characters:</p>
	<figure>
		<p><code><var>listseparator</var> ⇒ Unicode Newline</code><code><strong>+ </strong></code><code><strong>|</strong> ,</code></p>
	</figure>
	<p>A TURF interchange document is encoded in UTF-8 and begins with the TURF signature <code>`URF</code> followed by the description of the instance community, which consists of optional properties and a required community short representation.</p>
	<figure>
		<p><code><var>TURF</var> ⇒ signature <strong>[</strong>:<var>properties</var>;<strong>]</strong> <var>communityshort</var></code></p>
		<p><code><var>signature</var> ⇒ `URF</code></p>
	</figure>
	<p>The community short form, the grammar of which is below, is delimited by the currency character <code>'¤'</code> and the full stop character <code>'.'</code> and contains zero or more resource descriptions, separated by list separators. Each resource description must have at least one of the following optional components, any may have any or all of them: a label, a reference, one or more type short forms, a set of property definitions, a community short form, a proposition form, a list short form, a set short form, and a map short form. <em>No Unicode newline characters are allowed between elements of a resource description.</em></p>
	<figure>
		<p><code><var>resource</var> ⇒ <strong>[</strong><var>label</var><strong>]</strong> <strong>[</strong><var>reference</var><strong>]</strong> <strong>[</strong><var>type</var>s<strong>]</strong> <strong>[</strong><var>superclasses</var><strong>]</strong> <strong>[</strong><var>interfaces</var><strong>]</strong> <strong>[</strong><var>properties</var><strong>]</strong> <strong>[</strong><var>communityshort</var><strong>]</strong> <strong>[</strong><var>propositionshort</var><strong>]</strong> <strong>[</strong><var>listshort</var><strong>]</strong> <strong>[</strong><var>setshort</var><strong>]</strong> <strong>[</strong>mapshort<strong>]</strong></code></p>
	</figure>
	<p>A label consists of a name surrounded by matching vertical bars (<code>'|'</code>).</p>
	<figure>
		<p><code><var>label</var> ⇒ |<var>name</var>|</code></p>
	</figure>
	<p>A name is any letter followed by any number of letters, digits, or connectors such as the underscore character <code>'_'</code>.</p>
	<figure>
		<p><code><var>name</var> ⇒ <var>namebeginchar</var><strong>(</strong><var>namechar</var><strong>)</strong><strong>*</strong></code></p>
		<p><code><var>namebeginchar</var> ⇒ <var>Unicode Letter</var></code></p>
		<p><code><var>namechar</var> ⇒ <var>Unicode Letter</var> <strong>|</strong> <var>Unicode Decimal Digit Number</var> <strong>|</strong> <var>Unicode Connector Punctuation</var></code></p>
	</figure>
	<p>A resource reference is a URI reference, a name reference, or one of several short representations.</p>
	<figure>
		<p><code><var>reference</var> ⇒ <var>urireference</var> <strong>|</strong> <var>namereference</var> <strong>|</strong> <var>urishort</var> <strong>|</strong> <var>stringshort</var> <strong>|</strong> <var>charactershort</var> <strong>|</strong> <var>booleanshort</var> <strong>|</strong> <var>numbershort</var> <strong>|</strong> <var>ordinalshort</var> <strong>|</strong> <var>regexshort</var> <strong>|</strong> <var>temporalshort</var></code></p>
	</figure>
	<p>A resource URI reference is enclosed in angle quotes. The contents is either the text of a URI (or relative reference); or a resource reference to an inline type preceded by an asterisk <code>'*'</code>, immediately followed by a string containing the lexical representation of a resource, surrounded by parentheses <code>'('</code> and <code>')'</code>. If a relative reference is provided, it is resolved against the base URI of the TURF document according to the rules specified in [<a href="#rdfxml">RDF/XML</a>] <cite>5.3 Resolving URIs</cite>. Any URI reference that includes a lexical representation is equivalent to a URI reference in the form <code>«http://urf.name/inline/<var>encodedTypeURI</var>/<var>encodedTURFLexicalForm</var></code>».</p>
	<figure>
		<p><code><var>urireference</var> ⇒ «<strong>(</strong>*<var><var>type</var></var>(<var>stringshort</var>)<strong>)</strong> <strong>|</strong> <strong>(</strong><var>urichar</var><strong>+</strong><strong>)</strong>»</code></p>
		<p><code><var>type</var> ⇒ <var>reference</var></code></p>
	</figure>
	<p>A name reference is a <var>name</var> representing the local name of a resource, optionally preceded by a <var>name</var> ending with the full stop or period character <code>'.'</code>, together representing the URI of a resource. The prefix, if present, must have been associated with a namespace URI in using the tilde character <code>'~'</code> either in the properties of the current resource or one of its subject resources. If no prefix is present for a property, the namespace is the URI of the first type of the subject resource. A prefix must be present in all other name references. The local name is the unencoded form of the fragment to be appended to the namespace URI.</p>
	<figure>
		<p><code><var>namereference</var> ⇒ <strong>[</strong>prefix.<strong>]</strong>localName</code></p>
		<p><code><var>prefix</var> ⇒ <var>name</var></code></p>
		<p><code><var>localName</var> ⇒ <var>name</var></code></p>
	</figure>
	<p>A string short form is a sequence of Unicode characters, using the backslash as an escape character, enclosed in double quotes. The double quotation mark (<code>'"'</code>) and backslash (<code>'\\'</code>) characters must be escaped. A string short form is equivalent to a resource of type <code>urf.String</code> using the corresponding inline namespace. The string short form <code>"example"</code> is the equivalent of the string resource <code>«(urf.String)"example"»</code>.</p>
	<figure>
		<p><code><var>stringshort</var> ⇒ "<strong>[</strong><var>Unicode character except double quote and backslash</var> <strong>|</strong> \" <strong>|</strong> \\ <strong>|</strong> <var>escapedunicode</var> <strong>|</strong> <var>escapedcontrol</var><strong>]*</strong>"</code></p>
	</figure>
	<p>Any Unicode code point may be represented in string and other short representations where indicated by the four lowercase hexadecimal representation following the character sequence <code>"\u"</code>, or if the code point is not in the Basic Multilingual Plane, two such sequences representing UTF-16 surrogate pair.</p>
	<figure>
		<p><code><var>escapedunicode</var> ⇒ \u<var>xxxx</var></code></p>
	</figure>
	<p>Several control characters have escaped forms which can be used in string and other short representations where indicated.</p>
	<figure>
		<p><code><var>escapedcontrol</var> ⇒ \b <strong>|</strong> \t <strong>|</strong> \n <strong>|</strong> \f <strong>|</strong> \r <strong>|</strong> \“ <strong>|</strong> \”</code></p>
		<p><code>\b †\\\u0062‡ ⇒ \u0008 †backspace‡</code></p>
		<p><code>\t †\\\u0074‡ ⇒ \u0009 †character tabulation‡</code></p>
		<p><code>\n †\\\u006e‡ ⇒ \u000a †line feed (LF)‡</code></p>
		<p><code>\f †\\\u0066‡ ⇒ \u000c †form feed (FF)‡</code></p>
		<p><code>\r †\\\u0072‡ ⇒ \u000d †carriage return (CR)‡</code></p>
		<p><code>\“ †\\\u201c‡ ⇒ \u0098 †start of string (SOS)‡</code></p>
		<p><code>\” †\\\u201d‡ ⇒ \u009c †string terminator (ST)‡</code></p>
	</figure>
	<p>A character short form is a single Unicode characters, using the backslash as an escape character, enclosed in a single quote. The single quote (<code>'\''</code>) and backslash (<code>'\\'</code>) characters must be escaped. A character short form is equivalent to a resource of type <code>urf.Character</code> using the corresponding inline namespace. The character short form <code>'x'</code> is the equivalent of the character resource <code>«(urf.Character)"x"»</code>.</p>
	<figure>
		<p><code><var>charactershort</var> ⇒ '<strong>[</strong><var>Unicode character except single quote and backslash</var> <strong>|</strong> \' <strong>|</strong> \\ <strong>|</strong> <var>escapedunicode</var> <strong>|</strong> <var>escapedcontrol</var><strong>]*</strong>'</code></p>
	</figure>
	<p>A URI short form is a sequence of character constituting a syntactically correct URI or a relative reference, surrounded by the angle brackets <code>'&lt;'</code> and <code>'&gt;'</code>. Alternatively, a type and selector may be provided with identical syntax to a resource URI reference. If a relative reference is provided, it is resolved against the base URI of the TURF document according to the rules specified in [<a href="#rdfxml">RDF/XML</a>] <cite>5.3 Resolving URIs</cite>. A URI short form is equivalent to a resource of type <code>urf.URI</code> using the corresponding inline namespace. The URI short form <code>&lt;http://example.com&gt;</code> is the equivalent of the URI resource <code>«(urf.URI)"http://example.com"»</code>.</p>
	<figure>
		<p><code><var>urishort</var> ⇒ &lt;<strong>(</strong>*<var><var>type</var></var>(<var>stringshort</var>)<strong>)</strong> <strong>|</strong> <strong>(</strong><var>urichar</var><strong>+</strong><strong>)</strong>&gt;</code></p>
	</figure>
	<p>A boolean short form is the character sequence <code>true</code> or <code>false</code> surrounded by matching underscore characters <code>'_'</code>. A boolean short form is equivalent to a resource of type <code>urf.Boolean</code> using the corresponding inline namespace. The boolean short form <code>_true_</code> is the equivalent of the boolean resource <code>«(urf.Boolean)"true"»</code>.</p>
	<figure>
		<p><code><var>booleanshort</var> ⇒ _true_<strong>|</strong>_false_</code></p>
	</figure>
	<p>A number short form consists of Roman digits, optionally preceded by a minus sign, with an optional decimal and optional exponent, all surrounded by matching number signs <code>'#'</code>. A number short form is equivalent to a resource of type <code>urf.Integer</code> or <code>urf.Rational</code>, depending on the lexical form used, using the corresponding inline namespace. The number short form <code>#123#</code> is the equivalent of the number resource <code>«(urf.Integer)"123"»</code>, and the number short form <code>#123.45#</code> is the equivalent of the number resource <code>«(urf.Rational)"123.45"»</code>.</p>
	<figure>
		<p><code><var>numbershort</var> ⇒ #<strong>[</strong>-<strong>]</strong><var>n</var><strong>[</strong>.<var>n</var><strong>][</strong>e<strong>(</strong>+<strong>|</strong>-<strong>)</strong><var>n</var><strong>]</strong>#</code></p>
		<p><code><var>n</var> ⇒ <var>romandigit</var><strong>+</strong></code></p>
	</figure>
	<p>An ordinal short form consists of roman digits surrounded by matching ordinal signs <code>'º'</code>. An ordinal short form is equivalent to a resource of type <code>urf.Ordinal</code> using the corresponding inline namespace. The ordinal short form <code>º27º</code> is the equivalent of the ordinal resource <code>«(urf.Ordinal)"27"»</code>.</p>
	<figure>
		<p><code><var>ordinalshort</var> ⇒ º<var>n</var>º</code></p>
	</figure>
	<p>A regular expression short form is a sequence of Unicode characters, using the backslash as an escape character, enclosed in forward slash (<code>'/'</code>) characters. The slash (<code>'/'</code>) and backslash (<code>'\\'</code>) characters must be escaped. A regular expression short form is equivalent to a resource of type <code>urf.RegularExpression</code> using the corresponding inline namespace. The regular expression short form <code>/a?b+c*/</code> is the equivalent of the string resource <code>«(urf.RegularExpression)"a?b+c*"»</code>.</p>
	<figure>
		<p><code><var>regexshort</var> ⇒ /<strong>[</strong><var>Unicode character except slash and backslash</var> <strong>|</strong> \/ <strong>|</strong> \\ <strong>|</strong> <var>escapedunicode</var> <strong>|</strong> <var>escapedcontrol</var><strong>]*</strong>/</code></p>
	</figure>
	<p>A temporal short form consists of the lexical form of a temporal resource such as <code>urf.Date</code>, <code>urf.DateTime</code>, <code>urf.Duration</code>, <code>urf.Time</code>, or <code>urf.UTCOffset</code>, surrounded by matching at signs (<code>'@'</code>). An <code>urf.Duration</code> requires at least the date or the time section to be present. The hours component represents midnight as <code>00</code> and must not have a value larger than <code>23</code>. The UTC offset <code>-00:00</code> is not allowed; <code>+00:00</code> must be used instead. A temporal short form is equivalent to a resource of the corresponding urf.Temporal type, based upon the specific lexical form used. The temporal short form <code>@1999-03-04@</code> is the equivalent of the number resource <code>«(urf.Date)"1999-03-04"»</code>, for example.</p>
	<figure>
		<p><code><var>temporalshort</var> ⇒ @<strong>(</strong><var>YYYY</var>-<var>MM</var>-<var>DD</var><strong>)</strong> <strong>|</strong> <strong>(</strong><var>YYYY</var>-<var>MM</var>-<var>DD</var><code>T<var>hh:</var><var>mm</var>:ss<strong>[</strong>.s<strong>+</strong><strong>]</strong><strong>[</strong><strong>(</strong>+<strong>|</strong>-<strong>)</strong><var>hh</var>:<var>mm</var><strong>]</strong></code><strong>)</strong> <strong>|</strong> <strong>(</strong><var>hh:</var><var>mm</var>:ss<strong>[</strong>.s<strong>+</strong><strong>]</strong><strong>[</strong><strong>(</strong>+<strong>|</strong>-<strong>)</strong><var>hh</var>:<var>mm</var><strong>]</strong><strong>)</strong> <strong>|</strong> <strong>(</strong>P<strong>[</strong><var>n</var>Y<var>n</var>M<var>n</var>D<strong>]</strong><strong>[</strong>T<var>n</var>H<var>n</var>M<var>n</var><strong>[</strong>.<var>n</var><strong>]</strong>S<strong>]</strong><strong>)</strong> <strong>|</strong> <strong>(</strong><strong>(</strong>+<strong>|</strong>-<strong>)</strong><var>hh</var>:<var>mm</var><strong>)</strong>@</code> </p>
	</figure>
	<p>The types declaration consists of one or more resource references, each preceded by an asterisk <code>'*'</code>. Each type reference is equivalent to the reference asserted as the object of the <code>urf.type</code> property. Each type reference may optionally specify comma-separated selector resources between parentheses characters <code>'('</code> and <code>')'</code> following the type reference. The selector resources are equivalent to the values of <code>urf.List</code> value of a scoped <code>urf.selector</code> property in the context of the resource's <code>urf.type</code> property for which the type is a value.</p>
	<figure>
		<p><code><var>types</var> ⇒ <var>typeshort</var><var><strong><strong>*</strong></strong></var></code></p>
		<p><code><var>typeshort</var> ⇒ *<var>typereference</var><strong>[</strong>(<strong>[</strong><var>selectorresource</var><strong>[</strong>,<var>selectorresource</var><strong>]</strong><strong>*</strong><strong>]</strong>)<strong>]</strong></code></p>
		<p><code><var>typereference</var> ⇒ <var>reference</var></code></p>
		<p><code><var>selectorresource</var> ⇒ <var>resource</var></code></p>
	</figure>
	<p>The superclasses declaration consists of one or more resource references, each preceded by a circumflex accent <code>'^'</code>. Each superclass reference is equivalent to the reference asserted as the object of the <code>urf.subClassOf</code> property.</p>
	<figure>
		<p><code><var>superclasses</var> ⇒ <var>superclassshort</var><var><strong><strong>*</strong></strong></var></code></p>
		<p><code><var>superclassshort</var> ⇒ ^<var>reference</var></code></p>
	</figure>
	<p>The interfaces declaration consists of one or more resource references, each preceded by a greater-than symbol <code>'&gt;'</code>. Each interface reference is equivalent to the reference asserted as the object of the <code>urf.implementationOf</code> property.</p>
	<figure>
		<p><code><var>interfaces</var> ⇒ <var>interfaceshort</var><var><strong><strong>*</strong></strong></var></code></p>
		<p><code><var>interfaceshort</var> ⇒ *<var>reference</var></code></p>
	</figure>
	<p>Properties consist of a list of predicate resource and object resource pairs between the color character <code>':'</code> and the semicolon character <code>';'</code>, each separated by the equals sign <code>'='</code>. If the grave character <code>'`'</code> is present before the equals sign, it indicates that the property is scoped in the context of the property's subject resource and its respective predicate resource and subject resource. If a label is provided, it identifies the proposition represented by the reification of the assertion.</p>
	<figure>
		<p><code><var>properties</var> ⇒ :<strong>[</strong><var>property</var><strong>[</strong></code><code>listseparator</code><code> <var>property</var><strong><strong>]*</strong>]</strong>;</code></p>
		<p><code><var>property</var> ⇒ <var>resource</var><strong>[</strong><var>label</var><strong>]</strong><strong>[</strong>`<strong>]</strong>=<strong>(</strong><var>sequenceshort</var><strong>|</strong><var>resource</var><strong>)</strong></code></p>
	</figure>
	<p>A sequence short form consists of a sequence of element resources separated by list separators and surrounded by the backslash character <code>'\\'</code>. Each listed element resource indicates another assertion of the given predicate with the given element resource as the value, each with a contextual property of <code>urf.order</code> with values starting at <code>#0#</code> and continuing sequentially.</p>
	<figure>
		<p><code><var>sequenceshort</var> ⇒ \<strong>[</strong><var>resource</var><strong>[</strong></code><code><var>listseparator</var></code><code> <var>resource</var><strong>]*]</strong>\</code></p>
	</figure>
	<p>A community short form consists of a sequence of resources surrounded by the currency symbol <code>'¤'</code> and the full stop character <code>'.'</code>, separated by list separators. Each listed resource represents an unreified proposition that is a value of the <code>urf.element</code> property. The presence of a community short form implies a type of <code>urf.Community</code> if no other types have yet been specified, either implicitly or explicitly.</p>
	<figure>
		<p><code><var>communityshort</var> ⇒ ¤<strong>[</strong><var>resource</var><strong>[</strong></code><code>listseparator</code><code> <var>resource</var><strong>]*].</strong></code></p>
	</figure>
	<p>A proposition short form lists the subject, predicate, and object of a proposition inside the open double quotation mark <code>'“'</code> and closed double quotation mark <code>'”'</code> characters, separated by list separators. A proposition short form is equivalent to setting the resource <code>urf.Subject</code>, <code>urf.Predicate</code>, and <code>urf.Object</code> propoerties to the three listed resources within the proposition short form. The presence of a proposition short form implies a type of <code>urf.Proposition</code> if no other types have yet been specified, either implicitly or explicitly.</p>
	<figure>
		<p><code><var>propositionshort</var> ⇒ “<var>subject</var> </code><code>listseparator</code><code> <var>predicate</var> </code><code>listseparator</code><code> <var>object</var>”</code></p>
		<p><code><var>subject</var> ⇒ <var>resource</var></code></p>
		<p><code><var>predicate</var> ⇒ <var>resource</var></code></p>
		<p><code><var>object</var> ⇒ <var>resource</var></code></p>
	</figure>
	<p>A list short form consists of a sequence of element resources surrounded by bracket characters <code>'['</code> and <code>']'</code> and separated by list separators. Each listed element resource represents the value of an ordinal index property, in sequence beginning with the ordinal property <code><code>º0º</code></code>. The presence of a list short form implies a type of <code>urf.List</code> if no other types have yet been specified, either implicitly or explicitly.</p>
	<figure>
		<p><code><var>listshort</var> ⇒ [<strong>[</strong>resource<strong>[</strong></code><code>listseparator</code><code> resource<strong>]*]</strong>]</code></p>
	</figure>
	<p>A set short form consists of a sequence of element resources surrounded by curly bracket characters <code>'{'</code> and <code>'}'</code> and separated by list separators. Each listed element resource represents a value of the <code>urf.element</code> property. The presence of a set short form implies a type of <code>urf.Set</code> if no other types have yet been specified, either implicitly or explicitly.</p>
	<figure>
		<p><code><var>setshort</var> ⇒ {<strong>[</strong>resource<strong>[</strong></code><code>listseparator</code><code> resource<strong>]*]</strong>}</code></p>
	</figure>
	<p>A map short form consists of a sequence of key/value associations surrounded by tortoise shell bracket characters <code>'〔'</code> and <code>'〕'</code>. Each key is separated from its value using the equals sign <code>'='</code>, and the key/value combinations are separated by list separators. Each key/value association represents a resource of type <code>urf.MapEntry</code> as a value of the <code>urf.entry</code> property of the map resource, with key a value of the map entry <code>urf.key</code> property, and the value a value of the map entry <code>urf.value</code> property. The presence of a map short form implies a type of <code>urf.Map</code> if no other types have yet been specified, either implicitly or explicitly.</p>
	<figure>
		<p><code><var>mapshort</var> ⇒ 〔<strong>[</strong><var>mapentry</var><strong>[</strong></code><code>listseparator</code><code> <var>mapentry</var><strong><strong>]*</strong>]</strong>〕</code></p>
		<p><code><var>mapentry</var> ⇒ <var>key</var>=<var>value</var></code></p>
		<p><code><var>key</var> ⇒ <var>resource</var></code></p>
		<p><code><var>value</var> ⇒ <var>resource</var></code></p>
	</figure>
	<h2>Examples</h2>
	<h3>JSON</h3>
	<p>In the JavaScript Object Notation (JSON) [<a href="#rfc4627">RFC 4627</a>], every object besides strings, numbers, and booleans are associative arrays using string keys. The following is a complex JSON object, using every JSON data type available:</p>
	<figure>
		<pre><code class="language-json">{
  "length":1234,
  "valid":true,
  "status":"processing",
  "results":[false, 5, "dog", {"code":9.8}]
}</code></pre>
	</figure>
	<p>While this representation has some undesirable traits (e.g. strings are not recommended as general property identifiers except in the case of resources used as maps), the following TURF representation is semantically identical to the JSON example above:</p>
	<figure>
		<pre><code class="language-turf">`URF¤
  :
    "length"=#1234#,
    "valid"=_true_,
    "status"="processing",
    "results"=[_false_, #5#, "dog", :"code"=#9.8#;]
  ;
.</code></pre>
	</figure>
	<p>Note that, unlike JSON, in TURF the commas separating the values are optional if the values appear on separate lines.</p>
	<p>There is one slight semantic descrepancy between these two examples: URF uses a true ordinal property for each list element, while JSON adds each array element as the value of a string containing the lexical form of an integer.</p>
	<p>Although the above TURF representation replicates the simple semantics of the given JSON example, a better formulation that takes advantage of URF semantics would most importantly use actual properties rather than associative array string key pseudo-properties. An improved formulation would also indicate the type of the resources. Such improvements are illustrated in the following reformulation (assuming the <code>"code"</code> string in the list was intended to actually be a key in a map):</p>
	<figure>
		<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "example"~&lt;http://example.com/example/&gt;
;¤
  *example.Class:
    example.length=#1234#
    example.valid=_true_
    example.status="processing"
    example.results=[_false_, #5#, "dog", 〔"code"=#9.8#〕]
  ;
.</code></pre>
	</figure>
	<h3>PLOOP</h3>
	<p>The following TURF example uses URF as <a href="#ploop">PLOOP</a> for the Guise Internet application framework [<a href="#guise">Guise</a>] using the Java programming language. It defines a panel of Guise components that allow temperature to be converted between Celsius and Fahrenheit. (The control listeners and temperature conversion logic would be defined elsewhere.)</p>
	<figure>
		<pre><code class="language-turf">`URF:
  "component"~&lt;java:/com/guiseframework/component/&gt;
  "layout"~&lt;java:/com/guiseframework/component/layout/&gt;
  "validator"~&lt;java:/com/guiseframework/validator/&gt;
  "demo"~&lt;java:/com/guiseframework/demo/&gt;
;¤
  *demo.TemperatureConversionPanel2:
    label="Guise™ Demonstration: Temperature Conversion"
    layout=*layout.FlowLayout:
      flow=«*layout.Flow("LINE")»
    ;
    name="temperatureConversionPanel"
    children=[
      *component.LayoutPanel:
        layout=*layout.FlowLayout:
          flow=«*layout.Flow("PAGE")»
        ;
        name="inputPanel"
        children=[
          *component.TextControl(«java:/java/lang/Double»):
            label="Input Temperature"
            name="temperatureInput"
            validator=*validator.ValueRequiredValidator
          ;
          *component.TextControl(«java:/java/lang/Double»):
            editable=_false_
            label="Output Temperature"
            name="temperatureOutput"
          ;
        ]
      ;,
      *component.LayoutPanel:
        layout=*layout.FlowLayout:
          flow=«*layout.Flow("PAGE")»
        ;
        name="conversionPanel"
        children=[
          *component.GroupPanel:
            label="Input Scale"
            layout=*layout.FlowLayout:
              flow=«*layout.Flow("PAGE")»
            ;
            name="scalePanel"
            children=[
              *component.CheckControl:
                checkType="ellipse"
                label="Calsius"
                name="celsiusCheckControl"
              ;
              *component.CheckControl:
                checkType="ellipse"
                label="Fahrenheit"
                name="fahrenheitCheckControl"
              ;
            ]
          ;
          *component.Button:
            label="Convert"
            name="conversionButton"
          ;
        ]
      ;
    ]
  ;
.</code></pre>
	</figure>
	<p>The preceding example, when processed by an URF PLOOP processor, will produce an object instance graph identical to that produced by the following Java code:</p>
	<figure>
		<pre><code class="language-java">import com.guiseframework.component.*;
import com.guiseframework.component.layout.*;
import com.guiseframework.validator.*;

DefaultNavigationPanel navigationPanel=new DefaultNavigationPanel();
navigationPanel.setName("temperatureConversionPanel");
navigationPanel.setLayout(new FlowLayout(Flow.LINE));
navigationPanel.setLabel("Guise\u2122 Demonstration: Temperature Conversion");

LayoutPanel inputPanel=new LayoutPanel(new FlowLayout(Flow.PAGE));
TextControl&lt;Double&gt; temperatureInput=new TextControl&lt;Double&gt;(Double.class);
temperatureInput.setName("temperatureInput");
temperatureInput.setLabel("Input Temperature");
temperatureInput.setValidator(new ValueRequiredValidator&lt;Double&gt;());
inputPanel.add(temperatureInput);

TextControl&lt;Double&gt; temperatureOutput=temperatureOutput=new TextControl&lt;Double&gt;(Double.class);
temperatureOutput.setName("temperatureOutput");
temperatureOutput.setLabel("Output Temperature");
temperatureOutput.setEditable(false);
inputPanel.add(temperatureOutput);

navigationPanel.add(inputPanel);

LayoutPanel conversionPanel=new LayoutPanel();
conversionPanel.setLayout(new FlowLayout(Flow.PAGE));

GroupPanel scalePanel=new GroupPanel();
scalePanel.setLayout(new FlowLayout(Flow.PAGE));

scalePanel.setLabel("Input Scale");
CheckControl celsiusCheckControl=celsiusCheckControl=new CheckControl();
celsiusCheckControl.setName("celsiusCheckControl");
celsiusCheckControl.setCheckType(CheckControl.CheckType.ELLIPSE);
celsiusCheckControl.setLabel("Celsius");
scalePanel.add(celsiusCheckControl);
CheckControl fahrenheitCheckControl=fahrenheitCheckControl=new CheckControl();
fahrenheitCheckControl.setName("fahrenheitCheckControl");
fahrenheitCheckControl.setCheckType(CheckControl.CheckType.ELLIPSE);
fahrenheitCheckControl.setLabel("Fahrenheit");
scalePanel.add(fahrenheitCheckControl);

conversionPanel.add(scalePanel);

Button convertButton=new Button();
convertButton.setName("conversionButton");
convertButton.setLabel("Convert");
conversionPanel.add(convertButton);
navigationPanel.add(conversionPanel);
</code></pre>
	</figure>
	<h3>RDF/XML</h3>
	<p>URF is a semantic superset of RDF, and can represent any construct available in RDF. URF presents equivalents of many RDF classes as well. In terms of representation formats, TURF can represent any semantic information that is available using [<a href="#rdfxml">RDF/XML</a>], yet is more flexible and has less restrictions. The following is a sample RDF/XML representation of an RDF data instance using many of the capabilities available in RDF/XML:</p>
	<figure>
		<pre><code class="language-xml">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE rdf:RDF [&lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#"&gt;]&gt;
&lt;rdf:RDF
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:example="http://example.com/example/"
  xmlns:foaf="http://xmlns.com/foaf/0.1/"
  xmlns:xhtml="http://www.w3.org/1999/xhtml"
&gt;
  &lt;foaf:Person rdf:about="http://example.com/example#janedoe"&gt;
    &lt;foaf:nick xml:lang="pt-BR"&gt;Janinha&lt;/foaf:nick&gt;
    &lt;example:age rdf:datatype="&amp;xsd;integer"&gt;23&lt;/example:age&gt;
    &lt;example:birthdate rdf:datatype="&amp;xsd;date"&gt;1980-04-05&lt;/example:birthdate&gt;
    &lt;example:motto rdf:parseType="Literal"&gt;Do it. Do it &lt;xhtml:em&gt;right&lt;/xhtml:em&gt;.&lt;/example:motto&gt;
    &lt;example:favoriteSites rdf:parseType="Collection"&gt;
      &lt;rdf:Description rdf:about="http://www.globalmentor.com/"/&gt;
      &lt;rdf:Description rdf:about="http://www.garretwilson.com/"/&gt;
    &lt;/example:favoriteSites&gt;
    &lt;example:possibleVacationDestinations&gt;
      &lt;rdf:Alt&gt;
        &lt;rdf:li&gt;Paris&lt;/rdf:li&gt;
        &lt;rdf:li&gt;Rome&lt;/rdf:li&gt;
      &lt;/rdf:Alt&gt;
    &lt;/example:possibleVacationDestinations&gt;
  &lt;/foaf:Person&gt;
&lt;/rdf:RDF&gt;</code></pre>
	</figure>
	<p>The following URF information represented in TURF is semantically equivalent to the RDF information in the previous example represented in RDF/XML:</p>
	<figure>
		<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "content"~&lt;http://urf.name/content/&gt;
  "dc"~&lt;http://purl.org/dc/elements/1.1/&gt;
  "example"~&lt;http://example.com/example/&gt;
  "foaf"~&lt;http://xmlns.com/foaf/0.1/&gt;
;¤
  example.janedoe*foaf.Person:
    example.age=#23#
    example.birthdate=@1980-04-05@
    example.favoriteSites=[
      «http://www.globalmentor.com/»
      «http://www.garretwilson.com/»
    ],
    example.motto="Do it. Do it &lt;xhtml:em xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"&gt;right&lt;/xhtml:em&gt;.":
      content.type`=«*content.MediaType("text/xml-external-parsed-entity")»
    ;
    example.possibleVacationDestinations={
      "Paris",
      "Rome"
    }
    nick="Janinha":
      dc.language`=«*urf.Language("pt-BR")»
    ;
  ;
.</code></pre>
	</figure>
	<p>Note that, rather than use special literal types or general strings, URF promotes the representation of resources by URIs. Thus the language tag "pt-BR" for Brazilian Portuguese is represented as a resource with a URI in the <code>urf.Language</code> inline namespace, and the integer value <code>23</code> is represented as a resource with a URI in the <code>urf.Integer</code> inline namespace (shown here in its short form, <code>#23#</code>).</p>
	<h3>VCard</h3>
	<p>The URF <a href="#vcard">VCard Ontology</a> provides a representation of VCard [<a href="#rfc2426">RFC 2426</a>] within a semantic framework. The following is VCard information in traditional vCard MIME Directory Profile syntax as specified by [<a href="#rfc2426">RFC 2426</a>].</p>
	<figure>
		<pre><code class="language-vcard">BEGIN:vCard
VERSION:3.0
FN:Jane Doe
N:Doe;Jane;Mary,Ann;Dr.;M.D.,Ph.D.
ORG:Example Corporation;North American Division;Business Development
TITLE:Directory of Business Development
ADR;TYPE=WORK,POSTAL,PARCEL:;Suite 45;123 Some Street;Someplace;CA;12345-6789;USA
LABEL="123 Some Street\nSuite 45\nSomeplace, CA 12345-6789"
TEL;TYPE=PREF;VOICE,WORK:+1-234-567-8910
TEL;TYPE=VOICE,HOME,CELL:+1-234-567-8911
EMAIL;PREF:janedoe@example.com
EMAIL:jdoe@example.org
URL:http://www.example.com/home/jane/
BDAY=1980-02-02T09:45:00
CATEGORY:Internet,B2B,P2P,Web2.0,ABCD
END:vCard</code></pre>
	</figure>
	<p>The same vCard information in its URF VCard formulation is shown below for the resource <code>«http://example.com/example/janedoe»</code>. Note that the URF VCard version provides more semantics by using true classes and properties to describe what [<a href="#rfc2426">RFC 2426</a>] calls <dfn>structured values</dfn>.</p>
	<figure>
		<pre><code class="language-turf">`URF:
  "vcard"~&lt;http://urf.com/vcard/&gt;
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.janedoe:
    vcard.fn="Jane Doe"
    vcard.n=*vcard.Name:
      vcard.familyName="Doe"
      vcard.givenName="Jane"
      vcard.additionalName=\"Mary", "Ann"\
      vcard.honoraryPrefix="Dr."
      vcard.honorarySuffix=\"M.D.", "Ph.D."\
    ;
    vcard.org=\"Example Corporation", "North American Division", "Business Development"\
    vcard.title="Directory of Business Development"
    vcard.adr=*vcard.Adr:
      vcard.adrType=«*vcard.AdrType("work")»
      vcard.adrType=«*vcard.AdrType("postal")»
      vcard.adrType=«*vcard.AdrType("parcel")»
      vcard.extendedAddress="Suite 45"
      vcard.streetAddress="123 Some Street"
      vcard.locality="Someplace"
      vcard.region="CA"
      vcard.postalCode="12345-6789"
      vcard.countryName="USA"
    ;
    vcard.label="123 Some Street\nSuite 45\nSomeplace, CA 12345-6789"
    vcard.tel=
    \
      «tel:+1-234-567-8910»:
        vcard.telType`=«*vcard.TelType("voice")»
        vcard.telType`=«*vcard.TelType("work")»
      ;
      «tel:+1-234-567-8911»:
        vcard.telType`=«*vcard.TelType("voice")»
        vcard.telType`=«*vcard.TelType("home")»
        vcard.telType`=«*vcard.TelType("cell")»
      ;
    \
    vcard.email=\&lt;janedoe@example.com&gt;, &lt;jdoe@example.org&gt;\
    vcard.url=&lt;http://www.example.com/home/jane/&gt;
    vcard.bday=@1980-02-02T09:45:00@
    vcard.category="Internet"
    vcard.category="B2B"
    vcard.category="P2P"
    vcard.category="Web2.0"
    vcard.category="ABCD"
  ;
.</code></pre>
	</figure>
	<h2>References</h2>
	<dl>
		<dt>DCMI Namespace</dt>
		<dd>Andy Powell and Harry Wagner. <a href="http://dublincore.org/documents/dcmi-namespace/"><cite>Namespace Policy for the Dublin Core Metadata Initiative (DCMI)</cite></a>. Dublin Core Namespace Initiative, 2007.</dd>
		<dt>Guise</dt>
		<dd><a href="http://www.guiseframework.com/"><cite>Guise™ Internet Application Framework</cite></a>. GlobalMentor, Inc.</dd>
		<dt>IANA Charset Registry</dt>
		<dd><a href="http://www.iana.org/assignments/character-sets"><cite>IANA Charset Registry</cite></a>. Internet Assigned Numbers Authority.</dd>
		<dt>ISO 8601</dt>
		<dd><cite>ISO 8601:2004(E): Data elements and interchange formats — Information interchange — Representation of dates and times</cite>. International Organization for Standardization, 2004-12-01.</dd>
		<dt>RDF/XML</dt>
		<dd>Dave Beckett. <a href="http://www.w3.org/TR/rdf-syntax-grammar/"><cite>RDF/XML Syntax Specification (Revised)</cite></a>. World Wide Web Consortium, 2006-02-10.</dd>
		<dt id="ref-rfc2046" class="ref-target">RFC 2046</dt>
		<dd><a href="https://tools.ietf.org/html/rfc2046"><cite>Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</cite></a>, N. Freed (Innosoft), N. Borenstein. IETF.</dd>
		<dt id="ref-rfc2119" class="ref-target">RFC 2119</dt>
		<dd><a href="https://tools.ietf.org/html/rfc2119"><cite>Key words for use in RFCs to Indicate Requirement Levels</cite></a>, S. Bradner (Harvard University). IETF.</dd>
		<dt>RFC 2130</dt>
		<dd>C. Weider, C. Preston, K. Simonsen, H. Alvestrand, R. Atkinson, M. Crispin, and P. Svanberg. <a href="http://www.ietf.org/rfc/rfc2278.txt"><cite>RFC 2130: The Report of the IAB Character Set Workshop held 29 February - 1 March, 1996</cite></a>. Internet Engineering Task Force, 1997.</dd>
		<dt>RFC 2278</dt>
		<dd>N. Freed and J. Postel. <a href="http://www.ietf.org/rfc/rfc2278.txt"><cite>RFC 2278: IANA Charset Registration Procedures</cite></a>. Internet Engineering Task Force, 1998.</dd>
		<dt>RFC 2426</dt>
		<dd>F. Dawson and T. Howes. <a href="http://www.ietf.org/rfc/rfc2426.txt"><cite>RFC 2426: vCard MIME Directory Profile</cite></a>. Internet Engineering Task Force, 1998.</dd>
		<dt>RFC 2445</dt>
		<dd>F. Dawson and and D. Stenerson. <a href="http://www.ietf.org/rfc/rfc2426.txt"><cite>RFC 2445: Internet Calendaring and Scheduling Core Object Specification (iCalendar)</cite></a>. Internet Engineering Task Force, 1998.</dd>
		<dt>RFC 3339</dt>
		<dd>G. Klyne and C. Newman. <a href="http://www.ietf.org/rfc/rfc3339.txt"><cite>RFC 3339: Date and Time on the Internet: Timestamps</cite></a>. Internet Engineering Task Force, 2002.</dd>
		<dt>RFC 3966</dt>
		<dd>H. Schulzrinne. <a href="http://www.ietf.org/rfc/rfc3966.txt"><cite>RFC 3966: The tel URI for Telephone Numbers</cite></a>. Internet Engineering Task Force, 2004.</dd>
		<dt>RFC 3986</dt>
		<dd>T. Berners-Lee, R. Fielding, and L. Masinter. <a href="http://www.ietf.org/rfc/rfc3986.txt"><cite>RFC 3986: Uniform Resource Identifier (URI): Generic Syntax</cite></a>. Internet Engineering Task Force, 2005.</dd>
		<dt>RFC 4627</dt>
		<dd>D. Crockford. <a href="http://www.ietf.org/rfc/rfc4627.txt"><cite>RFC 4627: The application/json Media Type for JavaScript Object Notation (JSON)</cite></a>. Internet Engineering Task Force, 2006.</dd>
		<dt>RFC 4646</dt>
		<dd>A. Phillips and M. Davis. <a href="http://www.ietf.org/rfc/rfc4646.txt"><cite>RFC 4646: Tags for Identifying Languages</cite></a>. Internet Engineering Task Force, 2006.</dd>
		<dt>RFC 4648</dt>
		<dd>S. Josefsson. <a href="http://www.ietf.org/rfc/rfc4648.txt"><cite>RFC 4648: The Base16, Base32, and Base64 Data Encodings</cite></a>. Internet Engineering Task Force, 2006.</dd>
		<dt id="ref-rfc6657" class="ref-target">RFC 6657</dt>
		<dd><a href="https://tools.ietf.org/html/rfc6657"><cite>Update to MIME regarding "charset" Parameter Handling in Textual Media Types</cite></a>, A. Melnikov (Isode Limited), J. Reschke (greenbytes). IETF.</dd>
		<dt>Unicode BOM FAQ</dt>
		<dd>Asmus Freytag and Mark Davis. <a href="http://www.unicode.org/unicode/faq/utf_bom.html#BOM"><cite>Unicode Byte Order Mark (BOM) FAQ</cite></a>. Unicode, Inc., Retrieved 2006-06-07.</dd>
		<dt id="ref-utr13" class="ref-target">UTR #13</dt>
		<dd><a href="http://unicode.org/unicode/standard/reports/tr13/tr13-5.html"><cite>Unicode Technical Report #13: Unicode Newline Guidelines</cite><cite></cite></a>, Mark Davis. Unicode, Inc.</dd>
		<dt>XML Schema 2</dt>
		<dd>Paul V. Biron and Ashok Malhotra. <a href="http://www.w3.org/TR/xmlschema-2/"><cite>XML Schema Part 2: Datatypes Second Edition</cite></a>. World Wide Web Consortium, 2004-10-28.</dd>
	</dl>
	<h2>Acknowledgements</h2>
	<p>Brad Neuberg encouraged the creation of an alternate RDF serialization; Frank Manola made convincing arguments for using ordinals instead of integers as list element predicates.</p>
	<h2>History</h2>
	<dl>
		<dt>2017-09-25</dt>
		<dd>
			<ul>
				<li>Split out original URF specification into separate <cite>URF Specification</cite>, <cite>TURF Specification</cite>, and <cite>URF Primer</cite> documents.</li>
			</ul>
		</dd>
		<dt>2009-09-06</dt>
		<dd>
			<ul>
				<li>Change namespace URI rules to only allow namespace URIs that are collection URIs.</li>
				<li>Renamed "lexical namespace/URI" to "inline namespace/URI" and improved the corresponding semantics.</li>
				<li>Renamed <code>urf.Real</code> to <code>urf.Rational</code>.</li>
			</ul>
		</dd>
	</dl>
	<dl>
		<dt>2009-08-24</dt>
		<dd>
			<ul>
				<li>Changed grammar to allow Unicode newline characters as separators.</li>
				<li>Changed TURF content type to <code>text/urf</code>.</li>
			</ul>
		</dd>
	</dl>
	<dl>
		<dt>2008-01-20 </dt>
		<dd>
			<ul>
				<li>Improved semantics of <code>urf.Map</code> by adding map entries to distinguish between properties and map key/value associations.</li>
				<li>Added delimiters for <code>urf.Map</code> TURF short form.</li>
				<li>Changed delimiter of <code>urf.Boolean</code> TURF short form.</li>
				<li>Modified <code>urf.type</code> TURF short form syntax.</li>
				<li>Introduced <code>urf.selector</code> property with TURF short form.</li>
				<li>Removed <code>urf.inits</code> property.</li>
				<li>Documented <code>urf.subClassOf</code> and <code>urf.implementationOf</code> properties.</li>
				<li>Added TURF superclass and interface short forms.</li>
				<li>Renamed <code>content.CharacterEncoding</code> to <code>content.Charset</code>.</li>
			</ul>
		</dd>
		<dt>2007-12-31</dt>
		<dd>
			<ul>
				<li>Added <code>content.CharacterEncoding</code> class.</li>
				<li>Renamed URF reference implementation Java package.</li>
			</ul>
		</dd>
		<dt>2007-12-23</dt>
		<dd>
			<ul>
				<li>Changed TURF preamble delimiters.</li>
				<li>Changed TURF namespace association delimiter.</li>
				<li>Changed syntax for <code>urf.Boolean</code> short form.</li>
				<li>Changed order of string and type in TURF lexical form reference.</li>
				<li>Brought back requirement for ending delimiters for TURF number, temporal, and ordinal short representations to prevent an ambigious grammar.</li>
			</ul>
		</dd>
		<dt>2007-11-22</dt>
		<dd>
			<ul>
				<li>Changed syntax for <code>urf.Boolean</code> short form.</li>
				<li>Changed the TURF preface delimiter.</li>
			</ul>
		</dd>
		<dt>2007-11-18</dt>
		<dd>
			<ul>
				<li>Added TURF preamble.</li>
				<li>Improved TURF name grammar.</li>
				<li>Simplified TURF name namespace inheritance rules.</li>
				<li>Changed <code>urf.MediaType</code> to <code>content.MediaType</code>.</li>
				<li>Simplified PLOOP processing rules.</li>
				<li>Addressed merging of ordered properties.</li>
				<li>Changed syntax for <code>urf.Enum</code> value declarations.</li>
				<li>Introducted <code>urf.Community</code>.</li>
				<li>Reframed semantics of scoped properties in terms of URF communities.</li>
				<li>Added <code>urf.Proposition</code> short form.</li>
				<li>Changed comment syntax.</li>
				<li>Expanded rules for URI namespace determination.</li>
				<li>Changed syntax for <code>urf.Boolean</code> short form.</li>
			</ul>
		</dd>
		<dt>2007-10-16</dt>
		<dd>
			<ul>
				<li>Changed order of TURF properties declaration.</li>
				<li>Added <code>urf.init</code> property.</li>
				<li>Added PLOOP specification.</li>
				<li>Improved and clarified TURF namespace inheritance rules.</li>
				<li>Added list of ontologies along with links to their TURF definitions.</li>
				<li>Added RDF/XML example.</li>
				<li>Added PLOOP example.</li>
				<li>Added reference implementation links.</li>
				<li>Improved and simplified TURF URI and URI reference lexical form representation.</li>
				<li>Clarified and extended <code>urf.Temporal</code> types.</li>
				<li>Changed base lexical namespace URI to <code>&lt;http://urf.name/lexical/&gt;</code>.</li>
				<li>Added <code>urf.Language</code> type.</li>
				<li>Added <code>urf.MediaType</code> type.</li>
				<li>Changed PLOOP example to use <code>java:</code> URIs.</li>
				<li>Removed trailing delimiter from TURF temporal short forms.</li>
				<li>Added <code>urf.Enum</code> description.</li>
			</ul>
		</dd>
		<dt>2007-10-05</dt>
		<dd>
			<ul>
				<li>Added TURF Internet media type.</li>
				<li>Removed requirement that TURF strings must escape control characters.</li>
				<li>Added period to set of name characters.</li>
				<li>Added comments to TURF.</li>
				<li>Clarified and expanded TURF Unicode control escape sequences.</li>
				<li>Clarified and expanded namespace rules.</li>
				<li>Added <code>urf.Binary</code> type.</li>
				<li>Added <code>urf.Ordinal</code> type.</li>
				<li>Changed arrays to use ordinal indexes.</li>
				<li>Removed trailing delimiter from TURF number short forms.</li>
				<li>Removed trailing delimiter from TURF boolean short forms.</li>
				<li>Changed TURF boolean short form delimiter.</li>
				<li>Changed TURF name short form prefix delimiter.</li>
				<li>Changed TURF properties section delimiter.</li>
				<li>Improved TURF name grammar.</li>
				<li>Added <code>urf.Set</code> type.</li>
				<li>Renamed <code>urf.Array</code> to <code>urf.List</code>.</li>
				<li>Clarified TURF name reference namespace inheritance.</li>
			</ul>
		</dd>
		<dt>2007-09-15</dt>
		<dd>
			<ul>
				<li>Switched to <code>info:lexical</code> lexical namespaces.</li>
			</ul>
		</dd>
		<dt>2007-09-14</dt>
		<dd>
			<ul>
				<li>Added name reference short form.</li>
				<li>Modified syntax for sequences.</li>
				<li>Switched to <code>info:lexis</code> lexical namespaces.</li>
				<li>Changed property type for array indexes.</li>
				<li>Clarified number types.</li>
				<li>Added delimiters to boolean and number types.</li>
				<li>Added the ID namespace.</li>
				<li>Clarified array grammar.</li>
				<li>Added URF abstract model grammar.</li>
				<li>Added JSON example.</li>
			</ul>
		</dd>
		<dt>2007-09-08</dt>
		<dd>
			<ul>
				<li>Modified and simplified syntax for resource URI references and type declarations.</li>
				<li>Changed <dfn>contextual properties</dfn> to <dfn>scoped properties</dfn>.</li>
			</ul>
		</dd>
		<dt>2007-09-02</dt>
		<dd>
			<ul>
				<li>First public release of URF.</li>
			</ul>
		</dd>
	</dl>
	<footer><small>Copyright © 2007–2019 <a href="http://www.globalmentor.com/">GlobalMentor, Inc.</a>. All Rights Reserved. Content may not be published or reproduced by any means for any purpose without permission. This specification may be freely used for its intended purpose but only in unmodifed form.</small></footer>
	<script src="../../pub/js/prism.js"></script>
</body>

</html>
