<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
	<meta charset="UTF-8" />
	<meta name="author" content="Garret Wilson" />
	<title>TURF Specification</title>
	<link type="text/css" rel="stylesheet" href="../../pub/css/globalmentor-doc.css" />
</head>

<body>
	<header>
		<h1>Text URF (TURF) Specification</h1>
		<aside class="important far side">Draft version.</aside>
		<dl>
			<dt>Author</dt>
			<dd><a href="http://www.garretwilson.com/" class="external">Garret Wilson</a> (<a href="http://www.globalmentor.com/" class="external">GlobalMentor, Inc.</a>)</dd>
			<dt>Version</dt>
			<dd>Draft 2019-08-31</dd>
		</dl>
	</header>
	<h2>Introduction</h2>
	<p>TURF is the text interchange format for URF. TURF emphasizes terseness and consistency while maintaining human readability, with a preference for using symbols from existing interchange formats such as JSON and programming languages such as Java and C#. TURF has several useful properties, including:</p>
	<ul>
		<li>TURF has an optional signature character sequence, <code>\URF</code>, for easy recognition.</li>
		<li>TURF has an optional unambiguous end delimiter sequence <code>\.</code>, allowing TURF to be embedded in existing text-based content.</li>
		<li>Whitespace separators and comments may be removed with no loss of semantics, resulting in an extremely compact representation.</li>
		<li>Standard delimiters are used, such as <code>{…}</code> for sets, <code>[…]</code> for lists, <code>"…"</code> for strings, <code>&lt;…&gt;</code> for IRIs, and <code>#…</code> for decimal numbers.</li>
	</ul>
	<h3>Conventions Used in this Document</h3>
	<p>The key words “<span class="spec-must">must</span>”, “<span class="spec-must-not">must not</span>”, “<span class="spec-must">required</span>”, “<span class="spec-must">shall</span>”, “<span class="spec-must-not">shall not</span>”, “<span class="spec-should">should</span>”, “<span class="spec-should-not">should not</span>”, “<span class="spec-should">recommended</span>”, “<span class="spec-may">may</span>”, and “<span class="spec-may">optional</span>” in this document are to be interpreted as described in <a href="#ref-rfc2119" class="ref">RFC 2119</a>. Parts of this specification marked as <span class="note">notes</span> and <span class="annotation">annotations</span> are non-normative.</p>
	<h2>Internet Media Type</h2>
	<aside class="note far third">The charset of a TURF document may therefore be deduced by examining the bytes of the document. If those bytes match the TURF signature in some charset, that is the charset of the document; otherwise, the charset is UTF-8.</aside>
	<p>The Internet media type (<a href="#ref-rfc2046" class="ref">RFC 2046</a>, <a href="#ref-rfc6657" class="ref">RFC 6657</a>) of a TURF document <span class="spec-must">shall</span> be <code>text/urf</code> and <span class="spec-must">must</span> be encoded in UTF-8, UTF-16, or UTF-32. A TURF document <span class="spec-must-not">must not</span> begin with a byte order mark (<abbr>BOM</abbr>) or UTF-8 signature. If encoded in any encoding other than UTF-8, a TURF document <span class="spec-must">must</span> begin with a TURF <a href="#signature">signature</a>.</p>
	<p>TURF differs from general <a href="#ref-rfc2046" class="ref">RFC 2046</a> text media types in the following: </p>
	<ul>
		<li>The default charset of TURF is UTF-8 rather that ASCII.</li>
		<li>TURF allows any Unicode newline character (<a href="#ref-utr13" class="ref">UTR #13</a>) to represent newlines rather than only <code>CRLF</code>.</li>
	</ul>
	<p>For any application-specific URF data encoded as TURF <span class="spec-should">should</span> be represented as <code>application/<var>applicationName</var>+turf</code> to allow the data to be recognized as such, where <code><var>applicationName</var></code> is the application-specific identifier for the URF information.</p>
	<h2>Document</h2>
	<p>A TURF <dfn>document</dfn> encodes an <dfn>URF instance</dfn> (TODO reference URF) as one or more graphs of <dfn>resources</dfn> representing URF statements. A TURF document <span class="spec-may">may</span> be contain no resource representations, in which case it representing no URF statements.</p>
	<h2>Syntax</h2>
	<p>The production rules in this specification reference and build upon those already defined in <a href="#ref-urf" class="ref">URF</a></p>
	<h3>Whitespace</h3>
	<aside class="note far third">TURF follows the <cite>ECMAScript® 2016</cite> definition of “WhiteSpace”. <span class="see">See <a href="http://www.ecma-international.org/ecma-262/7.0/#sec-white-space"><cite>ECMA-262 7<sup>th</sup> Edition: 11.2 White Space</cite></a>.</span></aside>
	<p>TURF consider the following characters as <dfn>whitespace</dfn>, including characters in the Unicode <code class="name">Space_Separator</code> (<code>Zs</code>) category.</p>
	<ul class="spec-production">
		<li><code class="name">whitespace</code> ⇒ <code class="name">tab</code> | <code class="name">vtab</code> | <code class="name">ff</code> | <code class="name">sp</code> | <code class="name">nbsp</code> | <code class="name">zwnbspr</code> | <code class="name">Space_Separator</code></li>
		<li><code class="name">tab</code> ⇒ <code class="name">CHARACTER TABULATION</code> (<code class="unicode">U+0009</code>)</li>
		<li><code class="name">vtab</code> ⇒ <code class="name">LINE TABULATION</code> (<code class="unicode">U+000B</code>)</li>
		<li><code class="name">ff</code> ⇒ <code class="name">FORM FEED (FF)</code> (<code class="unicode">U+000C</code>)</li>
		<li><code class="name">sp</code> ⇒ <code class="name">SPACE</code> (<code class="unicode">U+0020</code>)</li>
		<li><code class="name">nbsp</code> ⇒ <code class="name">NO-BREAK SPACE</code> (<code class="unicode">U+00A0</code>)</li>
		<li><code class="name">zwnbspr</code> ⇒ <code class="name">ZERO WIDTH NO-BREAK SPACE</code> (<code class="unicode">U+FEFF</code>)</li>
	</ul>
	<h3>Line Endings</h3>
	<p>TURF recognizes both the <code class="name">CARRIAGE RETURN (CR)</code> character (<code class="unicode">U+000D</code>), the <code class="name">LINE FEED (LF)</code> character (<code class="unicode">U+000A</code>), and any Unicode <code class="name">Line_Separator</code> (<code>Zl</code>) or <code class="name">Paragraph_Separator</code> (<code>Zp</code>) character as marking the end of a line. A TURF parser <span class="spec-must">must</span> behave as if every <code class="name">CRLF</code> sequence as well as every <code>CR</code> not followed by a <code class="name">LF</code> were normalized to a single <code class="name">LF</code>. A TURF serializer <span class="spec-should">should</span> use the conventional line ending sequence supported by the platform on which it is running if that sequence is allowed by this specification.</p>
	<ul class="spec-production">
		<li><code class="name">eol</code> ⇒ <code class="name">cr</code> | <code class="name">lf</code> | <code class="name">Line_Separator</code> | <code class="name">Paragraph_Separator</code></li>
		<li><code class="name">cr</code> ⇒ <code class="name">CARRIAGE RETURN (CR)</code> (<code class="unicode">U+000D</code>)</li>
		<li><code class="name">lf</code> ⇒ <code class="name">LINE FEED (LF)</code> (<code class="unicode">U+000A</code>)</li>
	</ul>
	<h3>Comments</h3>
	<h4>Line Comments</h4>
	<p>A line comment <span class="spec-may">may</span> appear before the end of any line. A line comment begins with the <code class="name">EXCLAMATION MARK</code> character <code>!</code> (<code class="unicode">U+0021</code>) and proceeds to the next line ending character.</p>
	<ul class="spec-production">
		<li><code class="name">line_comment</code> ⇒ '!' [^<code class="name">eol</code>]*</li>
	</ul>
	<h3>Filler</h3>
	<aside class="note far third">Most instances of filler appear between items in a <a href="#sequence">sequence</a>.</aside>
	<p>The comments and whitespace that <span class="spec-may">may</span> appear between some structures is referred to as <dfn>filler</dfn>, indicated in this specification using the <code class="name">MIDDLE DOT</code> character <code>·</code>.</p>
	<ul class="spec-production">
		<li>· ⇒ (<code class="name">whitespace</code> | <code class="name">line_comment</code>)*</li>
	</ul>
	<h3>Line Breaks</h3>
	<aside class="tip far third">A parser <span class="spec-may">may</span> simply discard line comments and parse the TURF document as if they were not present.</aside>
	<p>A <dfn>line break</dfn> is any end of line surrounded on either side by filler.</p>
	<ul class="spec-production">
		<li><code class="name">line_break</code> ⇒ · <code class="name">eol</code> ·</li>
	</ul>
	<h3 id="sequence">Sequences</h3>
	<p>Several TURF types allow components to be presented in a <dfn>sequence</dfn>. A sequence is a syntactical construct indicated by the form <code class="name"><var>item</var>-sequence</code>, where <code><var>item</var></code> is the construct that may appear zero or more times in the sequence.</p>
	<aside class="note far third">The sequence separator is a TURF innovation that allows sequences to be represented in compact form using commas in the JSON style, or in a more human-readable format separated by newlines in the YAML style.</aside>
	<p>Any two items in a sequence are separated by a <dfn>sequence separator</dfn>, which is either a <code class="name">COMMA</code> character <code>,</code> (<code class="unicode">U+002C</code>) optionally surrounded by line line breaks; or one or more line breaks without a <code class="name">COMMA</code> character. If a <code class="name">COMMA</code> character is present, an item <span class="spec-must">must</span> follow. <span class="note">This means that one or more line breaks <span class="spec-may">may</span> end a sequence or appear in an empty sequence.</span></p>
	<ul class="spec-production">
		<li><code class="name">item-sequence</code> ⇒ <code class="name">line_break</code>* [ <code class="name">item</code> [ <code class="name">sequence_separator_must</code> <code class="name">item</code> | <code class="name">sequence_separator_may</code> <code class="name">item</code>? ]* ]</li>
		<li><code class="name">sequence_separator_must</code> ⇒ <code class="name">line_break</code>* ',' <code class="name">line_break</code>*</li>
		<li><code class="name">sequence_separator_may</code> ⇒ <code class="name">line_break</code>+</li>
	</ul>
	<h2>Structure</h2>
	<p>A TURF document is divided into four sections: a <dfn>header</dfn> with optional <dfn>signature</dfn>, a <dfn>document description</dfn>, a <dfn>body</dfn>, and a <dfn>footer</dfn>, each of which is optional. If a footer is included, a header <span class="spec-must">must</span> be included as well..</p>
	<ul class="spec-production">
		<li><code class="name">document</code> ⇒ <code class="name">header</code>? <code class="name">line_break</code>* <code class="name">document_description</code>? <code class="name">line_break</code>* <code class="name">body</code>? <code class="name">line_break</code>* <code class="name">footer</code>? <code class="name">line_break</code>*</li>
	</ul>
	<ul class="spec-production">
	</ul>
	<h3>Header</h3>
	<figure class="far half">
		<figcaption>Example TURF document with optional header, signature, and footer.</figcaption>
		<pre class="line-numbers"><code class="language-turf">\/URF/
  space-dc = &lt;http://purl.org/dc/elements/1.1/&gt;
  space-foaf = &lt;http://xmlns.com/foaf/0.1/&gt;
\

! body of document …

\/./\</code></pre>
	</figure>
	<p>The optional document header begins and ends with a backslash or <code class="name">REVERSE SOLIDUS</code> <code>\</code> (<code class="unicode">U+005C</code>). If a header is included it <span class="spec-must">must</span> appear at the first character of the document. The header <span class="spec-may">may</span> contain <dfn>directives</dfn>, a sequence of name-value pairs that provide serialization details essential for parsing. A TURF parser <span class="spec-must-not">must not</span> return directives as part of the URF instance, but may provide a way to access them separately. <span class="note">The production rules for literals appear later in this specification.</span></p>
	<ul class="spec-production">
		<li><code class="name">header</code> ⇒ '\' <code class="name">signature</code>? <code class="name">directive-sequence</code> '\'</li>
		<li><code class="name">directive</code> ⇒ <code class="name">handle</code> <code class="name">line_break</code>* '=' <code class="name">line_break</code>* <code class="name">literal</code></li>
	</ul>
	<h4 id="signature">Signature</h4>
	<p><em>This section is experimental.</em> If a signature is present, it <span class="spec-must">must</span> appear starting at the first character header. A TURF parser <span class="spec-must">must</span> use the bytes of the signature, or the absence of a signature, to determine the charset and byte order of the document. A TURF parser <span class="spec-may">may</span> use the signature as a heuristic to reasonably determine that some file in fact contains a TURF document.</p>
	<ul class="spec-production">
		<li><code class="name">signature</code> ⇒ "/URF/"</li>
	</ul>
	<h4>Directives</h4>
	<h5>Namespace Declaration</h5>
	<p>For every directive corresponding to a tag in the <code>https://urf.name/space/</code> namespace, the tag name declares a namespace alias prefix to be used with handles within the document body, and the value, which <span class="spec-must">must</span> be an <code>urf-Iri</code> literal, designates the namespace with which the alias is associated. A TURF serializer <span class="spec-must">must</span> generate a header containing appropriate namespace declarations for all custom namespaces used in the document.</p>
	<p>For example a directive handle <code>space-dc</code> indicates that <code>dc</code> is to be used as a namespace alias prefix. The example TURF document header in the figure above associates that prefix with the <code>&lt;http://purl.org/dc/elements/1.1/&gt;</code> namespace. Thus if <code>dc/creator</code> were to be used within the body of the example document above, it would indicate the tag <code>&lt;http://purl.org/dc/elements/1.1/creator&gt;</code>.</p>
	<h3>Document Description</h3>
	<figure class="far half">
		<figcaption>Example TURF document with a document description.</figcaption>
		<pre class="line-numbers"><code class="language-turf">\
  space-dc = &lt;http://purl.org/dc/elements/1.1/&gt;
\
#
  dc/title = "Example Document"
  dc/creator = "Jane Doe"
#

! body of document …</code></pre>
	</figure>
	<p><em>This section is experimental.</em> The optional document description provides a description of the document contents, separate from its serialization and independent of the represented URF graph. The document description begins and ends with the <code class="name">NUMBER SIGN</code> <code>#</code> (<code class="unicode">U+0023</code>), and contains a sequence of name-value pairs. A TURF parser <span class="spec-must-not">must not</span> return the document description as part of the URF instance graph, but <span class="spec-should">should</span> provide some means for it to be retrieved after parsing is finished.</p>
	<ul class="spec-production">
		<li><code class="name">document_description</code> ⇒ '#' <code class="name">document_property-sequence</code> '#'</li>
		<li><code class="name">document_property</code> ⇒ <code class="name">handle</code> <code class="name">line_break</code>* '=' <code class="name">line_break</code>* <code class="name">literal</code></li>
	</ul>
	<h3>Body</h3>
	<p>The document body contains zero or more <dfn>resources</dfn>, which may recursively contain other resources.</p>
	<h3>Footer</h3>
	<aside class="annotation far third">It is anticipated that a future version of this specification will allow multiple TURF documents to be serialized in a stream using the <code>\/.../\</code> separator, forming the basis of a message stream, for example.</aside>
	<p><em>This section is experimental.</em> The document footer, if present, explicitly indicates the end of the TURF document.</p>
	<ul class="spec-production">
		<li><code class="name">footer</code> ⇒ "\/./\"</li>
	</ul>
	<h2>Resources</h2>
	<p>A resource consists of an optional <dfn>label</dfn> followed by a <dfn>resource representation</dfn>.</p>
	<ul class="spec-production">
		<li><code class="name">resource</code> ⇒ <code class="name">label</code>? · <code class="name">resource_representation</code> | <code class="name">label</code></li>
		<li><code class="name">described_resource</code> ⇒ <code class="name">label</code>? · <code class="name">resource_representation</code> · <code class="name">description</code>? | <code class="name">label</code></li>
		<li><code class="name">resource_representation</code> ⇒ <code class="name">handle</code> · <code class="name">object</code>? | <code class="name">object</code> | <code class="name">literal</code> | <code class="name">collection</code></li>
		<li><code class="name">literal</code> ⇒ <code class="name">binary</code> | <code class="name">boolean</code> | <code class="name">character</code> | <code class="name">email</code> | <code class="name">iri</code> | <code class="name">number</code> | <code class="name">regex</code> | <code class="name">string</code> | <code class="name">telephone</code> | <code class="name">temporal</code> | <code class="name">uuid</code></li>
		<li><code class="name">collection</code> ⇒ <code class="name">list</code> | <code class="name">map</code> | <code class="name">set</code></li>
	</ul>
	<p> A label consists of an identifier; which is either an URF name, a string, or an IRI; a surrounded by matching <code class="name">VERTICAL LINE</code> characters <code>|</code> (<code class="unicode">U+007C</code>). The first occurrence of a label with a particular identifier <span class="spec-may">may</span> include a resource representation; if no resource representation is present at the first appearance of a label with some identifier, an object with no type and no description is implied. Subsequent appearances of a label with the same identifier <span class="spec-must-not">must not</span> include a resource representation. A nested resource representation <span class="spec-may">may</span> refer to the label of an outer resource in the graph.</p>
	<p>The tokens <code>false</code> and <code>true</code> <span class="spec-must-not">must not</span> appear as handles in a TURF document.</p>
	<ul class="spec-production">
		<li><code class="name">label</code> ⇒ <code class="name">alias_label</code> | <code class="name">id_label</code> | <code class="name">tag_label</code></li>
		<li><code class="name">alias_label</code> ⇒ '|' <code class="name">alias</code> '|'</li>
		<li><code class="name">id_label</code> ⇒ '|' <code class="name">id</code> '|'</li>
		<li><code class="name">tag_label</code> ⇒ '|' <code class="name">tag</code> '|'</li>
		<li><code class="name">alias</code> ⇒ <code class="name">name_token</code></li>
		<li><code class="name">id</code> ⇒ <code class="name">string</code></li>
		<li><code class="name">tag</code> ⇒ <code class="name">iri</code></li>
	</ul>
	<p>If a label uses an URF name as its identifier, it indicates an <dfn>alias</dfn> for referencing resources only within the confines of the TURF document. If the identifier is an IRI, it represents the URF <dfn>tag</dfn> of the resource. A tag label <span class="spec-must-not">must not</span> introduce any resource representation that itself represents a tag, such as a literal or an object represented by a handle.</p>
	<p>A string as the identifier indicates the URF <dfn>ID</dfn> for a resource. The ID <span class="spec-must">shall</span> be combined with the tag of the resource type to form the resource tag, as prescribed by the URF specification. This implies that an ID <span class="spec-must-not">must not</span> appear in front of any resource representation other than an object; and if an ID is present an object <span class="spec-must">must</span> indicate a type and <span class="spec-must-not">must not</span> be represented by a handle. Furthermore because of the URF formula for creating resource tags given an ID and a type tag, if a label indicates an ID the object type <span class="spec-must-not">must not</span> itself also indicate an ID.</p>
	<h3>Objects</h3>
	<p>Objects are are general resources with an optional type and that <span class="spec-may">may</span> be described by a description.</p>
	<ul class="spec-production">
		<li><code class="name">object</code> ⇒ '*' · <code class="name">type</code>?</li>
		<li><code class="name">type</code> ⇒ <code class="name">tag_reference</code></li>
		<li><code class="name">tag_reference</code> ⇒ <code class="name">tag_label</code> | <code class="name">handle</code></li>
	</ul>
	<p>If a type is indicated, it represents an URF statement with the object as the subject and the identified type as the value of the <code>urf-type</code> property. If preceded by a tag reference (that is, a tag label or a equivalently a handle introduces the object), the indicated tag serves as the tag of the object.</p>
	<h3>Descriptions</h3>
	<aside class="annotation far third">The representation of n-ary property handles combined with syntax of TURF property assignment conveniently results in the form <code class="langauge-turf">foo+="bar"</code> which reflects the addition assignment operator <code>+=</code> in programming languages such as C/C++.</aside>
	<p>A description <span class="spec-must-not">must not</span> follow any resource representation other than an object. <span class="annotation">This restriction may be lifted in a future version of TURF.</span> A description <span class="spec-must-not">must not</span> contain more than one <code class="name">property</code> with the same <code class="name">handle</code>, and a TURF parser <span class="spec-must">must</span> consider such a condition as a non-recoverable error. (TODO lift restriction here and in SURF for JSON compatibility) A TURF parser must preserve all distinct values of each n-ary property.</p>
	<ul class="spec-production">
		<li><code class="name">description</code> ⇒ ':' <code class="name">property-sequence</code> ';'</li>
		<li><code class="name">property</code> ⇒ <code class="name">tag_reference</code> <code class="name">line_break</code>* ('=' <code class="name">line_break</code>* <code class="name">resource</code>) | <code class="name">description</code></li>
	</ul>
	<p>A TURF parser <span class="spec-must">must</span> interpret a description appearing immediately after the property tag reference as if an object with no type appeared as the resource in the property production. For example the property <code>foo:…;</code> is the short-hand equivalent of <code>foo=*:…;</code>.</p>
	<h3>Literals</h3>
	<p>TURF <dfn>literals</dfn> are lexical representations of tagged resources with lexical ID types. <span class="note">Any TURF literal can also be represented by indicating the resource's lexical representation in an ID label as     explained above. The literal <code>1.23</code> can also be represented as <code>|"1.23"|*urf-Number</code>, for example. If the resource canonical lexical representation is also an URF name, it may even be represented as a handle. For example the literal "<code>foo"</code> can be represented as <code>urf-String#foo</code>.</span></p>
	<p>The following definitions in many cases delegate to the respective URF definitions of the canonical lexical representations for the respective types. The summaries of the URF canonical lexical representations when given are for informational purposes only. In addition a production rule may refer to the canonical lexical representation of an URF type. For example <code class="name">urf-EmailAddress_lex</code> refers the canonical lexical representation of the <code>urf-EmailAddress</code> type.</p>
	<h4>Binary</h4>
	<aside class="annotation far side">TURF uses the binary delimiter <code>%</code> because it resembles <code>0</code> and <code>1</code>.</aside>
	<p>The TURF binary literal representation for resources with the <code>urf-Binary</code> type begins with the <code class="name">PERCENT SIGN</code> character <code>%</code> (<code class="unicode">U+0025</code>) and is followed by the canonical lexical representation. <span class="info">As defined by URF, the canonical lexical representation for <code>urf-Binary</code> is zero or more bytes be encoded using the “Base 64 Encoding” defined in <a href="#ref-rfc4648" class="ref">RFC 4648</a>, beginning with the <code class="name">PERCENT SIGN</code> character <code>%</code> (<code class="unicode">U+0025</code>), using “base64url” alphabet with no Base 64 padding.</span></p>
	<ul class="spec-production">
		<li><code class="name">binary</code> ⇒ '%' <code class="name">urf-Binary_lex</code></li>
	</ul>
	<h4>Boolean</h4>
	<p>The TURF literal representation of <code>urf-Boolean</code> resources is simply the canonical lexical representation of the resource: <span class="info">either of the tokens <code>true</code> or <code>false</code></span>.</p>
	<ul class="spec-production">
		<li><code class="name">boolean</code> ⇒ <code class="name">urf-Boolean_lex</code></li>
	</ul>
	<h4>Character</h4>
	<p>The TURF literal representation for an <code>urf-Character</code> resource is the Unicode character being represented, delimited on both sides by the <code class="name">APOSTROPHE</code> character <code>'</code> (<code class="unicode">U+0027</code>). The backslash or <code class="name">REVERSE SOLIDUS</code> <code>\</code> (<code class="unicode">U+005C</code>) is used as as an escape character. The <code class="name">APOSTROPHE</code> , <code class="name">REVERSE SOLIDUS</code>, and control characters <span class="spec-must-not">must not</span> appear in a character unless they are escaped. The following escape sequences are allowed:</p>
	<dl>
		<dt><code>\\</code></dt>
		<dd><code class="name">REVERSE SOLIDUS</code> (<code class="unicode">U+005C</code>)</dd>
		<dt><code>\/</code></dt>
		<dd><code class="name">SOLIDUS</code> (<code class="unicode">U+002F</code>)</dd>
		<dt><code>\'</code></dt>
		<dd><code class="name">APOSTROPHE</code> (<code class="unicode">U+0027</code>)</dd>
		<dt><code>\b</code></dt>
		<dd><code class="name">BACKSPACE</code> (<code class="unicode">U+0008</code>)</dd>
		<dt><code>\f</code></dt>
		<dd><code class="name">FORM FEED (FF)</code> (<code class="unicode">U+000C</code>)</dd>
		<dt><code>\n</code></dt>
		<dd><code class="name">LINE FEED (LF)</code> (<code class="unicode">U+000A</code>)</dd>
		<dt><code>\r</code></dt>
		<dd><code class="name">CARRIAGE RETURN (CR)</code> (<code class="unicode">U+000D</code>)</dd>
		<dt><code>\t</code></dt>
		<dd><code class="name">CHARACTER TABULATION</code> (<code class="unicode">U+0009</code>)</dd>
		<dt><code>\v</code></dt>
		<dd><code class="name">LINE TABULATION</code> (<code class="unicode">U+000B</code>)</dd>
		<dt><code>\u<var>XXXX</var></code></dt>
		<dd>Any 16-bit Unicode code point encoding, where <var><code>XXXX</code></var> is four hexadecimal digits in any case. Escaped Unicode code points outside the Basic Multilingual Plane <span class="spec-must">must</span> be represented as two UTF-16 surrogate characters.</dd>
	</dl>
	<p>A TURF parser <span class="spec-must">must</span> correctly interpret characters outside the Basic Multilingual Plane, whether represented as a literal character or as an escaped Unicode code point.</p>
	<p> TODO production</p>
	<ul class="spec-production">
	</ul>
	<h4>Email Address</h4>
	<aside class="annotation far side">The caret delimiter indicating an email address resembles the paper airplane symbol representing “send email” in many user interfaces.</aside>
	<p>An email address literal for the <code>urf-EmailAddress</code> type begins with the <code class="name">CIRCUMFLEX ACCENT</code> character <code>^</code> (<code class="unicode">U+005E</code>) <span class="note">commonly known as a “caret”</span>, followed by the URF canonical lexical representation: <span class="info">the “addr-spec” format specified in <a href="#ref-rfc5322" class="ref">RFC 5322</a>, without any obsolete elements, comments or folding white space</span>.</p>
	<ul class="spec-production">
		<li><code class="name">email</code> ⇒ '^' <code class="name">urf-EmailAddress_lex</code></li>
	</ul>
	<h4>IRI</h4>
	<aside class="annotation far third"><a href="#ref-rfc3986" class="ref">RFC 3986</a> mentions that angle brackets are a common way to delimit URIs.</aside>
	<p>The literal representation of <code>urf-Iri</code> is the canonical lexical representation for that type (<span class="info">from <a href="#ref-rfc3987" class="ref">RFC 3987</a></span>) placed between a <code class="name">LESS-THAN SIGN</code> character <code>&lt;</code> (<code class="unicode">U+003C</code>) and a <code class="name">GREATER-THAN SIGN</code> character <code>&gt;</code> (<code class="unicode">U+003E</code>).</p>
	<ul class="spec-production">
		<ul>
			<li><code class="name">iri</code> ⇒ '&lt;' ( <code class="name">urf-Iri_lex</code> | <code class="name">email</code> | <code class="name">telephone</code> | <code class="name">uuid</code> ) '&gt;'</li>
		</ul>
	</ul>
	<p> If an email address, telephone number, or UUID appears between the delimiters, it represents an “IRI short form” that is equivalent to a literal IRI according to the following rules:</p>
	<dl>
		<dt><code class="name">email</code></dt>
		<dd>The email address is converted into an IRI with a scheme of <code>mailto</code> according to <a href="#ref-rfc3987" class="ref">RFC 6068</a>.</dd>
		<dt><code class="name">telephone</code></dt>
		<dd>The telephone is converted into an IRI with a scheme of <code>tel</code> according to <a href="#ref-rfc3966" class="ref">RFC 3966</a>.</dd>
		<dt><code class="name">uuid</code></dt>
		<dd>The UUID is converted into a IRI with a scheme of <code>urn</code> and a URN namespace of <code>uuid</code> according to <a href="#ref-rfc4122" class="ref">RFC 4122</a>.</dd>
	</dl>
	<h4>Number</h4>
	<aside class="note far third">Non-decimal TURF numbers are compatible with JSON numbers, except that TURF allows leading zeros. <span class="see">See <a href="#ref-rfc7159" class="ref">RFC 7159</a>.</span></aside>
	<p>There are several related literal representations for the <code>urf-Number</code> type and its subclasses. The TURF literal production rules are more lenient than the corresponding URF canonical representations, and <span class="spec-must">must</span> be normalized. The general production rule for the <code>urf-Number</code> types is a base 10 representation that <span class="spec-may">may</span> be negative and <span class="spec-may">may</span> be fractional.</p>
	<p>If the literal begins with the <code class="name">DOLLAR SIGN</code> character <code>$</code> (<code class="unicode">U+0024</code>), it represents an <code>urf-Decimal</code> instance. A TURF parser <span class="spec-must">must</span> represent a decimal instance exactly without rounding within the supported range. Specifically a TURF parser <span class="spec-must-not">must not</span> represent decimal numbers using <a href="#ref-ieee754" class="ref">IEEE 754</a>.</p>
	<aside class="annotation far third">While JSON only has a single “number” type, its specification is sufficiently broad as to allow implementations to distinguish between integer and non-integer types based upon the presence of a decimal and/or exponent—and indeed some pure JSON implementations already make this distinction. <span class="see">See <a href="#ref-rfc7159" class="ref">RFC 7159</a>.</span></aside>
	<p>If the literal does not begin with the <code class="name">DOLLAR SIGN</code> character <code>$</code> (<code class="unicode">U+0024</code>) it represents an instance of <code>urf-Number</code> unless it contains neither a fraction nor an exponent component, in which case it represents an instance of <code>urf-Integer</code>.</p>
	<ul class="spec-production">
		<li><code class="name">number</code> ⇒ ['$'] ['-'] <code class="name">whole</code> [<code class="name">fraction</code>] [<code class="name">exponent</code>]</li>
		<li><code class="name">whole</code> ⇒ <code class="name">digit</code>+</li>
		<li><code class="name">fraction</code> ⇒ '.' <code class="name">digit</code>+</li>
		<li><code class="name">exponent</code> ⇒ ('e' | 'E') ['-' | '+'] <code class="name">digit</code>+</li>
		<li><code class="name">digit</code> ⇒ '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'</li>
	</ul>
	<p>A number literal <span class="spec-should">should</span> be in its canonical form:</p>
	<ul>
		<li>No leading zeros in the <code class="name">whole</code> component except to meet the requirement of at least one digit.</li>
		<li>No trailing zeros in the digit(s) in the <code class="name">fraction</code> component except to meet the requirement of at least one digit.</li>
		<li>No leading zeros in the digit(s) in the <code class="name">exponent</code> component.</li>
		<li>A lowercase <code>'e'</code> in the <code class="name">exponent</code> component.</li>
	</ul>
	<p>Nevertheless the presence of any leading zero(s) in the <code class="name">whole</code> component <span class="spec-must-not">shall not</span> be interpreted as indicating any other number base other than base 10.</p>
	<h4>Regular Expression</h4>
	<aside class="note far third">TURF regular expressions are syntactically identical to those defined in <cite>ECMAScript® 2016</cite>, except that TURF allows empty regular expressions. <span class="see">See <a href="http://www.ecma-international.org/ecma-262/7.0/#sec-literals-regular-expression-literals"><cite>ECMA-262 7<sup>th</sup> Edition: 11.8.5 Regular Expression Literals</cite></a>.</span></aside>
	<p>The TURF literal representation for an <code>urf-RegularExpression</code> is its URF canonical lexical representation surrounded by slash or <code class="name">SOLIDUS</code> character <code>/</code> (<code class="unicode">U+002F</code>). The backslash or <code class="name">REVERSE SOLIDUS</code> <code>\</code> (<code class="unicode">U+005C</code>) is interpreted as as an escape character only if followed by a slash character <code>/</code>.</p>
	<p>TODO decide on whether and how to allow flags</p>
	<ul class="spec-production">
		<li><code class="name">regex</code> ⇒ '/' <code class="name">urf-RegularExpression_lex</code> '/'</li>
	</ul>
	<h4>String</h4>
	<aside class="note far third">Compare to <a href="#ref-rfc7159" class="ref">RFC 7159</a>.</aside>
	<p>An <code>urf-String</code> literal is its URF canonical lexical representation, escaped as necessary, and delimited on both sides by the <code class="name">QUOTATION MARK</code> character <code>"</code> (<code class="unicode">U+0022</code>). The sequence of Unicode code points in a string <span class="spec-should">should</span> follow <code class="name">Normalization Form C</code> (<code>NFC</code>) as per <a href="#ref-uax15" class="ref">UAX #15</a>. The backslash or <code class="name">REVERSE SOLIDUS</code> <code>\</code> (<code class="unicode">U+005C</code>) is used as as an escape character. The <code class="name">QUOTATION MARK</code> , <code class="name">REVERSE SOLIDUS</code>, and control characters <span class="spec-must-not">must not</span> appear in a string unless they are escaped. The following escape sequences are allowed:</p>
	<dl>
		<dt><code>\\</code></dt>
		<dd><code class="name">REVERSE SOLIDUS</code> (<code class="unicode">U+005C</code>)</dd>
		<dt><code>\/</code></dt>
		<dd><code class="name">SOLIDUS</code> (<code class="unicode">U+002F</code>)</dd>
		<dt><code>\"</code></dt>
		<dd><code class="name">QUOTATION MARK</code> (<code class="unicode">U+0022</code>)</dd>
		<dt><code>\b</code></dt>
		<dd><code class="name">BACKSPACE</code> (<code class="unicode">U+0008</code>)</dd>
		<dt><code>\f</code></dt>
		<dd><code class="name">FORM FEED (FF)</code> (<code class="unicode">U+000C</code>)</dd>
		<dt><code>\n</code></dt>
		<dd><code class="name">LINE FEED (LF)</code> (<code class="unicode">U+000A</code>)</dd>
		<dt><code>\r</code></dt>
		<dd><code class="name">CARRIAGE RETURN (CR)</code> (<code class="unicode">U+000D</code>)</dd>
		<dt><code>\t</code></dt>
		<dd><code class="name">CHARACTER TABULATION</code> (<code class="unicode">U+0009</code>)</dd>
		<dt><code>\v</code></dt>
		<dd><code class="name">LINE TABULATION</code> (<code class="unicode">U+000B</code>)</dd>
		<dt><code>\u<var>XXXX</var></code></dt>
		<dd>Any 16-bit Unicode code point encoding, where <var><code>XXXX</code></var> is four hexadecimal digits in any case. Escaped Unicode code points outside the Basic Multilingual Plane <span class="spec-must">must</span> be represented as two UTF-16 surrogate characters.</dd>
	</dl>
	<p> TODO production</p>
	<h4>Telephone</h4>
	<aside class="annotation far half"><cite>RFC 3966</cite> allows visual separators as an aid to remembering URIs. TURF's focus is representing information and thus forgoes separators in the interest of simplicity.</aside>
	<p>The literal representation of <code>urf-TelephoneNumber</code> is exactly its URF canonical lexical form: <span class="info">the format prescribed by <a href="#ref-rfc3966" class="ref">RFC 3966</a>, which is a <code class="name">PLUS SIGN</code> <code>+</code> (<code class="unicode">U+002B</code>), followed by at least one digit, with no visual separators</span>. The presence of the beginning <code class="name">PLUS SIGN</code> provides a built-in TURF delimiter.</p>
	<figure class="far half">
		<figcaption>Example TURF telephone number.</figcaption>
		<ul>
			<li><code class="language-turf">+12015550123</code></li>
		</ul>
	</figure>
	<ul class="spec-production">
		<li><code class="name">telephone</code> ⇒ <code class="name">urf-TelephoneNumber_lex</code></li>
	</ul>
	<h4>Temporal</h4>
	<figure class="far half">
		<figcaption>Example TURF temporal literals.</figcaption>
		<ul>
			<li><code class="language-turf">@2017-02-12T23:29:18.829Z</code></li>
			<li><code class="language-turf">@2017-02-12T15:29:18.829-08:00[America/Los_Angeles]</code></li>
			<li><code class="language-turf">@2017-02-12T15:29:18.829-08:00</code></li>
			<li><code class="language-turf">@2017-02-12-08:00</code></li>
			<li><code class="language-turf">@15:29:18.829-08:00</code></li>
			<li><code class="language-turf">@2017-02-12T15:29:18.829</code></li>
			<li><code class="language-turf">@2017-02-12</code></li>
			<li><code class="language-turf">@15:29:18.829</code></li>
			<li><code class="language-turf">@2017-02</code></li>
			<li><code class="language-turf">@--02-12</code></li>
			<li><code class="language-turf">@2017</code></li>
		</ul>
	</figure>
	<p>The TURF literal representations for the <code>urf-Temporal</code> types are each identical to the URF canonical lexical representation for the respective type, with a prefix of the <code class="name">COMMERCIAL AT</code> character <code>@</code> (<code class="unicode">U+0040</code>). <span class="info">The URF canonical lexical representations for the most part comply with <a href="#ref-iso8601" class="ref">ISO 8601</a>, with time zones from the IANA <a href="#ref-iso8601" class="ref">TZ</a> database represented following <a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_ZONED_DATE_TIME" class="external"><code>java.time.format.DateTimeFormatter.ISO_ZONED_DATE_TIME</code></a>.</span></p>
	<h4>UUID</h4>
	<aside class="annotation far side">The ampersand character &amp; was chosen for UUIDs because it recalls the address-of operator of C/C++.</aside>
	<p>A TURF literal for the <code>urf-Uuid</code> type is the <code class="name">AMPERSAND</code> character <code>&amp;</code> (<code class="unicode">U+0026</code>) followed by its URF canonical lexical representation: <span class="info">the “UUID” production of <a href="#ref-rfc4122" class="ref">RFC 4122</a></span>.</p>
	<figure class="far third">
		<figcaption>Example SURF UUID.</figcaption>
		<ul>
			<li><code class="language-turf">&amp;f81d4fae-7dec-11d0-a765-00a0c91e6bf6</code></li>
		</ul>
	</figure>
	<ul class="spec-production">
		<li><code class="name">uuid</code> ⇒ '&amp;' <code class="name">urf-Uuid_lex</code></li>
	</ul>
	<h3>Collections</h3>
	<p>Collections represent the <code>urf-Collection</code> abstract data types that can hold other resources.</p>
	<h4>List</h4>
	<p>A TURF list represents an instance of <code>urf-List</code> using an order-significant sequence of zero or more element resources with optional descriptions, beginning with a <code class="name">LEFT SQUARE BRACKET</code> character <code>[</code> (<code class="unicode">U+005B</code>) and ending with a <code class="name">RIGHT SQUARE BRACKET</code> character <code>]</code> (<code class="unicode">U+005D</code>).</p>
	<ul class="spec-production">
		<li><code class="name">list</code> ⇒ '[' <code class="name">element-sequence</code> ']'</li>
		<li><code class="name">element</code> ⇒ <code class="name">described_resource</code></li>
	</ul>
	<p>Each element represents an URF statement in which the <code>urf-List</code> instance is the subject, the identified resource is the property value, and the statement property is an instance of <code>urf-Ordinal</code> reflecting the zero-based position of the element within the list. TODO define urf-Ordinal in URF and in TURF</p>
	<h4>Map</h4>
	<p>A TURF map represents an instance of <code>urf-Map</code> using a sequence of associations between a key and a value. A TURF map begins a <code class="name">LEFT CURLY BRACKET</code> character <code>{</code> (<code class="unicode">U+007B</code>) and ends with a <code class="name">RIGHT CURLY BRACKET</code> character <code>}</code> (<code class="unicode">U+007D</code>). Keys and values can be any resources. If a key is an object with a description, the key <span class="spec-must">must</span> be surrounded by the <code class="name">REVERSE SOLIDUS</code> character <code>\</code> (<code class="unicode">U+005C</code>). The key and value in each association represent an <code>urf-MapEntry</code> are separated by a <code class="name">COLON</code> character <code>:</code> (<code class="unicode">U+003A</code>).</p>
	<p>A TURF map <span class="spec-should-not">should not</span> have entries with duplicate keys, and a TURF serializer <span class="spec-must-not">must not</span> produce a map with duplicate-key entries. A surf parser <span class="spec-must">must</span> ignore all but one of each entry with the same key. TODO revisit; this bring JSON compatibility, but could cause problems with tags if a duplicate entry is ignored; also address key equality</p>
	<ul class="spec-production">
		<li><code class="name">map</code> ⇒ '{' <code class="name">entry-sequence</code> '}'</li>
		<li><code class="name">entry</code> ⇒ <code class="name">key</code> <code class="name">line_break</code>* ':' <code class="name">line_break</code>* <code class="name">value</code></li>
		<li><code class="name">key</code> ⇒ '\' <code class="name">described_resource</code> '\' | <code class="name">resource</code></li>
		<li><code class="name">value</code> ⇒ <code class="name">described_resource</code></li>
	</ul>
	<p>Each entry represents four URF statements:</p>
	<ol>
		<li>A statement that a new anonymous resource has an <code>urf-Type</code> of <code>urf-MapEntry</code>.</li>
		<li>A statement that the <code>urf-key</code> of the <code>urf-MapEntry</code> instance is the key identified in the TURF document.</li>
		<li>A statement that the <code>urf-value</code> of the <code>urf-MapEntry</code> instance is the value identified in the TURF document.</li>
		<li>A statement that the <code>urf-MapEntry</code> instance is an <code>urf-member+</code> of the <code>urf-Map</code> instance.</li>
	</ol>
	<h4>Set</h4>
	<p>A TURF set represents an instance of <code>urf-Set</code> using an <em>unordered</em> sequence of zero or more member resources with optional descriptions, beginning with a <code class="name">LEFT PARENTHESIS</code> character <code>(</code> (<code class="unicode">U+0028</code>) and ending with a <code class="name">RIGHT PARENTHESIS</code> character <code>)</code> (<code class="unicode">U+0029</code>). The same resource <span class="spec-must-not">must not</span> appear more than once in a set.</p>
	<ul class="spec-production">
		<li><code class="name">set</code> ⇒ '(' <code class="name">member-sequence</code> ')'</li>
		<li><code class="name">member</code> ⇒ <code class="name">described_resource</code></li>
	</ul>
	<p>Each member represents an URF statement that the identified resource is an <code>urf-member+</code> of the <code>urf-Set</code> instance.</p>
	<figure> </figure>
	<h2>Examples</h2>
	<p>This section is non-normative.</p>
	<h3>JSON</h3>
	<p>In the JavaScript Object Notation (<abbr>JSON</abbr>) (<a href="#ref-rfc7159" class="ref">RFC 7159</a>), every object besides strings, numbers, and booleans are associative arrays using string keys. The following is a complex JSON object, using every JSON data type available:</p>
	<figure>
		<pre class="line-numbers"><code class="language-json">{
  "length": 1234,
  "valid": true,
  "status": "processing",
  "results": [false, 5, "dog", {"code": 9.8}]
}</code></pre>
	</figure>
	<p>As all JSON documents are also valid TURF documents, the above document could be parsed as TURF. It would however have some undesirable traits, because of slight semantic differences and because of limitations in JSON. In TURF the JSON “object” would be considered a map, for example. Note also that URF uses a true ordinal property for each list element, while JSON adds each array element as the value associated with a string containing the lexical form of an integer. Unlike JSON, in TURF the commas separating the values are optional if the values appear on separate lines.</p>
	<p>Although the above TURF representation replicates the simple semantics of the given JSON example, a better formulation that takes advantage of URF semantics would most importantly use actual properties rather than associative array string key pseudo-properties. An improved formulation would also indicate the type of the resource (the <code>FooBar</code> class in this example). Such improvements are illustrated in the following reformulation (assuming the <code>"code"</code> string in the list was intended to actually be a key in a map): </p>
	<figure>
		<pre class="line-numbers"><code class="language-turf">*FooBar:
  length = 1234
  valid = true
  status = "processing"
  results = [false, 5, "dog", {"code" = 9.8}]
;</code></pre>
	</figure>
	<p>In a TURF document, moreover, the data can be further improved by using true dates, decimal numbers, identifiers such as tags, and vocabularies from formal namespaces.</p>
	<h3>RDF/XML</h3>
	<p>URF is a semantic superset of RDF, and can represent any construct available in RDF. URF presents equivalents of many RDF classes as well. In terms of representation formats, TURF can represent any semantic information that is available using <a href="#ref-rdfxml" class="ref">RDF/XML</a>, yet is more flexible and has fewer restrictions. The following is a sample RDF/XML representation of an RDF data instance using many of the capabilities available in RDF/XML:</p>
	<figure>
		<pre><code class="language-xml">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE rdf:RDF [&lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#"&gt;]&gt;
&lt;rdf:RDF
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:example="http://example.com/example/"
  xmlns:foaf="http://xmlns.com/foaf/0.1/"
  xmlns:xhtml="http://www.w3.org/1999/xhtml"
&gt;
  &lt;foaf:Person rdf:about="http://example.com/example#janedoe"&gt;
    &lt;foaf:nick xml:lang="pt-BR"&gt;Janinha&lt;/foaf:nick&gt;
    &lt;example:age rdf:datatype="&amp;xsd;integer"&gt;23&lt;/example:age&gt;
    &lt;example:birthdate rdf:datatype="&amp;xsd;date"&gt;1980-04-05&lt;/example:birthdate&gt;
    &lt;example:motto rdf:parseType="Literal"&gt;Do it. Do it &lt;xhtml:em&gt;right&lt;/xhtml:em&gt;.&lt;/example:motto&gt;
    &lt;example:favoriteSites rdf:parseType="Collection"&gt;
      &lt;rdf:Description rdf:about="http://www.globalmentor.com/"/&gt;
      &lt;rdf:Description rdf:about="http://www.garretwilson.com/"/&gt;
    &lt;/example:favoriteSites&gt;
    &lt;example:possibleVacationDestinations&gt;
      &lt;rdf:Alt&gt;
        &lt;rdf:li&gt;Paris&lt;/rdf:li&gt;
        &lt;rdf:li&gt;Rome&lt;/rdf:li&gt;
      &lt;/rdf:Alt&gt;
    &lt;/example:possibleVacationDestinations&gt;
  &lt;/foaf:Person&gt;
&lt;/rdf:RDF&gt;</code></pre>
	</figure>
	<p>The following URF information represented in TURF is semantically equivalent to the RDF information in the previous example represented in RDF/XML:</p>
	<figure>
		<pre class="line-numbers"><code class="language-turf">\URF\:
  space-dc = &lt;http://purl.org/dc/elements/1.1/&gt;
  space-foaf = &lt;http://xmlns.com/foaf/0.1/&gt;
  space-example = &lt;http://example.com/example/&gt;
;
example/janedoe*foaf-Person:
  example/age = #23
  example/birthdate = @1980-04-05@
  example/favoriteSites = [
    |&lt;http://www.globalmentor.com/&gt;|
    |&lt;http://www.garretwilson.com/&gt;|
  ],
  example.motto="Do it. Do it &lt;xhtml:em xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"&gt;right&lt;/xhtml:em&gt;.":
    content.type`=«*content.MediaType("text/xml-external-parsed-entity")»
  ;
  example/possibleVacationDestinations = (
    "Paris",
    "Rome"
  )
  nick="Janinha":
    dc.language`=«*urf.Language("pt-BR")»
  ;
;</code></pre>
	</figure>
	<p>Note that, rather than use special literal types or general strings, URF promotes the representation of resources by URI tags. Thus the language tag <code>"pt-BR"</code> for Brazilian Portuguese is represented as a resource with a lexical ID tag with the type <code>urf-Language</code>, that is <code>|&lt;https://urf.name/urf/Language#pt-BR&gt;|</code>, or in its TURF literal form TODO, and the integer value <code>23</code> is represented as a resource with a lexical ID tag with the type <code>urf-Integer</code>, that is <code>|&lt;https://urf.name/urf/Integer#23&gt;|</code>, shown here in its TURF literal form, <code>#23</code>.</p>
	<p>TODO clarify and fix RDF language tags and properties in the content vocabulary</p>
	<h3>VCard</h3>
	<p>The URF <a href="#vcard">VCard Ontology</a> provides a representation of VCard [<a href="#rfc2426">RFC 2426</a>] within a semantic framework. The following is VCard information in traditional vCard MIME Directory Profile syntax as specified by [<a href="#rfc2426">RFC 2426</a>].</p>
	<figure>
		<pre><code class="language-vcard">BEGIN:vCard
VERSION:3.0
FN:Jane Doe
N:Doe;Jane;Mary,Ann;Dr.;M.D.,Ph.D.
ORG:Example Corporation;North American Division;Business Development
TITLE:Directory of Business Development
ADR;TYPE=WORK,POSTAL,PARCEL:;Suite 45;123 Some Street;Someplace;CA;12345-6789;USA
LABEL="123 Some Street\nSuite 45\nSomeplace, CA 12345-6789"
TEL;TYPE=PREF;VOICE,WORK:+1-234-567-8910
TEL;TYPE=VOICE,HOME,CELL:+1-234-567-8911
EMAIL;PREF:janedoe@example.com
EMAIL:jdoe@example.org
URL:http://www.example.com/home/jane/
BDAY=1980-02-02T09:45:00
CATEGORY:Internet,B2B,P2P,Web2.0,ABCD
END:vCard</code></pre>
	</figure>
	<p>The same vCard information in its URF VCard formulation is shown below for the resource <code>«http://example.com/example/janedoe»</code>. Note that the URF VCard version provides more semantics by using true classes and properties to describe what [<a href="#rfc2426">RFC 2426</a>] calls <dfn>structured values</dfn>.</p>
	<figure>
		<pre><code class="language-turf">`URF:
  "vcard"~&lt;http://urf.com/vcard/&gt;
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.janedoe:
    vcard.fn="Jane Doe"
    vcard.n=*vcard.Name:
      vcard.familyName="Doe"
      vcard.givenName="Jane"
      vcard.additionalName=\"Mary", "Ann"\
      vcard.honoraryPrefix="Dr."
      vcard.honorarySuffix=\"M.D.", "Ph.D."\
    ;
    vcard.org=\"Example Corporation", "North American Division", "Business Development"\
    vcard.title="Directory of Business Development"
    vcard.adr=*vcard.Adr:
      vcard.adrType=«*vcard.AdrType("work")»
      vcard.adrType=«*vcard.AdrType("postal")»
      vcard.adrType=«*vcard.AdrType("parcel")»
      vcard.extendedAddress="Suite 45"
      vcard.streetAddress="123 Some Street"
      vcard.locality="Someplace"
      vcard.region="CA"
      vcard.postalCode="12345-6789"
      vcard.countryName="USA"
    ;
    vcard.label="123 Some Street\nSuite 45\nSomeplace, CA 12345-6789"
    vcard.tel=
    \
      «tel:+1-234-567-8910»:
        vcard.telType`=«*vcard.TelType("voice")»
        vcard.telType`=«*vcard.TelType("work")»
      ;
      «tel:+1-234-567-8911»:
        vcard.telType`=«*vcard.TelType("voice")»
        vcard.telType`=«*vcard.TelType("home")»
        vcard.telType`=«*vcard.TelType("cell")»
      ;
    \
    vcard.email=\&lt;janedoe@example.com&gt;, &lt;jdoe@example.org&gt;\
    vcard.url=&lt;http://www.example.com/home/jane/&gt;
    vcard.bday=@1980-02-02T09:45:00@
    vcard.category="Internet"
    vcard.category="B2B"
    vcard.category="P2P"
    vcard.category="Web2.0"
    vcard.category="ABCD"
  ;
.</code></pre>
	</figure>
	TODO convert to new TURF conceptualization
	<h2>References</h2>
	<dl>
		<dt>DCMI Namespace</dt>
		<dd>Andy Powell and Harry Wagner. <a href="http://dublincore.org/documents/dcmi-namespace/"><cite>Namespace Policy for the Dublin Core Metadata Initiative (DCMI)</cite></a>. Dublin Core Namespace Initiative, 2007.</dd>
		<dt>Guise</dt>
		<dd><a href="http://www.guiseframework.com/"><cite>Guise™ Internet Application Framework</cite></a>. GlobalMentor, Inc.</dd>
		<dt>IANA Charset Registry</dt>
		<dd><a href="http://www.iana.org/assignments/character-sets"><cite>IANA Charset Registry</cite></a>. Internet Assigned Numbers Authority.</dd>
		<dt class="ref-target" id="ref-ieee754">IEEE 754-2008</dt>
		<dd><a href="https://ieeexplore.ieee.org/document/4610935"><cite>IEEE Standard for Floating-Point Arithmetic</cite></a>. IEEE.</dd>
		<dt>ISO 8601</dt>
		<dd><cite>ISO 8601:2004(E): Data elements and interchange formats — Information interchange — Representation of dates and times</cite>. International Organization for Standardization, 2004-12-01.</dd>
		<dt class="ref-target" id="ref-rdfxml">RDF/XML</dt>
		<dd><a href="http://www.w3.org/TR/2014/REC-rdf-syntax-grammar-20140225/"><cite>RDF 1.1 XML Syntax</cite></a>, Fabien Gandon (INRIA), Guus Schreiber (VU University Amsterdam), W3C, 2014.</dd>
		<dt id="ref-rfc2046" class="ref-target">RFC 2046</dt>
		<dd><a href="https://tools.ietf.org/html/rfc2046"><cite>Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</cite></a>, N. Freed (Innosoft), N. Borenstein. IETF.</dd>
		<dt id="ref-rfc2119" class="ref-target">RFC 2119</dt>
		<dd><a href="https://tools.ietf.org/html/rfc2119"><cite>Key words for use in RFCs to Indicate Requirement Levels</cite></a>, S. Bradner (Harvard University). IETF.</dd>
		<dt>RFC 2130</dt>
		<dd>C. Weider, C. Preston, K. Simonsen, H. Alvestrand, R. Atkinson, M. Crispin, and P. Svanberg. <a href="http://www.ietf.org/rfc/rfc2278.txt"><cite>RFC 2130: The Report of the IAB Character Set Workshop held 29 February - 1 March, 1996</cite></a>. Internet Engineering Task Force, 1997.</dd>
		<dt>RFC 2278</dt>
		<dd>N. Freed and J. Postel. <a href="http://www.ietf.org/rfc/rfc2278.txt"><cite>RFC 2278: IANA Charset Registration Procedures</cite></a>. Internet Engineering Task Force, 1998.</dd>
		<dt>RFC 2426</dt>
		<dd>F. Dawson and T. Howes. <a href="http://www.ietf.org/rfc/rfc2426.txt"><cite>RFC 2426: vCard MIME Directory Profile</cite></a>. Internet Engineering Task Force, 1998.</dd>
		<dt>RFC 2445</dt>
		<dd>F. Dawson and and D. Stenerson. <a href="http://www.ietf.org/rfc/rfc2426.txt"><cite>RFC 2445: Internet Calendaring and Scheduling Core Object Specification (iCalendar)</cite></a>. Internet Engineering Task Force, 1998.</dd>
		<dt>RFC 3339</dt>
		<dd>G. Klyne and C. Newman. <a href="http://www.ietf.org/rfc/rfc3339.txt"><cite>RFC 3339: Date and Time on the Internet: Timestamps</cite></a>. Internet Engineering Task Force, 2002.</dd>
		<dt class="ref-target" id="ref-rfc3966">RFC 3966</dt>
		<dd><a href="https://tools.ietf.org/html/rfc3966"><cite>The tel URI for Telephone Numbers</cite></a>, H. Schulzrinne (Columbia University). IETF.</dd>
		<dt class="ref-target" id="ref-rfc3986">RFC 3986</dt>
		<dd><a href="https://tools.ietf.org/html/rfc3986"><cite>Uniform Resource Identifier (URI): Generic Syntax</cite></a>, T. Berners-Lee (W3C/MIT), R. Fielding (Day Software), L. Masinter (Adobe Systems). IETF.</dd>
		<dt class="ref-target" id="ref-rfc3987">RFC 3987</dt>
		<dd><a href="https://tools.ietf.org/html/rfc3987"><cite>Internationalized Resource Identifiers (IRIs)</cite></a>, M. Duerst (W3C), M. Suignard (Microsoft Corporation). IETF.</dd>
		<dt class="ref-target" id="ref-rfc4122">RFC 4122</dt>
		<dd><a href="https://tools.ietf.org/html/rfc4122"><cite>A Universally Unique IDentifier (UUID) URN Namespace</cite></a>, P. Leach (Microsoft Corporation), M. Mealling (Refactored Networks, LLC), R. Salz (DataPower Technology, Inc.). IETF.</dd>
		<dt>RFC 4627</dt>
		<dd>D. Crockford. <a href="http://www.ietf.org/rfc/rfc4627.txt"><cite>RFC 4627: The application/json Media Type for JavaScript Object Notation (JSON)</cite></a>. Internet Engineering Task Force, 2006.</dd>
		<dt>RFC 4646</dt>
		<dd>A. Phillips and M. Davis. <a href="http://www.ietf.org/rfc/rfc4646.txt"><cite>RFC 4646: Tags for Identifying Languages</cite></a>. Internet Engineering Task Force, 2006.</dd>
		<dt class="ref-target" id="ref-rfc4648">RFC 4648</dt>
		<dd><a href="https://tools.ietf.org/html/rfc4648"><cite>The Base16, Base32, and Base64 Data Encodings</cite></a>, S. Josefsson (SJD). IETF.</dd>
		<dt id="ref-rfc5322" class="ref-target">RFC 5322</dt>
		<dd><a href="https://tools.ietf.org/html/rfc5322"><cite>Internet Message Format</cite></a>, P. Resnick, Ed. (Qualcomm Incorporated). IETF.</dd>
		<dt class="ref-target" id="ref-rfc6068">RFC 6068</dt>
		<dd><a href="https://tools.ietf.org/html/rfc6068"><cite>The 'mailto' URI Scheme</cite></a>, M. Duerst (Aoyama Gakuin University), L. Masinter (Adobe Systems Incorporated), J. Zawinski (DNA Lounge). IETF.</dd>
		<dt id="ref-rfc6657" class="ref-target">RFC 6657</dt>
		<dd><a href="https://tools.ietf.org/html/rfc6657"><cite>Update to MIME regarding "charset" Parameter Handling in Textual Media Types</cite></a>, A. Melnikov (Isode Limited), J. Reschke (greenbytes). IETF.</dd>
		<dt id="ref-rfc7159" class="ref-target">RFC 7159</dt>
		<dd><a href="https://tools.ietf.org/html/rfc7159"><cite id="ref-rfc7159">The JavaScript Object Notation (JSON) Data Interchange Format</cite></a>, T. Bray (Google, Inc.). IETF.</dd>
		<dt>Unicode BOM FAQ</dt>
		<dd>Asmus Freytag and Mark Davis. <a href="http://www.unicode.org/unicode/faq/utf_bom.html#BOM"><cite>Unicode Byte Order Mark (BOM) FAQ</cite></a>. Unicode, Inc., Retrieved 2006-06-07.</dd>
		<dt id="ref-urf" class="ref-target">URF</dt>
		<dd><a href="https://urf.io/spec"><cite>Uniform Resource Framework (URF) Specification</cite></a>, Garret Wilson (GlobalMentor, Inc.).</dd>
		<dt id="ref-utr13" class="ref-target">UTR #13</dt>
		<dd><a href="http://unicode.org/unicode/standard/reports/tr13/tr13-5.html"><cite>Unicode Technical Report #13: Unicode Newline Guidelines</cite><cite></cite></a>, Mark Davis. Unicode, Inc.</dd>
		<dt>XML Schema 2</dt>
		<dd>Paul V. Biron and Ashok Malhotra. <a href="http://www.w3.org/TR/xmlschema-2/"><cite>XML Schema Part 2: Datatypes Second Edition</cite></a>. World Wide Web Consortium, 2004-10-28.</dd>
	</dl>
	<h2>Acknowledgements</h2>
	<ul>
		<li>Brad Neuberg encouraged the creation of an alternate RDF serialization.</li>
		<li>Frank Manola made convincing arguments for using ordinals instead of integers as list element properties.</li>
	</ul>
	<footer><small>Copyright © 2007–2019 <a href="http://www.globalmentor.com/">GlobalMentor, Inc.</a>. All Rights Reserved. Content may not be published or reproduced by any means for any purpose without permission. This specification may be freely used for its intended purpose but only in unmodifed form.</small></footer>
	<script src="../../pub/js/prism.js"></script>
</body>

</html>
