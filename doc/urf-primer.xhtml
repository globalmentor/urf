<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
	<meta charset="UTF-8" />
	<meta name="author" content="Garret Wilson" />
	<title>URF Primer</title>
	<link type="text/css" rel="stylesheet" href="../../pub/css/globalmentor-doc.css" />
</head>

<body>
	<header>
		<h1>Uniform Resource Framework (URF) Primer</h1>
		<aside class="important float-end max-size-subordinate">Draft version.</aside>
		<dl>
			<dt>Author</dt>
			<dd><a href="http://www.garretwilson.com/">Garret Wilson</a> (<a href="http://www.globalmentor.com/">GlobalMentor, Inc.</a>)</dd>
			<dt>Version</dt>
			<dd>Draft 2017-09-25</dd>
		</dl>
	</header>
	<p>The Uniform Resource Framework (URF) provides a consistent way for representing resources and their relationships. URF and its interchange formats are useful for data storage, data interchange, data querying, and logical inferences. URF together with its interchange formats provides a more powerful yet in many ways simpler and more consistent replacement for data-oriented XML, RDF, and JSON.</p>
	<p>This document defines the Uniform Resource Framework (URF) as an abstract model, and also defines a text-based representation format, Text URF (TURF). This document does not yet provide a description of the binary representation format Serial URF (SURF), or the XML-based format XML URF (XMURF).</p>
	<h2>Resources</h2>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>Everything that can be described by URF is referred to as a <dfn>resource</dfn>. Every resource is an instance of the class <code>urf.Resource</code>. A group of described resources is referred to as an <dfn>URF instance</dfn>.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>A resource can be described within a colon-semicolon pair. Multiple resources are separated by commas and/or newlines. The following example refers to an anonymous resource:</p>
			<figure>
				<pre><code class="language-turf">:;</code></pre>
			</figure>
			<p>A resource can optionally be given a label which can be used as a short representation to refer the resource only within the interchange document. A resource label is a <a href="#name">name</a> placed in front of a resource description and surrounded by vertical bars, as in the following example:</p>
			<figure>
				<pre><code class="language-turf">|label|:;</code></pre>
			</figure>
		</dd>
	</dl>
	<h2>Resource Identification</h2>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>A resource may be <dfn>anonymous</dfn> or may be identified by a URI.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>A URI is indicated by angle brackets. The following example indicates the URI represented by the characters <code>http://example.com/example/resource</code>:</p>
			<figure>
				<pre><code class="language-turf">&lt;http://example.com/example/resource&gt;</code></pre>
			</figure>
			<p>A resource may be identified by placing its URI characters within angle quotes; when the resource URI is given, the the colon and semicolon are optional if the resource has no properties. All URIs may be relative references, which are resolved to the base URI of the interchange document. The following example refers to the resource identified by the URI <code>&lt;http://urf.name/urf/resource&gt;</code>.</p>
			<figure>
				<pre><code class="language-turf">«http://example.com/example/resource»</code></pre>
			</figure>
			<p>A resource identified by URI may also be given a label and/or description:</p>
			<figure>
				<pre><code class="language-turf">|label|«http://example.com/example/resource»:;</code></pre>
			</figure>
			<p>There can be no newline characters between each of these elements, although there may be newlines <em>inside</em> individual elements if appropriate:</p>
			<figure>
				<pre><code class="language-turf">|label|«http://example.com/example/resource»:;</code></pre>
			</figure>
		</dd>
	</dl>
	<h2>Ontologies and Namespaces</h2>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>A set of resources related to the same domain may be grouped together into an <dfn>ontology</dfn>. If all resources within an ontology to have similar URIs, each constructed relative to the ontology URI, the URI of the ontology is said to be a <dfn>namespace URI</dfn>, and each resource is said to have a <dfn>local name</dfn> which is combined with the namespace to create the resource URI. Not all resource URIs are part of some namespace.</p>
			<p>URF only allows namespace URIs that are collection URIs, ending in a slash character <code>'/'</code>. the URI is formed by URI-encoding all non-<var>pchar</var> characters of the local name according to [<a href="#rfc3986">RFC 3986</a>] and appending the result to the namespace URI. For example, a namespace URI of <code>&lt;http://purl.org/dc/elements/1.1/&gt;</code> and a local name of <code>"title"</code> yield a resource URI of <code>&lt;http://purl.org/dc/elements/1.1/title&gt;</code>. These rules allow the namespace and local name to be unambiguously determined given any URI within a namespace.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>A resource within a namespace can be identified by a <dfn>name reference</dfn> by listing the unencoded local name of the resource, with an optional prefix separated by full stop or period. The prefix, if present, is a string that has been associated with some namespace URI using a tilde character <code>'~'</code> in the TURF preamble, which is surrounded by colon <code>':'</code> and semicolon <code>';'</code> characters. If a property name reference has no prefix, the namespace is the URF default namespace, <code>&lt;http://urf.name/default/&gt;</code>.</p>
			<p>In the following example, the name reference <code>component.Button</code> is equivalent to the URI reference <code>«java:/com/guiseframework/component/Button»</code>, and the name reference of its sole property, <code>label</code>, is equivalent to the URI reference <code>«http://urf.name/default/label»</code>. Another resource is also described that uses name references with prefixes for its URI, type, and property.</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "component"~&lt;java:/com/guiseframework/component/&gt;
  "example"~&lt;http://example.com/example/&gt;
  "foaf"~&lt;http://xmlns.com/foaf/0.1/&gt;
;¤
  *component.Button:
    label="Convert"
  ;
  example.janedoe*foaf.Person:
    example.name="Jane Doe"
  ;
.</code></pre>
			</figure>
			Namespace declarations within a TURF document are purely syntactical, and their assigned namespace prefixes make no separate appearance in the resulting URF instance.</dd>
	</dl>
	<p>This specification uses resources in the following namespaces, with corresponding prefixes:</p>
	<dl>
		<dt><code>"dc"~&lt;http://purl.org/dc/elements/1.1/&gt;</code></dt>
		<dd>The Dublin Core Metadata Initiative namespace [<a href="#dcmiNamespace">DCMI Namespace</a>].</dd>
		<dt><code>"example"~&lt;http://example.com/example/&gt;</code></dt>
		<dd>An example namespace; used for hypothetical situations.</dd>
		<dt><code>"urf"~&lt;http://urf.name/urf/&gt;</code></dt>
		<dd>The URF namespace for resource and properties related to the framework abstract model itself.</dd>
	</dl>
	<p>The default namespace URI <code>&lt;http://urf.name/default/&gt;</code> is associated with no prefix (that is, the absense of a prefix).</p>
	<h2>Properties</h2>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>A resource may be related to another resource by the use of a <dfn>property</dfn>. Every property is itself a resource, although it is not implicitly an instance of the class <code>urf.Property</code> unless declared to be so. A resource <dfn>subject</dfn>, a property <dfn>predicate</dfn>, and the related resource <dfn>object</dfn> together make an <dfn>assertion</dfn> about the universe being described.</p>
			<p>An infinite number of assertions may be made about a single subject resource. Repeated assertions about a subject resource with the same same predicate property and the same object resource are considered identical.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>Assertions about a particular subject resource are presented within a colon-semicolon pair and separated by commas and/or newlines. Each predicate property and object resource pair of an assertion are separated by an equals character. Object resources, like resources in other contexts, can serve as the subject of other property assertions. In the following example, the resource <code>«http://example.com/example/resource»</code> has a single property <code>«http://example.com/example/property»</code>, which has as its value another resource, <code>«http://example.com/example/value»</code>:</p>
			<figure>
				<pre><code class="language-turf">`URF¤
  «http://example.com/example/resource»:
    «http://example.com/example/property»=«http://example.com/example/value»
  ;
.</code></pre>
			</figure>
			<p>By associating the namespace <code>&lt;http://example.com/example/&gt;</code> with the prefix string <code>"example"</code>, the above example could be represented in the following representation:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.resource:
    example.property=example.value
  ;
.</code></pre>
			</figure>
		</dd>
	</dl>
	<h2>Classes</h2>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>A resource may represent a <dfn>class</dfn> or set of resources containing instances of other resources. As stated earlier, for example, all resources are implicitly instances of the class <code>urf.Resource</code>. Any resource may be explicitly asserted to be an instance of some class by identifying the class resource as a value of the <code>urf.type</code> property. A resource that is an instance of the class <code>urf.Class</code> may indicate that it is a subclass of some other class by indicating that class resource as the value of the <code>urf.subClassOf</code> property. A resource that is an instance of the class <code>urf.Class</code> may indicate that it is an implementation of some interface by indicating that interface resource as the value of the <code>urf.implementationOf</code> property.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>It can be asserted that a resource is an instance of a class and a subclass of some other class by normal representation of the <code>urf.type</code> and urf.subClassOf property. In the following example, the resource <code>example.resource</code> is asserted to be an instance of the class <code>example.MyClass</code>:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.resource:
    urf.type=example.MyClass
    example.property=example.value
  ;
.</code></pre>
			</figure>
			<p>As a shorthand representation, that a resource is an instance of one or more classes may be represented by placing a reference to the class resources after the resource reference, each preceded by an asterisk (<code>'*'</code>). The following example is semantically identical to the preceding example.</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.resource*example.MyClass:
    example.property=example.value
  ;
.</code></pre>
			</figure>
			<p>There also exists a shorthand representation for the <code>urf.subClassOf</code> and <code>urf.implementationOf</code> properties, using the circumflex accent <code>'^'</code> and the greater than symbol <code>'&gt;'</code>, respectivly. The following example indicates that <code>example.MyClass</code> is a class that is a subclass of <code>example.SuperClass</code> and an implementation of the interface <code>example.MyInterface</code>:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.MyClass*urf.Class^example.MySuperClass&gt;example.MyInterface
.</code></pre>
			</figure>
		</dd>
	</dl>
	<h2>URF Types</h2>
	<p>URF and its standard ontologies comes with several built-in types, including:</p>
	<dl>
		<dt><code>urf.Binary</code></dt>
		<dd>Binary resources represent arbitrarily long sequences of bytes. Binary resources use the appropriate inline namespace for their type, with a lexical form of the <dfn>base64url</dfn> encoding of the binary data without line breaks according to [<a href="#rfc4648">RFC 4648</a>].</dd>
		<dt><code>urf.Boolean</code></dt>
		<dd>There are two boolean resources, the values <code>true</code> and <code>false</code>. Boolean resources are identified by URIs in the Boolean inline namespace with lexical representations of <code>"true"</code> and <code>"false"</code>, respectively.</dd>
		<dt><code>urf.Character</code></dt>
		<dd>Character resources are the Unicode code points, and their lexical forms are the Unicode characters represented by those code points.</dd>
		<dt><code>urf.Class</code></dt>
		<dd>Not every resource used as a class is an instance of the class <code>urf.Class</code>, but a resource may be declared to be of the class type to further specify its semantics. The class <code>urf.Class</code> is a subclass of the class <code>urf.Resource</code>.</dd>
		<dt><code>urf.Date</code></dt>
		<dd>Date resources represent calendar dates in terms of calendar year, calendar month, and calendar day of month. They use an inline namespace with a lexical form consistent with [<a href="#rfc3339">RFC 3339</a>] of <code><var>YYYY</var>-<var>MM</var>-<var>DD</var></code> as defined in [<a href="#iso8601">ISO 8601</a>].</dd>
		<dt><code>urf.DateTime</code></dt>
		<dd>A date time resource represents a time of day on a particular calendar date. They use an inline namespace with a lexical form combining the lexical forms of <code>urf.Date</code> and <code>urf.Time</code> separated by <code>T</code>: <code><var>YYYY</var>-<var>MM</var>-<var>DD</var>T<var>hh:</var><var>mm</var>:ss<strong>[</strong>.s<strong>+</strong><strong>]</strong><strong>[</strong><strong>(</strong>+<strong>|</strong>-<strong>)</strong><var>hh</var>:<var>mm</var><strong>]</strong></code> with optional UTC offset as defined in [<a href="#iso8601">ISO 8601</a>]. A form without the optional UTC offset is said to be <dfn>floating</dfn> as defined in [<a href="#rfc2445">RFC 2445</a>], and should not be used unless a time independent of a time zone is to be specified. In most cases a <dfn>fixed time</dfn> is appropriate and a form with the UTC offset should be used. The hours component represents midnight as <code>00</code> and must not have a value larger than <code>23</code>. The UTC offset <code>-00:00</code> is not allowed; <code>+00:00</code> must be used instead.</dd>
		<dt><code>urf.Duration</code></dt>
		<dd>Duration resources represent lengths of time. They use an inline namespace with a lexical form consistent with [<a href="#rfc2445">RFC 2445</a>] and [<a href="#iso8601">ISO 8601</a>] of <code>P<strong>[</strong><var>n</var>Y<var>n</var>M<var>n</var>D<strong>]</strong><strong>[</strong>T<var>n</var>H<var>n</var>M<var>n</var><strong>[</strong>.<var>n</var><strong>]</strong>S<strong>]</strong></code>, where <var>n</var> is some positive number of roman digits and at least the date or time section is present.</dd>
		<dt><code>urf.Enum</code></dt>
		<dd>The base class of class resources having inline URIs the lexical forms of which are enumerated as class list elements.</dd>
		<dt><code>urf.Integer</code></dt>
		<dd>Integer resources are the positive whole numbers, the negative whole numbers, and zero. They are identified by inline namespace URIs with a lexical representation in the form <code><strong>[</strong>-<strong>]</strong><var>romandigit</var><strong>+</strong></code>. The integer class is a subclass of the class <code>urf.Number</code>.</dd>
		<dt><code>urf.Language</code></dt>
		<dd>Language resources represent human langages and use inline namespace URIs. The lexical form of each is the corresponding <dfn>language tag</dfn> described in [<a href="#rfc4646">RFC 4646</a>].</dd>
		<dt><code>urf.List</code></dt>
		<dd>List resources are resources that contain other <dfn>element</dfn> resources at certain <dfn>indexes</dfn> of the list. A list, like normal resources, may have any property, but the properties representing the elements of the list lie in the ordinal namespace <code>&lt;http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Ordinal/&gt;</code>, each representing the ordinal index of the element. That is, if a list contains an element at index 5, the element resource will appear as a value of the property <code>«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Ordinal/%225%22»</code> (that is, the property <code>«(urf.Ordinal)"5"»</code>, or simply <code>º5</code>). Although many uses cases will prefer a continuous, unduplicated sequence of index properties beginning with <code>º5</code>, this is not an URF requirement.</dd>
		<dt><code>urf.Map</code></dt>
		<dd>A resource containing associations between keys and values. Each association is represented by an instance of <code>urf.MapEntry</code>, which indicates a value for the property <code>urf.key</code> and the property <code>urf.value</code>. Each map entry is the value of an <code>urf.entry</code> property of the map resource.</dd>
		<dt><code>urf.Ordinal</code></dt>
		<dd>Ordinal resources are numbers that represent the position of an element in a sequence. URF currently only supports finite ordinals, which means that there will be a corresponding ordinal for every positive whole numbers and zero. Ordinals are identified by inline namespace URIs with a lexical representation in the form <code><var>romandigit</var><strong>+</strong></code>. The ordinal class is a subclass of the class <code>urf.</code>Number.</dd>
		<dt><code>urf.Property</code></dt>
		<dd>Not every resource used as a predicate is an instance of the class <code>urf.Property</code>, but a resource may be declared to be of the property type to further specify its semantics and expected domain and range. The class <code>urf.Property</code> is a subclass of the class <code>urf.Class</code>.</dd>
		<dt><code>urf.Rational</code></dt>
		<dd>Rational number are all of the measuring numbers and may include decimal fractional parts. They are identified by inline namespace URIs with a lexical representation in the form <strong>[</strong>-<strong>]</strong><var>romandigit</var><strong>+</strong>.<var>romandigit</var><strong>+[</strong>e<strong>[</strong>+<strong>|</strong>-<strong>]</strong><var>romandigit</var><strong>+]</strong>. The integer class is a subclass of the class <code>urf.Number</code>.</dd>
		<dt><code>urf.RegularExpression</code></dt>
		<dd>Regular expression resources are text-based patterns that define rules for the content of strings. These are inline namespace resources.</dd>
		<dt><code>urf.Resource</code></dt>
		<dd>Every resource is implicitly an instance of the class <code>urf.Resource</code>. The resources <code>urf.Property</code> and <code>urf.Resource</code> are both instances of the class <code>urf.Resource</code>.</dd>
		<dt><code>urf.Set</code></dt>
		<dd>Set resources are resources that contain at most one instance of other <dfn>element</dfn> resources. A set, like normal resources, may have any property, but the properties representing the elements of the set appear as values of the <code>urf.element</code> property.</dd>
		<dt><code>urf.String</code></dt>
		<dd>String resources are sequences of Unicode code points or text and lie in the corresponding inline namespace.</dd>
		<dt><code>urf.Time</code></dt>
		<dd>Time resources represent time of day. They use a inline namespace with a lexical form consistent with [<a href="#rfc3339">RFC 3339</a>] of <code><var>hh:</var><var>mm</var>:ss<strong>[</strong>.s<strong>+</strong><strong>]</strong><strong>[</strong><strong>(</strong>+<strong>|</strong>-<strong>)</strong><var>hh</var>:<var>mm</var><strong>]</strong></code> with optional UTC offset as defined in [<a href="#iso8601">ISO 8601</a>]. A form without the optional UTC offset is said to be <dfn>floating</dfn> as defined in [<a href="#rfc2445">RFC 2445</a>], and should not be used unless a time independent of a time zone is to be specified. In most cases a <dfn>fixed time</dfn> is appropriate and a form with the UTC offset should be used. The hours component represents midnight as <code>00</code> and must not have a value larger than <code>23</code>. The UTC offset <code>-00:00</code> is not allowed; <code>+00:00</code> must be used instead.</dd>
		<dt><code>urf.URI</code></dt>
		<dd>URI resources are sequences of Unicode code points that function as resource identifiers and conform to [<a href="#rfc3986">RFC 3986</a>]. They lie in the corresponding inline namespace with a lexical form specified by [<a href="#rfc3986">RFC 3986</a>].</dd>
		<dt><code>urf.UTCOffset</code></dt>
		<dd>UTC offset resources represent an offset from UTC to local time. They use an inline namespace with a lexical form of <strong>(</strong>+<strong>|</strong>-<strong>)</strong><var>hh</var>:<var>mm</var> with semantics corresponding to the UTC offset described in [<a href="#rfc2426">RFC 2426</a>] and [<a href="#rfc2445">RFC 2445</a>]. The UTC offset <code>-00:00</code> is not allowed; <code>+00:00</code> must be used instead.</dd>
		<dt><code>content.Charset</code></dt>
		<dd>The name of the mapping of integer values to a set of characters. This is equivalent to the <dfn>charset</dfn> Internet media type parameter described by [<a href="#rfc2046">RFC 2046</a>] and further elaborated in [<a href="#rfc2278">RFC 2278</a>] Section 2.3. A charset encapsulates both the concept of a <dfn>coded character set</dfn> and a <dfn>character encoding scheme</dfn>, as specified in [<a href="#rfc2130">RFC 2130</a>] Section 3.2. The lexical form is the canonical charset name specified by [<a href="#ianaCharsetRegistry">IANA Charset Registry</a>], such as <code>UTF-16BE</code>.</dd>
		<dt><code>content.MediaType</code></dt>
		<dd>A media type resource is an Internet media types described by [<a href="#rfc2046">RFC 2046</a>]. Internet media types are also known as <dfn>MIME types</dfn> and <dfn>content types</dfn>. Media type resources use inline namespace URIs, and each has a lexical form corresponding to its [<a href="#rfc2046">RFC 2046</a>] representation without any media type parameters.</dd>
	</dl>
	<h2>Selectors</h2>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>A resource may have a <dfn>selector</dfn> that indicates how a specific instance of a class is to be selected. A selector for an instance of a particular class is represented by the <code>urf.List</code> value of a scoped <code>urf.selector</code> property in the scope of the resource's <code>urf.type</code> property for the class instance being selected.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>A selector for a particular type may be represented in short form by one or more comma-separated resources withing parenthesis after the type short form. The following example selects an instance of the type <code>example.Point</code> using the selector <code>[#5#, #8#]</code>, assumedly indicating five units along the X axis and eight units along the Y axis.</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "example"~&lt;http://example.com/example/&gt;
;¤
  *example.Point(#5#, #8#)
.</code></pre>
			</figure>
			<p>The following example is semantically equivalent to the short form above:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "example"~&lt;http://example.com/example/&gt;
;¤
  :
    urf.type=example.Point:
      urf.selector`=[#5#, #8#]
    ;
  ;
.</code></pre>
			</figure>
		</dd>
	</dl>
	<h2>Inline Resource URIs</h2>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>Some resource types are singletons that are unambiguously identified by their selectors. These resources are identified by <dfn>inline</dfn> URIs that contain both the resource type and the identifying selector within the URI itself. The most common type of resource that use inline URIs are those that in day-to-day life have customarily been identified by character sequences or <dfn><dfn>lexical representations</dfn></dfn>. For example, the integer <code>123</code> has historically been represented by the character sequence <code>"123"</code>, although the number itself is an abstract concept, not a series of characters. Similarly, the two boolean values are usually represented as the character sequences <code>"true"</code> and <code>"false"</code>.</p>
			<p>Each inline namespace URI begins with the base URF inline namespace URI <code>&lt;http://urf.name/inline/&gt;</code> and has the following format,</p>
			<figure>
				<pre><code class="language-turf">http://urf.name/inline/<var>encodedTypeURI</var>/<var>encodedTURFLexicalForm</var></code></pre>
			</figure>
			<p>where <var>encodedTypeURI</var> is the URI path segment-encoded form of the full type URI of the resource; and <var>encodedTURFLexicalForm</var> is the URI path segment-encoded canonical lexical form of the resource as defined by the indicated type, in its TURF short string form. For example, the integer 123, which is of the type <code>«http://urf.name/urf/Integer»</code>, has a lexical form of <code>"123"</code>. This TURF string representation, encoded for a URI, yields <code>%22123%22</code>, which results in  the following inline URI:</p>
			<figure>
				<pre><code class="language-turf">http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Integer/%22123%22</code></pre>
			</figure>
			<p>A resource in an inline namespace is implicitly an instance of the type indicated in the <var>encodedTypeURI</var> section of the URI. In all other aspects resources in inline namespaces are no different from resources not in an inline namespace; these resources are <em>not</em> instances of a special resource type solely because their namespaces are inline namespaces. Inline namespaces provide a framework for easily and consistently formulating identifying URIs for resources that are traditionally identified in lexical form; inline namespaces in themselves imply no additional semantics.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>Any representation of a resource in an inline namespace also implicitly asserts the type of the resource. A resource in an inline namespace can be identified by its URI as with any other resource. For example, the integer 123 can be identified by its URI <code>&lt;http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Integer/%22123%22&gt;</code> as in the following example:</p>
			<figure>
				<pre><code class="language-turf">«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Integer/%22123%22»</code></pre>
			</figure>
			<p>Rather than indicating directly the URI of a resource in an inline namespace, the resource may be identified by indicating the type of the resource preceded by an asterisk inside the URI reference, followed by the canonical lexical form of the resource as a string inside parentheses. In essence, a type an selector is being used to generate a corresponding URI. The integer 123 may therefore be represented as either of the following short forms:</p>
			<figure>
				<pre><code class="language-turf">«*«http://urf.name/urf/Integer»("123")»</code></pre>
				<pre><code class="language-turf">«*urf.Integer("123")»</code></pre>
			</figure>
			<p>The inline namespaces for several types have additional short representations. The examples below assume that the label <code>urf</code> has been assigned to the URF namespace.</p>
			<dl>
				<dt><code>urf.Binary</code></dt>
				<dd>
					<p>An binary resource may be identified by its [<a href="#rfc4648">RFC 4648</a>] base64url lexical form surrounded by percent signs. For example, the series of bytes <code>64</code>, <code>63</code>, <code>62</code>, <code>61</code> produce the lexical form, <code>"QD8-PQ=="</code>; the corresponding short representation,</p>
					<figure>
						<pre><code class="language-turf">%QD8-PQ==%</code></pre>
					</figure>
					<p>is equivalent to the following long representation,</p>
					<figure>
						<pre><code class="language-turf">«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Binary/%22QD8-PQ%3D%3D%22»</code></pre>
					</figure>
					<p>which is also equivalent to the following general short representation for resources in an inline namespace:</p>
					<figure>
						<pre><code class="language-turf">«*urf.Binary("QD8-PQ==")»</code></pre>
					</figure>
				</dd>
				<dt><code>urf.Boolean</code></dt>
				<dd>
					<p>An boolean resource may be identified by its lexical form surrounded by matching underscore characters (<code>'_'</code>). For example, the following short representation,</p>
					<figure>
						<pre><code class="language-turf">_true_</code></pre>
					</figure>
					<p>is equivalent to the following long representation,</p>
					<figure>
						<pre><code class="language-turf">«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Boolean/%22true%22»</code></pre>
					</figure>
					<p>which is also equivalent to the following general short representation for resources in an inline namespace:</p>
					<figure>
						<pre><code class="language-turf">«*urf.Boolean("true")»</code></pre>
					</figure>
				</dd>
				<dt><code>urf.Character</code></dt>
				<dd>
					<p>A character resource may be identified by its <a href="#charactershort">character-escaped lexical form</a> with surrounding single quotes. For example, the following short representation,</p>
					<figure>
						<pre><code class="language-turf">'x'</code></pre>
					</figure>
					<p>is equivalent to the following long representation,</p>
					<figure>
						<pre><code class="language-turf">«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Character/%22x%22»</code></pre>
					</figure>
					<p>which is also equivalent to the following general short representation for resources in an inline namespace:</p>
					<figure>
						<pre><code class="language-turf">«*urf.Character("x")»</code></pre>
					</figure>
				</dd>
				<dt><code>urf.Number</code></dt>
				<dd>
					<p>Integer and rational number resources may be identified by their lexical forms surrounded by matching number signs (<code>'#'</code>). The specific type of number resource yielded depends on the lexical form used. For example, the following short representations,</p>
					<figure>
						<pre><code class="language-turf">#123#
#123.45#</code></pre>
					</figure>
					<p>are equivalent to the following long representations, respectively,</p>
					<figure>
						<pre><code class="language-turf">«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Integer/%22123%22»
«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Rational/%22123.45%22»</code></pre>
					</figure>
					<p>which are also equivalent to the following general short representations for resources in an inline namespace, respectively:</p>
					<figure>
						<pre><code class="language-turf">«*urf.Integer("123")»
«*urf.Rational("123.45")»</code></pre>
					</figure>
				</dd>
				<dt><code>urf.Ordinal</code></dt>
				<dd>
					<p>Ordinal number resources may be identified by their lexical forms surrounded by matching ordinal characters <code>'º'</code>. For example, the following short representation,</p>
					<figure>
						<pre><code class="language-turf">º5º</code></pre>
					</figure>
					<p>is equivalent to the following long representation,</p>
					<figure>
						<pre><code class="language-turf">«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Ordinal/%225%22»</code></pre>
					</figure>
					<p>which are also equivalent to the following general short representation for resources in an inline namespace:</p>
					<figure>
						<pre><code class="language-turf">«*urf.Ordinal("5")»</code></pre>
					</figure>
				</dd>
				<dt><code>urf.RegularExpression</code></dt>
				<dd>
					<p>A regular expression resource may be identified by its <a href="#regexshort">regular expression-escaped lexical form</a> surrounded by slashes (<code>'/'</code>). For example, the following short representation,</p>
					<figure>
						<pre><code class="language-turf">/a?b+c*/</code></pre>
					</figure>
					<p>is equivalent to the following long representation,</p>
					<figure>
						<pre><code class="language-turf">«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23RegularExpression/%22a%3Fb%2Bc%2a%22»</code></pre>
					</figure>
					<p>which is also equivalent to the general short representation for resources in an inline namespace:</p>
					<figure>
						<pre><code class="language-turf">«*urf.RegularExpression("a?b+c*")»</code></pre>
					</figure>
				</dd>
				<dt><code>urf.String</code></dt>
				<dd>
					<p>A string resource may be identified by its <a href="#stringshort">string-escaped lexical form</a> with surrounding quotes. For example, the following short representation,</p>
					<figure>
						<pre><code class="language-turf">"apple"</code></pre>
					</figure>
					<p>is equivalent to the following long representation,</p>
					<figure>
						<pre><code class="language-turf">«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23String/%22apple%22»</code></pre>
					</figure>
					<p>which is also equivalent to the general short representation for resources in an inline namespace:</p>
					<figure>
						<pre><code class="language-turf">«*urf.String("apple")»</code></pre>
					</figure>
				</dd>
				<dt><code>urf.Temporal</code></dt>
				<dd>
					<p>A temporal resource such as <code>urf.Date</code>, <code>urf.DateTime</code>, <code>urf.Duration</code>, <code>urf.Time</code>, or <code>urf.UTCOffset</code> may be identified by its lexical form surrounded by matching at signs (<code>'@'</code>). The specific temporal type can be determined by the specific lexical form used. For example, the following short representations for <code>urf.Date</code>, <code>urf.Time</code>, <code>urf.DateTime</code>, <code>urf.Duration</code>, and <code>urf.UTFOffset</code>,</p>
					<figure>
						<pre><code class="language-turf">@1980-05-06@
@16:39:57-08:00@
@1980-05-06T16:39:57-08:00@
@P100Y5M3DT8H2M10.5S@
@-08:00@</code></pre>
					</figure>
					<p>are equivalent to the following long representations, respectively,</p>
					<figure>
						<pre><code class="language-turf">«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Date/%221980-05-06%22»
«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Time/%2216%3A39%3A57-08%3A00%22»
«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23DateTime/%221980-05-06T16%3A39%3A57-08%3A00%22»
«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Duration/%22P100Y5M3DT8H2M10.5S%22»
«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23UTCOffset/%22-08:00%22»</code></pre>
					</figure>
					<p>which are also equivalent to the general short representations for resources in an inline namespace:</p>
					<figure>
						<pre><code class="language-turf">«*urf.Date("1980-05-06")»
«*urf.Time("16:39:57-08:00")»
«*urf.DateTime("1980-05-06T16:39:57-08:00")»
«*urf.Duration("P100Y5M3DT8H2M10.5S")»
«*urf.UTCOffset("-08:00")»</code></pre>
					</figure>
				</dd>
				<dt><code>urf.URI</code></dt>
				<dd>
					<p>A URI resource may be identified by its lexical form with surrounding angle brackets <code>'&lt;'</code> and <code>'&gt;'</code>. For example, the following short representation,</p>
					<figure>
						<pre><code class="language-turf">&lt;http://urf.name/urf/type&gt;</code></pre>
					</figure>
					<p>is equivalent to the following long representation,</p>
					<figure>
						<pre><code class="language-turf">«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23URI/http%3A%2F%2Furf.name%2Furf%23type»</code></pre>
					</figure>
					<p>which is also equivalent to the general short representation for resources in an inline namespace:</p>
					<figure>
						<pre><code class="language-turf">«*urf.URI("http://urf.name/urf/type")»</code></pre>
					</figure>
				</dd>
			</dl>
		</dd>
	</dl>
	<h2>Enums</h2>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>URF provides a special class, <code>urf.Enum</code>, for declaring subclasses that have values from a finite set of lexical forms. The URI of each instance of the enum subclass is a normal inline URI, made up of the enum type (the <code>urf.Enum</code> subclass) and the lexical form of the enum value. <code>urf.Enum</code> is in turn a subclass of <code>urf.Set</code>, and the lexical form values of the enum type are specified as set elements of the <code>urf.Enum</code> subclass. For example, the URF class <code>urf.Boolean</code> is a subclass of <code>urf.Enum</code>, and its lexical form values are <code>"false"</code> and <code>"true"</code>. The URI of each <code>urf.Boolean</code> instance is formed following normal URF inline URI rules, resulting in <code>«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Boolean/%22false%22»</code> and <code>«http://urf.name/inline/http%3A%2F%2Furf.name%2Furf%23Boolean/%22true%22»</code>.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>The following is the definition of the <code>urf.Boolean</code> class, which is a typical enum subclass:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
;¤
  urf.Boolean*urf.Class^urf.Enum{
    "false",
    "true"
  }
.</code></pre>
			</figure>
		</dd>
	</dl>
	<h2>Reification</h2>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>Propositions may be described without actually asserting those propositions. The sentence, "John believes that the sky is purple," for example, does not assert that the skye is purple, but merely that John believes this to be the case. The proposition "the sky is purple" may be described like any other resource, using the URF class <code>urf.Proposition</code> and the URF properties <code>urf.subject</code>, <code>urf.predicate</code>, and <code>urf.object</code>.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>The following example asserts that John believes the sky to have the color purple without asserting that the sky actually has that color:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.john:
    example.believes=*urf.Proposition:
      urf.subject=example.sky
      urf.predicate=example.color
      urf.object=example.purple
    ;
  ;
.</code></pre>
			</figure>
			<p>Propositions may be presented in a short form consisting of the subject, predicate, and object enclosed in open double quotation mark <code>'“'</code> and closed double quotation mark <code>'”'</code> characters. The following example is semantically equivalent to the previous one:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;,
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.john:
    example.believes=“example.sky, example.color, example.purple”
  ;
.</code></pre>
			</figure>
			<p>Any proposition that is asserted can be reified by placing a label before the equals sign in a property definition. The label will then identify a proposition that is the reification of the property assertion, and that labeled resource can then be used in any situation in which a resource is expected. The following example first asserts that the sky is purple, using the label <code>skyColorPurple</code> to represent the reified proposition, <code>“example.sky, example.color, example.purple”</code>. Then it is asserted that John believes this proposition; the second assertion is therefore semantically identical to the one in the previous example.</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.sky:
    example:color|skyColorPurple|=example:purple
  ;
  example.john:
    example.believes=|skyColorPurple|
  ;
.</code></pre>
			</figure>
		</dd>
	</dl>
	<h2>Proposition Scope</h2>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>Some assertions are only valid within a certain scope; they are asserted in a separate URF instance related to the context of some other subject and property. For example, if Juan has an English name of <code>"John"</code>, Juan could specify a <code>example.name</code> of <code>"John"</code> with an <code>example.lang</code> of <code>example.english</code>. Because the string <code>"John"</code> may not represent an English string in all contexts, its property <code>example.lang</code> should be considered to be in the scope of the relationship between Juan and the <code>example.name</code> <code>"John"</code>. The assertion, "the string 'John' is in English", is contextual to the string "John" being the name of Juan.</p>
			<p>Similarly, Juan could specify a <code>example.weight</code> of <code>#72#</code> with an <code>example.unit</code> of <code>example.kilogram</code>. Because the integer <code>#72#</code> may not represent a unit of kilograms in all contexts, its property <code>example.unit</code> should be considered to be in the scope of the relationship between Juan and the <code>example.weight</code> <code>#72#</code>. The assertion, "the integer 72 is in kilograms", is contextual to the integer 72 being the weight of Juan.</p>
			<p>Scoped propositions are actually propositions asserted in separate <a href="#communities">knowledge communities</a> created by their context propositions.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>To restrict a particular property assignment to the scope of the subject serving as the value of some other resource's property, the grave accent character <code>'`'</code> is used before the equals sign <code>'='</code> in the property declaration:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.juan:
    example.name="John":
      example.lang`=example.english
    ;
    example.weight=#72#:
      example.unit`=example.kilogram
    ;
  ;
.</code></pre>
			</figure>
		</dd>
	</dl>
	<h2>Ordered Properties</h2>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>Although all resource property assertions of a particular subject have no inherent order, URF provides a facility for declaring property order using scoped properties. Each property that should be considered to have an order relative to other assertions of the same property is given a scoped property <code>urf.order</code> with a value of type <code>urf.Integer</code>, representing the relative order in which the property should be interpreted.</p>
			<p>The interpretation of the property's order is specific to the property in question. Although many uses cases will prefer a continuous, unduplicated sequence of order property values beginning with <code>0</code>, this is not an URF requirement. The result of merging ordered properties is undefined, except that the properties in each group before the merge must still be in the same order relative to each other after the merge.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>Ordered properties may be indicated using the general representation for contextual properties. The following example indicates that a resource has two names, <code>"William"</code> and <code>"Bill"</code>, and that <code>"Will"</code> comes before <code>"Bill"</code>. (What it means that a name "comes before" another name depends on the definition of the name property being used. Perhaps one name comes before the other if used simultaneously, or perhaps one name has a higher priority or is considered the "default" name.)</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.billy:
    example.name="William":
      urf.order`=#0#
    ;
    example.name="Bill":
      urf.order`=#1#
    ;
  ;
.</code></pre>
			</figure>
			The same information may be presented in short representation in the form of a <dfn>sequence</dfn> by placing the ordered values within matching backslash characters. A sequence does not result in a new type of value, but rather indicates that the given predicate should be asserted for each value, each with a scoped property of <code>urf.order</code> with values starting at <code>#0#</code> and continuing sequentially. The following example represents information semantically identical to the previous example:
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.billy:
    example.name=\"William",  "Bill"\
  ;
.</code></pre>
			</figure>
		</dd>
	</dl>
	<h2>Programming Languages</h2>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>URF provides inherent support for describing how to instantiate objects from programming languages such as Java. When an ontology of a semantic framework such as URF is used to represent programming language objects, the ontology is referred to as a Programming Language Ontology for Objects and Properties, or <a href="#ploop">PLOOP</a>. A class can be identified as an object's type using a URI that identifies the type, such as <code>«java:/com/example/package/ExampleClass»</code> for the Java class <code>com.example.package.ExampleClass</code>. The <code>urf.List</code> value of the selector property <code>urf.selector</code> specifies the resources to be used for object initialization using a constructor with parameters matching the given values.</p>
			<p>URF properties specify programming language properties, which may be virtual properties using "getter" and "setter" methods such as with JavaBeans. Programming languages usually have properties relative to each class rather than absolute for all classes. URF uses properties in the default namespace to represent these relative properties. For example, the Java property represented by the JavaBean method <code>com.example.package.ExampleClass.setProperty(java.lang.String)</code> would be represented by an URF property with the URI <code>«http://urf.name/default/property»</code>. Some values may be language-specific; Java, for example, provides a global <code>null</code> value represented in URF by <code>«java:null»</code>.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>The TURF selector shorthand notation specifies constructor arguments for a class instance if a non-default constructor is desired. The class <code>com.guiseframework.Category</code> of the Guise Internet application framework [<a href="#guise">Guise</a>], for example, does not have a default constructor. The following example provides an <code>urf.selector</code> <code>urf.List</code> property containing a single element of type <code>urf.String</code>, which can be converted to a <code>java.lang.String</code> object and used as arguments for the <code>com.guiseframework.Category(java.lang.String, java.lang.String)</code> constructor. Properties of that class will then be set, recursively converting values such as <code>urf.List</code> to the equivalent Java object such as <code>java.util.List</code>.</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "guise"~&lt;java:/com/guiseframework/&gt;
;¤
  *guise.Category("category1", "First Category"):
    categories=[
      *guise.Category("subcategoryA")
      *guise.Category("subcategoryB")
    ]
  ;
.</code></pre>
			</figure>
			<p>This is equivalent to the following TURF long form:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "guise"~&lt;java:/com/guiseframework/&gt;
;¤
  :
    urf.type=guise.Category:
      urf.selector`=["category1", "First Category"]
    ;
    categories=[
      :
        urf.type=guise.Category:
          urf.selector`=["subcategoryA"]
        ;
      ;
      :
        urf.type=guise.Category:
          urf.selector`=["subcategoryB"]
        ;
      ;
    ]
  ;
.</code></pre>
			</figure>
		</dd>
	</dl>
	<h2>Knowledge Communities</h2>
	<dl>
		<dt>URF</dt>
		<dd>
			<p>The class <code>urf.Community</code> represents a body of knowledge accepted within a certain context. The <code>urf.Community</code> class is a subclass of <code>urf.Set</code>; its elements are instances of <code>urf.Proposition</code>. The propositions an <code>urf.Community</code> contains are considered to be asserted within that community.</p>
			<p>The class <code>urf.Proposition</code> is a subclass of <code>urf.Community</code>, which means that each proposition is itself a knowledge community providing a context for asserted propositions. Scoped propositions are propositions that are contained within another instance of <code>urf.Proposition</code>.</p>
		</dd>
		<dt>TURF</dt>
		<dd>
			<p>In a TURF interchange document, every root resource and its recursive properties (excluding those within other <code>urf.Community</code> instances), represent propositions asserted in a default knowledge community. For example, the following example asserts that Punxsutawney Phil predicts the weather. ("Punxsutawney Phil" the name given to a marmot in Punxsutawney, Philadelphia, USA. On the American holiday Groundhog Day, whether Punxsutawney Phil sees his shadow is considered to be a prognostication regarding the onset of spring weather.)</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "punx"~&lt;http://example.com/punxsutawney/&gt;
;¤
  punx.Phil:
    punx.predicts=punx.weather
  ;
.</code></pre>
			</figure>
			<p>It may instead be asserted that some other community, possibly identified, asserts a set of propositions. The currency symbol <code>'¤'</code> and full stop <code>'.'</code> characters indicate that the properties and resources between them are reified as propositions and serve as elements of the given <code>urf.Community</code> instance—which in turn is taken to mean that the propositions are asserted by the given knowledge community. (All TURF exchange documents have a common <dfn>instance community</dfn> in which root assertions are made.) For example, rather than directly asserting that Punxsutawney Phil predicts the weather, the following example asserts that <em>the community of Punxsutawney</em> asserts (believes or holds) that Punxsutawney Phil predicts the weather (the <code>urf.Community</code> specification is redundant here, because the community short form implies the <code>urf.Community</code> type):</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "punx"~&lt;http://example.com/punxsutawney/&gt;
;¤
  punx.Punxsutawney*urf.Community¤
    punx.Phil:
      punx.predicts=punx.weather
  .
.</code></pre>
			</figure>
			<p>Semantics identical to those the previous example can be represented in the following longer form, with the propositions (shown here in short form) that are asserted in the community explicitly reified:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "punx"~&lt;http://example.com/punxsutawney/&gt;
;¤
  punx.Punxsutawney*urf.Community{
    “punx.Phil, punx.predicts, punx.weather”
  }
.</code></pre>
			</figure>
			<p>Because scoped properties are really propositions asserted in the knowledge community that is some other proposition, scoped properties may be represented in the same manner as other knowledge community representations. The following is the scoped property example given earlier in its short form:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.juan:
    example.name="John":
      example.lang`=example.english
    ;
    example.weight=#72#:
      example.unit`=example.kilogram
    ;
  ;
.</code></pre>
			</figure>
			<p>Because each <code>urf.Proposition</code> instance is also an instance of <code>urf.Community</code>, reifying the propositions <code>example.name="John"</code> and <code>example.weight</code> provides two separate knowledge communities, in this case asserting the scoped properties. This is illustrated in the following example, which uses labels to indicate the reification of the asserted propositions relating to <code>example.juan</code>:</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.juan:
    example.name|juanNameJohn|="John"
    |juanNameJohn|¤
      "John":
        example.lang=example.english
      ;
    .
    example.weight|juanWeight72|=#72#
    |juanWeight72|¤
      #72#:
        example.unit=example.kilogram
      ;
    .
  ;
.</code></pre>
			</figure>
			<p>Referring to labeled assertions represent the reification of those propositions, and property declarations within a community (which itself may be another reified proposition) represent reified propositions asserted within that community. Therefore, the previous example can be represented in a more fully reified form (using proposition short forms):</p>
			<figure>
				<pre><code class="language-turf">`URF:
  "urf"~&lt;http://urf.name/urf/&gt;
  "example"~&lt;http://example.com/example/&gt;
;¤
  example.juan:
    example.name="John"
    example.weight=#72#
    “example.juan, example.name, "John"”{
      “"John", example.lang, example.english”
    }
    “example.juan, example.weight, #72#”{
      “#72#, example.unit, example.kilogram”
    }
  ;
.</code></pre>
			</figure>
			<p>Note that <code>example.name="John"</code> and <code>example.weight=#72#</code> are listed separately as assertions of John's name and weight; those two propositions are later explicitly reified as propositions and serve as separate knowledge communities containing other assertions about the name <code>"John"</code> and the weight <code>#72#</code>.</p>
		</dd>
	</dl>
	<h2>References</h2>
	<dl>
		<dt>DCMI Namespace</dt>
		<dd>Andy Powell and Harry Wagner. <a href="http://dublincore.org/documents/dcmi-namespace/"><cite>Namespace Policy for the Dublin Core Metadata Initiative (DCMI)</cite></a>. Dublin Core Namespace Initiative, 2007.</dd>
		<dt>Guise</dt>
		<dd><a href="http://www.guiseframework.com/"><cite>Guise™ Internet Application Framework</cite></a>. GlobalMentor, Inc.</dd>
		<dt>IANA Charset Registry</dt>
		<dd><a href="http://www.iana.org/assignments/character-sets"><cite>IANA Charset Registry</cite></a>. Internet Assigned Numbers Authority.</dd>
		<dt>ISO 8601</dt>
		<dd><cite>ISO 8601:2004(E): Data elements and interchange formats — Information interchange — Representation of dates and times</cite>. International Organization for Standardization, 2004-12-01.</dd>
		<dt>RDF/XML</dt>
		<dd>Dave Beckett. <a href="http://www.w3.org/TR/rdf-syntax-grammar/"><cite>RDF/XML Syntax Specification (Revised)</cite></a>. World Wide Web Consortium, 2006-02-10.</dd>
		<dt>RFC 2046</dt>
		<dd>N. Freed and N. Borenstein. <a href="http://www.ietf.org/rfc/rfc2046.txt"><cite>RFC 2046: Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</cite></a>. Internet Engineering Task Force, 1996.</dd>
		<dt>RFC 2130</dt>
		<dd>C. Weider, C. Preston, K. Simonsen, H. Alvestrand, R. Atkinson, M. Crispin, and P. Svanberg. <a href="http://www.ietf.org/rfc/rfc2278.txt"><cite>RFC 2130: The Report of the IAB Character Set Workshop held 29 February - 1 March, 1996</cite></a>. Internet Engineering Task Force, 1997.</dd>
		<dt>RFC 2278</dt>
		<dd>N. Freed and J. Postel. <a href="http://www.ietf.org/rfc/rfc2278.txt"><cite>RFC 2278: IANA Charset Registration Procedures</cite></a>. Internet Engineering Task Force, 1998.</dd>
		<dt>RFC 2426</dt>
		<dd>F. Dawson and T. Howes. <a href="http://www.ietf.org/rfc/rfc2426.txt"><cite>RFC 2426: vCard MIME Directory Profile</cite></a>. Internet Engineering Task Force, 1998.</dd>
		<dt>RFC 2445</dt>
		<dd>F. Dawson and and D. Stenerson. <a href="http://www.ietf.org/rfc/rfc2426.txt"><cite>RFC 2445: Internet Calendaring and Scheduling Core Object Specification (iCalendar)</cite></a>. Internet Engineering Task Force, 1998.</dd>
		<dt>RFC 3339</dt>
		<dd>G. Klyne and C. Newman. <a href="http://www.ietf.org/rfc/rfc3339.txt"><cite>RFC 3339: Date and Time on the Internet: Timestamps</cite></a>. Internet Engineering Task Force, 2002.</dd>
		<dt>RFC 3966</dt>
		<dd>H. Schulzrinne. <a href="http://www.ietf.org/rfc/rfc3966.txt"><cite>RFC 3966: The tel URI for Telephone Numbers</cite></a>. Internet Engineering Task Force, 2004.</dd>
		<dt>RFC 3986</dt>
		<dd>T. Berners-Lee, R. Fielding, and L. Masinter. <a href="http://www.ietf.org/rfc/rfc3986.txt"><cite>RFC 3986: Uniform Resource Identifier (URI): Generic Syntax</cite></a>. Internet Engineering Task Force, 2005.</dd>
		<dt>RFC 4627</dt>
		<dd>D. Crockford. <a href="http://www.ietf.org/rfc/rfc4627.txt"><cite>RFC 4627: The application/json Media Type for JavaScript Object Notation (JSON)</cite></a>. Internet Engineering Task Force, 2006.</dd>
		<dt>RFC 4646</dt>
		<dd>A. Phillips and M. Davis. <a href="http://www.ietf.org/rfc/rfc4646.txt"><cite>RFC 4646: Tags for Identifying Languages</cite></a>. Internet Engineering Task Force, 2006.</dd>
		<dt>RFC 4648</dt>
		<dd>S. Josefsson. <a href="http://www.ietf.org/rfc/rfc4648.txt"><cite>RFC 4648: The Base16, Base32, and Base64 Data Encodings</cite></a>. Internet Engineering Task Force, 2006.</dd>
		<dt>Unicode BOM FAQ</dt>
		<dd>Asmus Freytag and Mark Davis. <a href="http://www.unicode.org/unicode/faq/utf_bom.html#BOM"><cite>Unicode Byte Order Mark (BOM) FAQ</cite></a>. Unicode, Inc., Retrieved 2006-06-07.</dd>
		<dt>UTR #13</dt>
		<dd>Mark Davis. <a href="http://unicode.org/unicode/standard/reports/tr13/tr13-5.html"><cite>Unicode Technical Report #13: Unicode Newline Guidelines</cite><cite></cite></a>. Unicode, Inc., 1999.</dd>
		<dt>XML Schema 2</dt>
		<dd>Paul V. Biron and Ashok Malhotra. <a href="http://www.w3.org/TR/xmlschema-2/"><cite>XML Schema Part 2: Datatypes Second Edition</cite></a>. World Wide Web Consortium, 2004-10-28.</dd>
	</dl>
	<h2>Acknowledgements</h2>
	<p>Brad Neuberg encouraged the creation of an alternate RDF serialization; Frank Manola made convincing arguments for using ordinals instead of integers as list element predicates.</p>
	<h2>History</h2>
	<dl>
		<dt>2017-09-25</dt>
		<dd>
			<ul>
				<li>Split out original URF specification into separate <cite>URF Specification</cite>, <cite>TURF Specification</cite>, and <cite>URF Primer</cite> documents.</li>
			</ul>
		</dd>
		<dt>2009-09-06</dt>
		<dd>
			<ul>
				<li>Change namespace URI rules to only allow namespace URIs that are collection URIs.</li>
				<li>Renamed "lexical namespace/URI" to "inline namespace/URI" and improved the corresponding semantics.</li>
				<li>Renamed <code>urf.Real</code> to <code>urf.Rational</code>.</li>
			</ul>
		</dd>
	</dl>
	<dl>
		<dt>2009-08-24</dt>
		<dd>
			<ul>
				<li>Changed grammar to allow Unicode newline characters as separators.</li>
				<li>Changed TURF content type to <code>text/urf</code>.</li>
			</ul>
		</dd>
	</dl>
	<dl>
		<dt>2008-01-20 </dt>
		<dd>
			<ul>
				<li>Improved semantics of <code>urf.Map</code> by adding map entries to distinguish between properties and map key/value associations.</li>
				<li>Added delimiters for <code>urf.Map</code> TURF short form.</li>
				<li>Changed delimiter of <code>urf.Boolean</code> TURF short form.</li>
				<li>Modified <code>urf.type</code> TURF short form syntax.</li>
				<li>Introduced <code>urf.selector</code> property with TURF short form.</li>
				<li>Removed <code>urf.inits</code> property.</li>
				<li>Documented <code>urf.subClassOf</code> and <code>urf.implementationOf</code> properties.</li>
				<li>Added TURF superclass and interface short forms.</li>
				<li>Renamed <code>content.CharacterEncoding</code> to <code>content.Charset</code>.</li>
			</ul>
		</dd>
		<dt>2007-12-31</dt>
		<dd>
			<ul>
				<li>Added <code>content.CharacterEncoding</code> class.</li>
				<li>Renamed URF reference implementation Java package.</li>
			</ul>
		</dd>
		<dt>2007-12-23</dt>
		<dd>
			<ul>
				<li>Changed TURF preamble delimiters.</li>
				<li>Changed TURF namespace association delimiter.</li>
				<li>Changed syntax for <code>urf.Boolean</code> short form.</li>
				<li>Changed order of string and type in TURF lexical form reference.</li>
				<li>Brought back requirement for ending delimiters for TURF number, temporal, and ordinal short representations to prevent an ambigious grammar.</li>
			</ul>
		</dd>
		<dt>2007-11-22</dt>
		<dd>
			<ul>
				<li>Changed syntax for <code>urf.Boolean</code> short form.</li>
				<li>Changed the TURF preface delimiter.</li>
			</ul>
		</dd>
		<dt>2007-11-18</dt>
		<dd>
			<ul>
				<li>Added TURF preamble.</li>
				<li>Improved TURF name grammar.</li>
				<li>Simplified TURF name namespace inheritance rules.</li>
				<li>Changed <code>urf.MediaType</code> to <code>content.MediaType</code>.</li>
				<li>Simplified PLOOP processing rules.</li>
				<li>Addressed merging of ordered properties.</li>
				<li>Changed syntax for <code>urf.Enum</code> value declarations.</li>
				<li>Introducted <code>urf.Community</code>.</li>
				<li>Reframed semantics of scoped properties in terms of URF communities.</li>
				<li>Added <code>urf.Proposition</code> short form.</li>
				<li>Changed comment syntax.</li>
				<li>Expanded rules for URI namespace determination.</li>
				<li>Changed syntax for <code>urf.Boolean</code> short form.</li>
			</ul>
		</dd>
		<dt>2007-10-16</dt>
		<dd>
			<ul>
				<li>Changed order of TURF properties declaration.</li>
				<li>Added <code>urf.init</code> property.</li>
				<li>Added PLOOP specification.</li>
				<li>Improved and clarified TURF namespace inheritance rules.</li>
				<li>Added list of ontologies along with links to their TURF definitions.</li>
				<li>Added RDF/XML example.</li>
				<li>Added PLOOP example.</li>
				<li>Added reference implementation links.</li>
				<li>Improved and simplified TURF URI and URI reference lexical form representation.</li>
				<li>Clarified and extended <code>urf.Temporal</code> types.</li>
				<li>Changed base lexical namespace URI to <code>&lt;http://urf.name/lexical/&gt;</code>.</li>
				<li>Added <code>urf.Language</code> type.</li>
				<li>Added <code>urf.MediaType</code> type.</li>
				<li>Changed PLOOP example to use <code>java:</code> URIs.</li>
				<li>Removed trailing delimiter from TURF temporal short forms.</li>
				<li>Added <code>urf.Enum</code> description.</li>
			</ul>
		</dd>
		<dt>2007-10-05</dt>
		<dd>
			<ul>
				<li>Added TURF Internet media type.</li>
				<li>Removed requirement that TURF strings must escape control characters.</li>
				<li>Added period to set of name characters.</li>
				<li>Added comments to TURF.</li>
				<li>Clarified and expanded TURF Unicode control escape sequences.</li>
				<li>Clarified and expanded namespace rules.</li>
				<li>Added <code>urf.Binary</code> type.</li>
				<li>Added <code>urf.Ordinal</code> type.</li>
				<li>Changed arrays to use ordinal indexes.</li>
				<li>Removed trailing delimiter from TURF number short forms.</li>
				<li>Removed trailing delimiter from TURF boolean short forms.</li>
				<li>Changed TURF boolean short form delimiter.</li>
				<li>Changed TURF name short form prefix delimiter.</li>
				<li>Changed TURF properties section delimiter.</li>
				<li>Improved TURF name grammar.</li>
				<li>Added <code>urf.Set</code> type.</li>
				<li>Renamed <code>urf.Array</code> to <code>urf.List</code>.</li>
				<li>Clarified TURF name reference namespace inheritance.</li>
			</ul>
		</dd>
		<dt>2007-09-15</dt>
		<dd>
			<ul>
				<li>Switched to <code>info:lexical</code> lexical namespaces.</li>
			</ul>
		</dd>
		<dt>2007-09-14</dt>
		<dd>
			<ul>
				<li>Added name reference short form.</li>
				<li>Modified syntax for sequences.</li>
				<li>Switched to <code>info:lexis</code> lexical namespaces.</li>
				<li>Changed property type for array indexes.</li>
				<li>Clarified number types.</li>
				<li>Added delimiters to boolean and number types.</li>
				<li>Added the ID namespace.</li>
				<li>Clarified array grammar.</li>
				<li>Added URF abstract model grammar.</li>
				<li>Added JSON example.</li>
			</ul>
		</dd>
		<dt>2007-09-08</dt>
		<dd>
			<ul>
				<li>Modified and simplified syntax for resource URI references and type declarations.</li>
				<li>Changed <dfn>contextual properties</dfn> to <dfn>scoped properties</dfn>.</li>
			</ul>
		</dd>
		<dt>2007-09-02</dt>
		<dd>
			<ul>
				<li>First public release of URF.</li>
			</ul>
		</dd>
	</dl>
	<footer><small>Copyright © 2007–2017 <a href="http://www.globalmentor.com/">GlobalMentor, Inc.</a>. All Rights Reserved. Content may not be published or reproduced by any means for any purpose without permission. This specification may be freely used for its intended purpose but only in unmodifed form.</small></footer>
	<script src="../../pub/js/prism.js"></script>
</body>

</html>
